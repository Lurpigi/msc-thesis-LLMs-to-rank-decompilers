{
  "pr": "6722",
  "mean_delta_perplexity": 0.0928125,
  "mean_perplexity_base": 1.8928125,
  "mean_perplexity_pr": 1.985625,
  "mean_perplexity_source": 2.2159375,
  "mean_perplexity_base_ast": 2.34875,
  "mean_perplexity_pr_ast": 2.339375,
  "mean_perplexity_source_ast": 2.7121875,
  "results": {
    "qwen-coder": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type*id){\n  if(!id)return id;\n  type id = idnumidnum;\n  type id = idnumidnum;\n  type *id = ;\n  type id = num;\n  type id = id;\n  call();\n  do{\n    if(id > num){\n      call(, (type)id->id);\n      call(, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, num, num, id->id) != num){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == ){\n        if(id)call(id, , (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, num, id.id, id->id) != id.id){\n        if(id)call(id, );\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[num] op (id[num] op num) != num);\n        id->id = id[num] op (id[num] op num);\n        if(id){\n          call(, (id->id ?  : ));\n          call(, id->id);\n        }\n        break;\n      case id:\n        id->id = id[num] op (id[num] op num);\n        if(id)call(, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call();\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }else{\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type ;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            if(id)call(, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type ;\n          id = (type)id;\n          call(, id->id op num);\n          if(id->id op num){\n            call(, id->id);\n            call(, id->id);\n          }else{\n            type *id = call((type)&id[num], id.id op num, num, id);\n            call(, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > num){\n          type *id = id op num;\n          type id, id;\n          id = id[num] op (id[num] op num);\n          for(id = num;  id < id; upd id){\n            call(, id op num, id[num], id[num], id[num]);\n            id = num;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call();\n          for(id = num;  id < id.id; upd id)call(, id[id]);\n          call();\n        }\n        break;\n      case def:\n        if(id){\n          call(, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = num;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)(type)id[num]);\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = call(id) op id;\n            *(type)((type)id op num) = (id) op id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)(type)id[num]);\n              call(, (id) op (type)((type)id op num));\n              call(, (type)(type)id[num]);\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (type)(type)id[id op num op num], (id) op (type)((type)id op id op num op num), (type)(type)id[id op num op num]);\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (type)(type)id[num]);\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)*(type)(id op num));\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = (type)call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = (id) op (type)id;\n            *(type)((type)id op num) = *(type)id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (id) op (type)(id op num));\n              call(, (id) op (type)((type)id op num));\n              call(, (id) op (type)(id op num));\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (id) op (type)(id op id op num op num), (id) op (type)((type)id op id op num op num), (id) op (type)(id op id op num op num));\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (id) op (type)(id op num));\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 2.0,
          "pr_ppl": 2.0,
          "source_ast_ppl": 2.375,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A contains high-level loop structures and idiomatic programming patterns such as switch statements, while Candidate B relies heavily on low-level jumps and nested conditional logic.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type*id){\n  if(!id)return id;\n  type id = idnumidnum;\n  type id = idnumidnum;\n  type *id = ;\n  type id = num;\n  type id = id;\n  call();\n  do{\n    if(id > num){\n      call(, (type)id->id);\n      call(, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, num, num, id->id) != num){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == ){\n        if(id)call(id, , (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, num, id.id, id->id) != id.id){\n        if(id)call(id, );\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[num] op (id[num] op num) != num);\n        id->id = id[num] op (id[num] op num);\n        if(id){\n          call(, (id->id ?  : ));\n          call(, id->id);\n        }\n        break;\n      case id:\n        id->id = id[num] op (id[num] op num);\n        if(id)call(, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call();\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }else{\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type ;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            if(id)call(, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type ;\n          id = (type)id;\n          call(, id->id op num);\n          if(id->id op num){\n            call(, id->id);\n            call(, id->id);\n          }else{\n            type *id = call((type)&id[num], id.id op num, num, id);\n            call(, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > num){\n          type *id = id op num;\n          type id, id;\n          id = id[num] op (id[num] op num);\n          for(id = num;  id < id; upd id){\n            call(, id op num, id[num], id[num], id[num]);\n            id = num;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call();\n          for(id = num;  id < id.id; upd id)call(, id[id]);\n          call();\n        }\n        break;\n      case def:\n        if(id){\n          call(, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = num;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)(type)id[num]);\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = call(id) op id;\n            *(type)((type)id op num) = (id) op id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)(type)id[num]);\n              call(, (id) op (type)((type)id op num));\n              call(, (type)(type)id[num]);\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (type)(type)id[id op num op num], (id) op (type)((type)id op id op num op num), (type)(type)id[id op num op num]);\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (type)(type)id[num]);\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)*(type)(id op num));\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = (type)call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = (id) op (type)id;\n            *(type)((type)id op num) = *(type)id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (id) op (type)(id op num));\n              call(, (id) op (type)((type)id op num));\n              call(, (id) op (type)(id op num));\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (id) op (type)(id op id op num op num), (id) op (type)((type)id op id op num op num), (id) op (type)(id op id op num op num));\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (id) op (type)(id op num));\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 2.0,
          "pr_ppl": 2.0,
          "source_ast_ppl": 2.375,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A contains a high-level loop structure, while Candidate B relies heavily on low-level jumps and nested conditional statements.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch(*(undefined *)(param_2 + 3)) {\n    case 1:\n      local_28 = (long)(char)param_3;\n      break;\n    case 2:\n    case 7:\n    case 10:\n      local_28 = (long)(short)param_3;\n      break;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x29:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      local_28 = (long)(int)param_3;\n      break;\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",*(undefined *)(param_2 + 3));\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "type id(type*id, type*id, typeid){\n  if(!(id->id op id)){\n    switch(id->id){\n      case id:\n        id = call(id, id, id);\n        break;\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        break;\n      case def:\n        if(id->id op id)call(id, , id->id);\n        return id;\n    }\n  }\n  return id;\n}",
        "base_ast": " id(id, type*id, id){\n  type id;\n  id = id;\n  if((*id op num) == num){\n    switch((type)id[num]){\n      case :\n        id = (type)(type)id;\n        break;\n      case :\n      case :\n      case :\n        id = (type)(type)id;\n        break;\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        break;\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        id = (type)(type)id;\n        break;\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        break;\n      case def:\n        if((*(type)(id op num) op num) != num){\n          call(id, , (type)id[num]);\n        }\n        return num;\n    }\n  }\n  return id;\n}",
        "pr_ast": " id(id, type*id, id){\n  type id;\n  id = id;\n  if((*id op num) == num){\n    switch(*(type)(id op num)){\n      case num:\n        id = (type)(type)id;\n        break;\n      case num:\n      case num:\n      case num:\n        id = (type)(type)id;\n        break;\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n        break;\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n        id = (type)(type)id;\n        break;\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n        break;\n      case def:\n        if((*(type)(id op num) op num) != num){\n          call(id, , *(type)(id op num));\n        }\n        return num;\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 1.8046875,
          "source_ast_ppl": 1.9140625,
          "base_ast_ppl": 2.5,
          "pr_ast_ppl": 2.078125,
          "delta_ppl": -0.3671875
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar3 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(local_18 + 1));\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = *(byte *)local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(local_28 + 5));\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(local_28 + 6));\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar3) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)*(byte *)local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              bVar1 = *(byte *)local_28;\n              bVar2 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)bVar1 + (uint)bVar2 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)*(byte *)local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)*(byte *)(local_78 + 1));\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(local_28 + 1));\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)*(byte *)local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 !=\n                       0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)*(byte *)(local_28 + 1) +\n                       (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar3 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type*id){\n  if(!id)return id;\n  type id = idnumidnum;\n  type id = idnumidnum;\n  type *id = ;\n  type id = num;\n  type id = id;\n  call();\n  do{\n    if(id > num){\n      call(, (type)id->id);\n      call(, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, num, num, id->id) != num){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == ){\n        if(id)call(id, , (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, num, id.id, id->id) != id.id){\n        if(id)call(id, );\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[num] op (id[num] op num) != num);\n        id->id = id[num] op (id[num] op num);\n        if(id){\n          call(, (id->id ?  : ));\n          call(, id->id);\n        }\n        break;\n      case id:\n        id->id = id[num] op (id[num] op num);\n        if(id)call(, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call();\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }else{\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type ;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            if(id)call(, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type ;\n          id = (type)id;\n          call(, id->id op num);\n          if(id->id op num){\n            call(, id->id);\n            call(, id->id);\n          }else{\n            type *id = call((type)&id[num], id.id op num, num, id);\n            call(, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > num){\n          type *id = id op num;\n          type id, id;\n          id = id[num] op (id[num] op num);\n          for(id = num;  id < id; upd id){\n            call(, id op num, id[num], id[num], id[num]);\n            id = num;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call();\n          for(id = num;  id < id.id; upd id)call(, id[id]);\n          call();\n        }\n        break;\n      case def:\n        if(id){\n          call(, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = num;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = id;\n    call(&id, num, num);\n    call(&id, num, num);\n    id = (type)num;\n    id = bool;\n    id = num;\n    call();\n    do{\n      if(num < *(type)id){\n        call(, (type)(type)id[num]);\n        call(, (id) op (type)(*id op num), *(type)(*id op num) op num, *(type)(*id op num) op num, *(type)(*id op num) op num);\n      }\n      id = call(&id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(&id);\n      if(*(type)id != num){\n        call(&id);\n      }\n      if(id.id != num){\n        id = call(id, (type)id.id);\n        if(id == (type)num){\n          if(*(type)id != num){\n            call(*(type)id, , (type)id.id);\n          }\n          id = num;\n          break;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != num){\n            call(*(type)id, );\n          }\n          id = num;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      id = id op num;\n      if(id != num){\n        if(id == num){\n          if(*(type)id != num){\n            call();\n            for(id = num;  id < (type)(id op num); id = id op num){\n              call(, (id) op (type)((type)id op (type)id));\n            }\n            call();\n          }\n        }elseif(id == num){\n          *(type)((type)id op num) = (id) op id;\n          if(*(type)id != num){\n            call(, (id) op (type)((type)id op num));\n          }\n        }else{\n          if(id == num){\n            id = num;\n            break;\n          }\n          if(id == num){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)(type)id[num]);\n              call(, (id) op (type)((type)id op num));\n              call(, (type)(type)id[num]);\n              if(id != num){\n                call(, id);\n              }\n            }\n          }elseif(id == num){\n            if(id){\n              if(((type)id == num) && (id = call(id, id, id.id)id != num))break;\n              id = id;\n            }\n          }elseif(id == num){\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, (id) op id op num, (id) op id op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n            }\n          }elseif(id == num){\n            *(type)((type)id op num) = call(id) op id op (id) op (type)((type)id op num) op num;\n            if(*(type)id != num){\n              call(, (id) op (type)((type)id op num));\n            }\n          }elseif(id == num){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != num)break;\n          }elseif(id == num){\n            if(num < *(type)id){\n              id = id op num;\n              id = *id;\n              id = *(type)((type)id op num);\n              for(id = num;  id < (type)((type)(type)id op (type)id op num); id = id op num){\n                call(, call(id op num), call(id) op id, (id) op (type)((type)id op num), (type)(type)id[num]);\n                id = id op num;\n              }\n            }\n          }elseif(id == num){\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(, (id) op id);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n              }\n            }\n          }else{\n            if(id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id == num){\n                if(*(type)id != num){\n                  call(, call(*id op num));\n                  if((*id op num) == num){\n                    id = (type)call(id op num, (type)(type)((id op num) op num), num, id);\n                    call(, id);\n                    call(id);\n                  }else{\n                    call(, (type)(type)id[num]);\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }\n              }else{\n                if(id == num){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == num){\n                  *(type)((type)id op num) = call(id) op id op (id) op (type)((type)id op num) op num != num;\n                  *(type)((type)id op num) = (type)(type)id[num] op (id) op (type)((type)id op num) op num;\n                  if(*(type)id != num){\n                    id = ;\n                    if(*(type)((type)id op num) != ){\n                      id = ;\n                    }\n                    call(, id);\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }elseif(*(type)id != num){\n                  call(, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id op num) == ){\n        id = (type)id != num;\n      }\n    }while(id);\n    if(id != (type)num){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = id;\n    call(&id, num, num);\n    call(&id, num, num);\n    id = (type)num;\n    id = bool;\n    id = num;\n    call();\n    do{\n      if(num < *(type)id){\n        call(, (type)*(type)(id op num));\n        call(, (id) op (type)(*id op num), *(type)(*id op num) op num, *(type)(*id op num) op num, *(type)(*id op num) op num);\n      }\n      id = call(&id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(&id);\n      if(*(type)id != num){\n        call(&id);\n      }\n      if(id.id != num){\n        id = (type)call(id, (type)id.id);\n        if(id == (type)num){\n          if(*(type)id != num){\n            call(*(type)id, , (type)id.id);\n          }\n          id = num;\n          break;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != num){\n            call(*(type)id, );\n          }\n          id = num;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      id = id op num;\n      if(id != num){\n        if(id == num){\n          if(*(type)id != num){\n            call();\n            for(id = num;  id < (type)(id op num); id = id op num){\n              call(, (id) op (type)((type)id op (type)id));\n            }\n            call();\n          }\n        }elseif(id == num){\n          *(type)((type)id op num) = *(type)id;\n          if(*(type)id != num){\n            call(, (id) op (type)((type)id op num));\n          }\n        }else{\n          if(id == num){\n            id = num;\n            break;\n          }\n          if(id == num){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (id) op (type)(id op num));\n              call(, (id) op (type)((type)id op num));\n              call(, (id) op (type)(id op num));\n              if(id != num){\n                call(, id);\n              }\n            }\n          }elseif(id == num){\n            if(id){\n              if(((type)id == num) && (id = call(id, id, id.id)id != num))break;\n              id = id;\n            }\n          }elseif(id == num){\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, (id) op id op num, (id) op id op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n            }\n          }elseif(id == num){\n            *(type)((type)id op num) = (id) op (type)id op (id) op (type)((type)id op num) op num;\n            if(*(type)id != num){\n              call(, (id) op (type)((type)id op num));\n            }\n          }elseif(id == num){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != num)break;\n          }elseif(id == num){\n            if(num < *(type)id){\n              id = id op num;\n              id = *(type)id;\n              id = *(type)((type)id op num);\n              for(id = num;  id < (type)((type)id op (type)id op num); id = id op num){\n                call(, call(id op num), (id) op (type)id, (id) op (type)((type)id op num), (id) op (type)(id op num));\n                id = id op num;\n              }\n            }\n          }elseif(id == num){\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(, (id) op id);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n              }\n            }\n          }else{\n            if(id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id == num){\n                if(*(type)id != num){\n                  call(, call(*id op num));\n                  if((*id op num) == num){\n                    id = (type)call(id op num, (type)(type)((id op num) op num), num, id);\n                    call(, id);\n                    call(id);\n                  }else{\n                    call(, (id) op (type)(id op num));\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }\n              }else{\n                if(id == num){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == num){\n                  *(type)((type)id op num) = (id) op (type)id op (id) op (type)((type)id op num) op num != num;\n                  *(type)((type)id op num) = (id) op (type)(id op num) op (id) op (type)((type)id op num) op num;\n                  if(*(type)id != num){\n                    id = ;\n                    if(*(type)((type)id op num) != ){\n                      id = ;\n                    }\n                    call(, id);\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }elseif(*(type)id != num){\n                  call(, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id op num) == ){\n        id = (type)id != num;\n      }\n    }while(id);\n    if(id != (type)num){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 1.96875,
          "pr_ppl": 1.9609375,
          "source_ast_ppl": 2.375,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type ;\n  type *id = ;\n  type id = num;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), , id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), , id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = ;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), , id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = (type)call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = (type)call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.40625,
          "base_ast_ppl": 2.203125,
          "pr_ast_ppl": 2.1875,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar patterns and logic, but Candidate A uses more idiomatic programming constructs such as `if`, `do-while`, and `switch` statements, which are indicative of human-like code. In contrast, Candidate B relies heavily on repetitive low-level control flow constructs like nested loops and conditional branches without clear higher-level abstractions.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type ;\n  type *id = ;\n  type id = num;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), , id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), , id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = ;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), , id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = (type)call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = (type)call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.40625,
          "base_ast_ppl": 2.203125,
          "pr_ast_ppl": 2.1875,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses higher-level constructs like `if` statements and loops more effectively, indicating a cleaner and more human-like design.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type id = num;\n  type *id = ;\n  type id = num;\n  type id = num op id;\n  type *id = ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = ;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != ){\n            type id = (*id) op ;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, , (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = (type)call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = (type)call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.9375,
          "pr_ppl": 1.9296875,
          "source_ast_ppl": 2.640625,
          "base_ast_ppl": 2.359375,
          "pr_ast_ppl": 2.359375,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses higher-level constructs such as loops and conditionals more effectively, reducing the overall complexity and improving readability.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type id = num;\n  type *id = ;\n  type id = num;\n  type id = num op id;\n  type *id = ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = ;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != ){\n            type id = (*id) op ;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, , (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = (type)call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = (type)call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.9453125,
          "pr_ppl": 1.9453125,
          "source_ast_ppl": 2.640625,
          "base_ast_ppl": 2.359375,
          "pr_ast_ppl": 2.359375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type ;\n  type *id = ;\n  type id = num;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), , id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), , id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = ;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), , id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != ){\n      id = (type)[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, , id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == ){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, , id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == ){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == ){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, , (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != ){\n      id = (type)[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = (type)call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, , id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == ){\n        id = (type)call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, , id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == ){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == ){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, , (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.71875,
          "pr_ppl": 1.7109375,
          "source_ast_ppl": 2.40625,
          "base_ast_ppl": 2.0625,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Candidate A contains high-level control flow structures such as loops and conditional statements, whereas Candidate B relies heavily on low-level constructs like goto statements, indicating that Candidate A was more likely generated by human programmers using idiomatic programming patterns.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type id = num;\n  type *id = ;\n  type id = num;\n  type id = num op id;\n  type *id = ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = ;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != ){\n            type id = (*id) op ;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, , (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != ){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == ) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, , (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != ){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = (type)call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == ) && (id = (type)call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, , (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.734375,
          "pr_ppl": 1.734375,
          "source_ast_ppl": 2.640625,
          "base_ast_ppl": 2.0625,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses more idiomatic programming constructs such as `for` loops and `switch` statements, which indicate a higher level of human-like logic. Candidate B relies heavily on `while` loops and conditional jumps (`goto`), suggesting it was likely generated by a decompiler rather than hand-written code.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type ;\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.5,
          "pr_ast_ppl": 2.515625,
          "delta_ppl": 0.03125
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type ;\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.5,
          "pr_ast_ppl": 2.515625,
          "delta_ppl": 0.03125
        },
        "llm_ast": {
          "motivation": "Candidate A contains more structured control flow patterns, including loops and conditional statements, which indicate higher-level logic and human-like programming practices. Candidate B, on the other hand, relies heavily on low-level jumps and lacks clear loop constructs.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op );\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.390625,
          "base_ast_ppl": 2.640625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op );\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.390625,
          "base_ast_ppl": 2.640625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Candidate A contains more structured control flow patterns such as loops and conditional statements, which indicate a higher level of abstraction and human-like design. Candidate B, on the other hand, relies heavily on low-level jumps and nested structures, suggesting it was likely generated by a decompiler.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id ==  || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if((id != (type)num) && (id = *idid != num)){\n    id = id op num;\n    id = num;\n    id = num;\n    id = num;\n    id = bool;\n    do{\n      id = num;\n      id = bool;\n      switch(id){\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          id = bool;\n          id = num;\n          break;\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          goto lbl;\n        case num:\n          break;\n        case def:\n          id = num;\n          id = bool;\n          if(num < id op num){\n            return num;\n          }\n      }\n      if(!id){\n        return num;\n      }\n      id = id op id;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      id = id;\n    }while(id != num);\n    if((id == num && id < num) && (id < num)){\n      *id = id;\n      id = num;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 6.21875,
          "base_ast_ppl": 2.65625,
          "pr_ast_ppl": 2.71875,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Candidate A uses more structured control flow constructs such as loops and switches, which are indicative of idiomatic programming patterns. In contrast, Candidate B contains numerous low-level jumps and lacks clear loop structures, suggesting it may be a decompiled version.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id ==  || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if((id != (type)num) && (id = *idid != num)){\n    id = id op num;\n    id = num;\n    id = num;\n    id = num;\n    id = bool;\n    do{\n      id = num;\n      id = bool;\n      switch(id){\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          id = bool;\n          id = num;\n          break;\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          goto lbl;\n        case num:\n          break;\n        case def:\n          id = num;\n          id = bool;\n          if(num < id op num){\n            return num;\n          }\n      }\n      if(!id){\n        return num;\n      }\n      id = id op id;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      id = id;\n    }while(id != num);\n    if((id == num && id < num) && (id < num)){\n      *id = id;\n      id = num;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 6.21875,
          "base_ast_ppl": 2.65625,
          "pr_ast_ppl": 2.71875,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Candidate A uses higher-level control flow constructs such as `do-while` loops and `switch` statements, indicating a more human-like and logical design. Candidate B contains numerous low-level jumps (`goto`) and nested conditions, suggesting it was likely decompiled from a lower-level representation.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013e6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013e6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        if(id == num)goto lbl;\n        lbl:\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        id = *id;\n        if(id != num)goto lbl;\n        lbl:\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        call(id op num, num);\n        call(id op num, num);\n        id = call(num);\n        id = call(id op num, id op num, (type)id);\n        if(id != num){\n          return num;\n        }\n        id = call(id op id, *id op id, id[num]);\n        id[num] = id;\n        *id = num;\n      case num:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return num;\n          }\n          id = id[num];\n          id = id[num];\n          *id = id op num;\n          if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n          id = *id;\n          *id = id op num;\n          if(num < id op num){\n            return num;\n          }\n        }\n        return num;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.46875,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.9453125,
          "source_ast_ppl": 3.484375,
          "base_ast_ppl": 2.625,
          "pr_ast_ppl": 2.625,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "Candidate A contains more structured control flow patterns such as `for` loops and `switch` statements, indicating higher-level logic and human-like design. Candidate B uses only `do-while` loops and nested `if-else` statements, which suggest lower-level control flow graph artifacts.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013d6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013d6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        if(id == num)goto lbl;\n        lbl:\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        id = *id;\n        if(id != num)goto lbl;\n        lbl:\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        call(id op num, num);\n        call(id op num, num);\n        id = call(num);\n        id = call(id op num, id op num, (type)id);\n        if(id != num){\n          return num;\n        }\n        id = call(id op id, *id op id, id[num]);\n        id[num] = id;\n        *id = num;\n      case num:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return num;\n          }\n          id = id[num];\n          id = id[num];\n          *id = id op num;\n          if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n          id = *id;\n          *id = id op num;\n          if(num < id op num){\n            return num;\n          }\n        }\n        return num;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.46875,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.9453125,
          "source_ast_ppl": 3.484375,
          "base_ast_ppl": 2.640625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, including a `do-while` loop and nested `switch-case` statements, which indicate a more logical and human-like design. Candidate B also contains these structures but has additional redundant labels and unnecessary complexity, making it less clean.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op ;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.21875,
          "base_ppl": 2.234375,
          "pr_ppl": 2.25,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.125,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Candidate A contains higher-level control flow structures such as loops and conditional statements, indicating a more human-like code structure. Candidate B uses low-level constructs like direct memory access and goto statements, suggesting it may be decompiled code.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op ;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.21875,
          "base_ppl": 2.234375,
          "pr_ppl": 2.25,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.125,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id){\n  type *id = ;\n  type id, id;\n  type ;\n  type ;\n  type id, id, id = num;\n  type id = id->id op id;\n  type id = id->id;\n  type *id = call(id op id->id);\n  type id = id->id;\n  type id = num;\n  type id;\n  if((id->id op id) == num)return num;\n  for(id = num;  id < id; id upd){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < num){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == num;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, num, (id));\n      id.id = id;\n      id = call(id, &id, &id) != num;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id op id), id, &id, &id);\n    call(id, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, num, , id, id, id);\n        if(id == num)goto lbl;\n        id = num;\n        if((id->id op id) != num)goto lbl;\n        if(id != id && id != num)goto lbl;\n        if((call(id, (id ?  : ))) == num)goto lbl;\n        if((id = call(id)) == )goto lbl;\n        if(call(id, num, , , id, id) == num){\n          if(call(id, id) != )call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != ){\n          if(call(id, , id) == num){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, ) == num)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = num;\n        break;\n    }\n  }\n  lbl:\n  call(, id);\n  if(id && id.id != id)(type)call(id, &id, );\n  call(id);\n  id->id = id;\n  call(, id);\n  return id;\n}",
        "base_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < num){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "pr_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(num < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.46875,
          "pr_ppl": 2.453125,
          "source_ast_ppl": 4.65625,
          "base_ast_ppl": 3.0625,
          "pr_ast_ppl": 3.03125,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id){\n  type *id = ;\n  type id, id;\n  type ;\n  type ;\n  type id, id, id = num;\n  type id = id->id op id;\n  type id = id->id;\n  type *id = call(id op id->id);\n  type id = id->id;\n  type id = num;\n  type id;\n  if((id->id op id) == num)return num;\n  for(id = num;  id < id; id upd){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < num){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == num;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, num, (id));\n      id.id = id;\n      id = call(id, &id, &id) != num;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id op id), id, &id, &id);\n    call(id, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, num, , id, id, id);\n        if(id == num)goto lbl;\n        id = num;\n        if((id->id op id) != num)goto lbl;\n        if(id != id && id != num)goto lbl;\n        if((call(id, (id ?  : ))) == num)goto lbl;\n        if((id = call(id)) == )goto lbl;\n        if(call(id, num, , , id, id) == num){\n          if(call(id, id) != )call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != ){\n          if(call(id, , id) == num){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, ) == num)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = num;\n        break;\n    }\n  }\n  lbl:\n  call(, id);\n  if(id && id.id != id)(type)call(id, &id, );\n  call(id);\n  id->id = id;\n  call(, id);\n  return id;\n}",
        "base_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < num){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "pr_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(num < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.46875,
          "pr_ppl": 2.453125,
          "source_ast_ppl": 4.65625,
          "base_ast_ppl": 3.0625,
          "pr_ast_ppl": 3.03125,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Candidate A contains numerous low-level control flow constructs such as goto statements and complex nested loops, indicating it was likely decompiled from machine code rather than written by a human programmer. Candidate B, while also containing goto statements, has a more structured layout with fewer deeply nested constructs, suggesting a higher likelihood of being handwritten or generated by a more sophisticated tool.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id){\n  type id = num;\n  type id = id;\n  type *id = id->id;\n  type *id = call(num, (id));\n  type *id = call(num, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > num)id->id = id->id;\n  if(call(id, id->id) == num){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(num, id, id->id)) == num){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), );\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(num, id, id->id) == num){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), );\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() op id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? num : num);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == ){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == ){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != num){\n    type id = call(id->id, id->id);\n    if(id == (id) op num){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == num){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, num)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), , id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), , call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, typeid){\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = num;\n  id = *(type)((type)id op num);\n  id = id;\n  id = id;\n  id = id;\n  id = call(num, num);\n  id = call(num, num);\n  call(id, id, num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = id;\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = (type)*(type)((type)id op num);\n  if(num < *(type)((type)id op num)){\n    *(type)((type)id op num) = (type)*(type)((type)id op num);\n  }\n  id = call(id, id[num]);\n  if(id == num){\n    id = num;\n  }else{\n    id = call(num, num, id[num]);\n    *(type)((type)id op num) = id;\n    if(id == num){\n      id = num;\n      if(*(type)((type)id op num) != num){\n        call((type)((type)id op num), num, );\n        call((type)id op num, *(type)((type)id op num));\n      }\n    }else{\n      id = call(num, num, id[num]);\n      if(id == num){\n        id = num;\n        if(*(type)((type)id op num) != num){\n          call((type)((type)id op num), num, );\n          call((type)id op num, *(type)((type)id op num));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id op num), id);\n        if(id == num){\n          *(type)((type)id op num) = id[num];\n          *(type)((type)id op num) = *id;\n          *(type)((type)id op num) = id[num];\n          id = call();\n          *(type)((type)id op num) = id op *id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          id = num;\n          if(*(type)((type)id op num) != num){\n            id = num;\n          }\n          *(type)((type)id op num) = (type)id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = id[num];\n          if(*(type)((type)id op num) == num){\n            *(type)((type)id op num) = *(type)(id op num);\n          }\n          id = call(*(type)((type)id op num));\n          *(type)((type)id op num) = id;\n          if(id == num){\n            id = num;\n          }else{\n            if(((*(type)((type)id op num) != num) && (*(type)((type)id op num) != num)) && (id = call(*(type)((type)id op num), *(type)((type)id op num))id != num)){\n              id = call(*(type)((type)id op num), *(type)((type)id op num));\n              if(id == (type)num){\n                id = num;\n                goto lbl;\n              }\n              *(type)((type)id op num) = id;\n            }\n            id = call((type)id op num, num, id op num, num, *(type)((type)id op num));\n            if(((id == num) && (id = call(id, &id)id == num)) && (id = call(id, id)id == num)){\n              id = call(*(type)((type)id op num), num, id[num]);\n              if(id == num){\n                id = num;\n                if(*(type)((type)id op num) != num){\n                  call((type)((type)id op num), num, , *(type)((type)id op num));\n                  call((type)id op num, *(type)((type)id op num));\n                }\n              }else{\n                id = call(id);\n                if((id == num) && (id = call(id, num)id == num)){\n                  if((*(type)((type)id op num) == num) || (*(type)((type)id op num) == *(type)((type)id op num))){\n                    id = call(id);\n                  }else{\n                    id = num;\n                    if(*(type)((type)id op num) != num){\n                      call((type)((type)id op num), num, , (id) op (type)((type)id op num), (id) op (type)((type)id op num));\n                      call((type)id op num, *(type)((type)id op num));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[num]);\n  if((((id == num) || (id == num)) || (id == num)) && (*(type)((type)id op num) != num)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id op num), num, , id, (type)id, id, *id);\n    call((type)id op num, id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, typeid){\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = num;\n  id = *(type)((type)id op num);\n  id = id;\n  id = id;\n  id = id;\n  id = call(num, num);\n  id = (type)call(num, num);\n  call(id, id, num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = id;\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = (type)*(type)((type)id op num);\n  if(num < *(type)((type)id op num)){\n    *(type)((type)id op num) = (type)*(type)((type)id op num);\n  }\n  id = call(id, id[num]);\n  if(id == num){\n    id = num;\n  }else{\n    id = call(num, num, id[num]);\n    *(type)((type)id op num) = id;\n    if(id == num){\n      id = num;\n      if(*(type)((type)id op num) != num){\n        call((type)((type)id op num), num, );\n        call((type)id op num, *(type)((type)id op num));\n      }\n    }else{\n      id = call(num, num, id[num]);\n      if(id == num){\n        id = num;\n        if(*(type)((type)id op num) != num){\n          call((type)((type)id op num), num, );\n          call((type)id op num, *(type)((type)id op num));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id op num), id);\n        if(id == num){\n          *(type)((type)id op num) = id[num];\n          *(type)((type)id op num) = *id;\n          *(type)((type)id op num) = id[num];\n          id = call();\n          *(type)((type)id op num) = id op *id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          id = num;\n          if(*(type)((type)id op num) != num){\n            id = num;\n          }\n          *(type)((type)id op num) = (type)id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = id[num];\n          if(*(type)((type)id op num) == num){\n            *(type)((type)id op num) = *(type)(id op num);\n          }\n          id = call(*(type)((type)id op num));\n          *(type)((type)id op num) = id;\n          if(id == num){\n            id = num;\n          }else{\n            if(((*(type)((type)id op num) != num) && (*(type)((type)id op num) != num)) && (id = call(*(type)((type)id op num), *(type)((type)id op num))id != num)){\n              id = call(*(type)((type)id op num), *(type)((type)id op num));\n              if(id == (type)num){\n                id = num;\n                goto lbl;\n              }\n              *(type)((type)id op num) = id;\n            }\n            id = call((type)id op num, num, id op num, num, *(type)((type)id op num));\n            if(((id == num) && (id = call(id, &id)id == num)) && (id = call(id, id)id == num)){\n              id = call(*(type)((type)id op num), num, id[num]);\n              if(id == num){\n                id = num;\n                if(*(type)((type)id op num) != num){\n                  call((type)((type)id op num), num, , *(type)((type)id op num));\n                  call((type)id op num, *(type)((type)id op num));\n                }\n              }else{\n                id = call(id);\n                if((id == num) && (id = call(id, num)id == num)){\n                  if((*(type)((type)id op num) == num) || (*(type)((type)id op num) == *(type)((type)id op num))){\n                    id = call(id);\n                  }else{\n                    id = num;\n                    if(*(type)((type)id op num) != num){\n                      call((type)((type)id op num), num, , (id) op (type)((type)id op num), (id) op (type)((type)id op num));\n                      call((type)id op num, *(type)((type)id op num));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[num]);\n  if((((id == num) || (id == num)) || (id == num)) && (*(type)((type)id op num) != num)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id op num), num, , id, (type)id, id, *id);\n    call((type)id op num, id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.046875,
          "base_ppl": 1.8125,
          "pr_ppl": 1.8046875,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 1.96875,
          "pr_ast_ppl": 1.9765625,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow patterns, but Candidate A uses more idiomatic programming constructs like function calls and conditional statements in a more structured manner. Candidate B appears to be a decompiled version with a higher presence of low-level jumps and repetitive code, indicating it may be an artifact of the decompiler rather than human-written code.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O2.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      param_3 = __src;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      param_3 = __src + sVar2;\n      if (pbVar3 < param_3) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    param_3 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    if (pbVar3 <= param_3) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    pbVar7 = __src;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = __src + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    pbVar7 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid){\n  type *id = (type)id;\n  type *id = id;\n  type id = num;\n  type *id = (type)id;\n  while(id < (type)id op id){\n    type id = *id upd;\n    type id = (id op num) op num;\n    type id = (id op num);\n    type id = num;\n    type id = num;\n    type id = ;\n    if(id op id[id] > (type)id op id){\n      return num;\n    }\n    switch(id){\n      case id:\n        id = (*id upd) op num op id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = *id upd;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = *id upd;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id op id > (type)id op id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    if(num < id){\n      lbl:\n      id = id;\n      id = id;\n      goto lbl;\n    }\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    id = id;\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    id = id;\n    id = id;\n    if(num < id)goto lbl;\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    id = id;\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.7890625,
          "base_ppl": 1.640625,
          "pr_ppl": 1.625,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O3.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid){\n  type *id = (type)id;\n  type *id = id;\n  type id = num;\n  type *id = (type)id;\n  while(id < (type)id op id){\n    type id = *id upd;\n    type id = (id op num) op num;\n    type id = (id op num);\n    type id = num;\n    type id = num;\n    type id = ;\n    if(id op id[id] > (type)id op id){\n      return num;\n    }\n    switch(id){\n      case id:\n        id = (*id upd) op num op id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = *id upd;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = *id upd;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id op id > (type)id op id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    if(num < id){\n      lbl:\n      id = id;\n      goto lbl;\n    }\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    id = id;\n    if(num < id)goto lbl;\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.7890625,
          "base_ppl": 1.640625,
          "pr_ppl": 1.6171875,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": -0.0234375
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      }
    ],
    "deepseek-r1": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type*id){\n  if(!id)return id;\n  type id = idnumidnum;\n  type id = idnumidnum;\n  type *id = ;\n  type id = num;\n  type id = id;\n  call();\n  do{\n    if(id > num){\n      call(, (type)id->id);\n      call(, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, num, num, id->id) != num){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == ){\n        if(id)call(id, , (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, num, id.id, id->id) != id.id){\n        if(id)call(id, );\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[num] op (id[num] op num) != num);\n        id->id = id[num] op (id[num] op num);\n        if(id){\n          call(, (id->id ?  : ));\n          call(, id->id);\n        }\n        break;\n      case id:\n        id->id = id[num] op (id[num] op num);\n        if(id)call(, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call();\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }else{\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type ;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            if(id)call(, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type ;\n          id = (type)id;\n          call(, id->id op num);\n          if(id->id op num){\n            call(, id->id);\n            call(, id->id);\n          }else{\n            type *id = call((type)&id[num], id.id op num, num, id);\n            call(, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > num){\n          type *id = id op num;\n          type id, id;\n          id = id[num] op (id[num] op num);\n          for(id = num;  id < id; upd id){\n            call(, id op num, id[num], id[num], id[num]);\n            id = num;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call();\n          for(id = num;  id < id.id; upd id)call(, id[id]);\n          call();\n        }\n        break;\n      case def:\n        if(id){\n          call(, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = num;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)(type)id[num]);\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = call(id) op id;\n            *(type)((type)id op num) = (id) op id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)(type)id[num]);\n              call(, (id) op (type)((type)id op num));\n              call(, (type)(type)id[num]);\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (type)(type)id[id op num op num], (id) op (type)((type)id op id op num op num), (type)(type)id[id op num op num]);\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (type)(type)id[num]);\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)*(type)(id op num));\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = (type)call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = (id) op (type)id;\n            *(type)((type)id op num) = *(type)id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (id) op (type)(id op num));\n              call(, (id) op (type)((type)id op num));\n              call(, (id) op (type)(id op num));\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (id) op (type)(id op id op num op num), (id) op (type)((type)id op id op num op num), (id) op (type)(id op id op num op num));\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (id) op (type)(id op num));\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.5,
          "base_ppl": 4.3125,
          "pr_ppl": 4.21875,
          "source_ast_ppl": 3.203125,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.765625,
          "delta_ppl": -0.09375
        },
        "llm_ast": {
          "motivation": "B has more standard control flow patterns with fewer goto jumps and cleaner structure, making it more readable and maintainable.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type*id){\n  if(!id)return id;\n  type id = idnumidnum;\n  type id = idnumidnum;\n  type *id = ;\n  type id = num;\n  type id = id;\n  call();\n  do{\n    if(id > num){\n      call(, (type)id->id);\n      call(, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, num, num, id->id) != num){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == ){\n        if(id)call(id, , (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, num, id.id, id->id) != id.id){\n        if(id)call(id, );\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[num] op (id[num] op num) != num);\n        id->id = id[num] op (id[num] op num);\n        if(id){\n          call(, (id->id ?  : ));\n          call(, id->id);\n        }\n        break;\n      case id:\n        id->id = id[num] op (id[num] op num);\n        if(id)call(, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call();\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }else{\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type ;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            if(id)call(, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type ;\n          id = (type)id;\n          call(, id->id op num);\n          if(id->id op num){\n            call(, id->id);\n            call(, id->id);\n          }else{\n            type *id = call((type)&id[num], id.id op num, num, id);\n            call(, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > num){\n          type *id = id op num;\n          type id, id;\n          id = id[num] op (id[num] op num);\n          for(id = num;  id < id; upd id){\n            call(, id op num, id[num], id[num], id[num]);\n            id = num;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call();\n          for(id = num;  id < id.id; upd id)call(, id[id]);\n          call();\n        }\n        break;\n      case def:\n        if(id){\n          call(, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = num;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)(type)id[num]);\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = call(id) op id;\n            *(type)((type)id op num) = (id) op id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)(type)id[num]);\n              call(, (id) op (type)((type)id op num));\n              call(, (type)(type)id[num]);\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (type)(type)id[id op num op num], (id) op (type)((type)id op id op num op num), (type)(type)id[id op num op num]);\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (type)(type)id[num]);\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)*(type)(id op num));\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = (type)call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = (id) op (type)id;\n            *(type)((type)id op num) = *(type)id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (id) op (type)(id op num));\n              call(, (id) op (type)((type)id op num));\n              call(, (id) op (type)(id op num));\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (id) op (type)(id op id op num op num), (id) op (type)((type)id op id op num op num), (id) op (type)(id op id op num op num));\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (id) op (type)(id op num));\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.5,
          "base_ppl": 4.3125,
          "pr_ppl": 4.21875,
          "source_ast_ppl": 3.203125,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.765625,
          "delta_ppl": -0.09375
        },
        "llm_ast": {
          "motivation": "Candidate B exhibits more logical and human-like control flow patterns with cleaner use of loops and conditionals, avoiding excessive goto jumps and spaghetti code.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch(*(undefined *)(param_2 + 3)) {\n    case 1:\n      local_28 = (long)(char)param_3;\n      break;\n    case 2:\n    case 7:\n    case 10:\n      local_28 = (long)(short)param_3;\n      break;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x29:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      local_28 = (long)(int)param_3;\n      break;\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",*(undefined *)(param_2 + 3));\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "type id(type*id, type*id, typeid){\n  if(!(id->id op id)){\n    switch(id->id){\n      case id:\n        id = call(id, id, id);\n        break;\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        break;\n      case def:\n        if(id->id op id)call(id, , id->id);\n        return id;\n    }\n  }\n  return id;\n}",
        "base_ast": " id(id, type*id, id){\n  type id;\n  id = id;\n  if((*id op num) == num){\n    switch((type)id[num]){\n      case :\n        id = (type)(type)id;\n        break;\n      case :\n      case :\n      case :\n        id = (type)(type)id;\n        break;\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        break;\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        id = (type)(type)id;\n        break;\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        break;\n      case def:\n        if((*(type)(id op num) op num) != num){\n          call(id, , (type)id[num]);\n        }\n        return num;\n    }\n  }\n  return id;\n}",
        "pr_ast": " id(id, type*id, id){\n  type id;\n  id = id;\n  if((*id op num) == num){\n    switch(*(type)(id op num)){\n      case num:\n        id = (type)(type)id;\n        break;\n      case num:\n      case num:\n      case num:\n        id = (type)(type)id;\n        break;\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n        break;\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n        id = (type)(type)id;\n        break;\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n        break;\n      case def:\n        if((*(type)(id op num) op num) != num){\n          call(id, , *(type)(id op num));\n        }\n        return num;\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 8.5,
          "base_ppl": 3.984375,
          "pr_ppl": 2.78125,
          "source_ast_ppl": 2.375,
          "base_ast_ppl": 3.46875,
          "pr_ast_ppl": 2.609375,
          "delta_ppl": -1.203125
        },
        "llm_ast": {
          "motivation": "A uses a switch with many default cases, which is less elegant. B uses a switch with case num: which aligns with the if condition, making the code flow more logically. B's structure is more concise and avoids unnecessary repetition.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar3 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(local_18 + 1));\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = *(byte *)local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(local_28 + 5));\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(local_28 + 6));\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar3) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)*(byte *)local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              bVar1 = *(byte *)local_28;\n              bVar2 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)bVar1 + (uint)bVar2 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)*(byte *)local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)*(byte *)(local_78 + 1));\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(local_28 + 1));\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)*(byte *)local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 !=\n                       0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)*(byte *)(local_28 + 1) +\n                       (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar3 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type*id){\n  if(!id)return id;\n  type id = idnumidnum;\n  type id = idnumidnum;\n  type *id = ;\n  type id = num;\n  type id = id;\n  call();\n  do{\n    if(id > num){\n      call(, (type)id->id);\n      call(, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, num, num, id->id) != num){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == ){\n        if(id)call(id, , (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, num, id.id, id->id) != id.id){\n        if(id)call(id, );\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[num] op (id[num] op num) != num);\n        id->id = id[num] op (id[num] op num);\n        if(id){\n          call(, (id->id ?  : ));\n          call(, id->id);\n        }\n        break;\n      case id:\n        id->id = id[num] op (id[num] op num);\n        if(id)call(, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call();\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }else{\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type ;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            if(id)call(, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type ;\n          id = (type)id;\n          call(, id->id op num);\n          if(id->id op num){\n            call(, id->id);\n            call(, id->id);\n          }else{\n            type *id = call((type)&id[num], id.id op num, num, id);\n            call(, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > num){\n          type *id = id op num;\n          type id, id;\n          id = id[num] op (id[num] op num);\n          for(id = num;  id < id; upd id){\n            call(, id op num, id[num], id[num], id[num]);\n            id = num;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call();\n          for(id = num;  id < id.id; upd id)call(, id[id]);\n          call();\n        }\n        break;\n      case def:\n        if(id){\n          call(, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = num;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = id;\n    call(&id, num, num);\n    call(&id, num, num);\n    id = (type)num;\n    id = bool;\n    id = num;\n    call();\n    do{\n      if(num < *(type)id){\n        call(, (type)(type)id[num]);\n        call(, (id) op (type)(*id op num), *(type)(*id op num) op num, *(type)(*id op num) op num, *(type)(*id op num) op num);\n      }\n      id = call(&id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(&id);\n      if(*(type)id != num){\n        call(&id);\n      }\n      if(id.id != num){\n        id = call(id, (type)id.id);\n        if(id == (type)num){\n          if(*(type)id != num){\n            call(*(type)id, , (type)id.id);\n          }\n          id = num;\n          break;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != num){\n            call(*(type)id, );\n          }\n          id = num;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      id = id op num;\n      if(id != num){\n        if(id == num){\n          if(*(type)id != num){\n            call();\n            for(id = num;  id < (type)(id op num); id = id op num){\n              call(, (id) op (type)((type)id op (type)id));\n            }\n            call();\n          }\n        }elseif(id == num){\n          *(type)((type)id op num) = (id) op id;\n          if(*(type)id != num){\n            call(, (id) op (type)((type)id op num));\n          }\n        }else{\n          if(id == num){\n            id = num;\n            break;\n          }\n          if(id == num){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)(type)id[num]);\n              call(, (id) op (type)((type)id op num));\n              call(, (type)(type)id[num]);\n              if(id != num){\n                call(, id);\n              }\n            }\n          }elseif(id == num){\n            if(id){\n              if(((type)id == num) && (id = call(id, id, id.id)id != num))break;\n              id = id;\n            }\n          }elseif(id == num){\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, (id) op id op num, (id) op id op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n            }\n          }elseif(id == num){\n            *(type)((type)id op num) = call(id) op id op (id) op (type)((type)id op num) op num;\n            if(*(type)id != num){\n              call(, (id) op (type)((type)id op num));\n            }\n          }elseif(id == num){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != num)break;\n          }elseif(id == num){\n            if(num < *(type)id){\n              id = id op num;\n              id = *id;\n              id = *(type)((type)id op num);\n              for(id = num;  id < (type)((type)(type)id op (type)id op num); id = id op num){\n                call(, call(id op num), call(id) op id, (id) op (type)((type)id op num), (type)(type)id[num]);\n                id = id op num;\n              }\n            }\n          }elseif(id == num){\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(, (id) op id);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n              }\n            }\n          }else{\n            if(id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id == num){\n                if(*(type)id != num){\n                  call(, call(*id op num));\n                  if((*id op num) == num){\n                    id = (type)call(id op num, (type)(type)((id op num) op num), num, id);\n                    call(, id);\n                    call(id);\n                  }else{\n                    call(, (type)(type)id[num]);\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }\n              }else{\n                if(id == num){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == num){\n                  *(type)((type)id op num) = call(id) op id op (id) op (type)((type)id op num) op num != num;\n                  *(type)((type)id op num) = (type)(type)id[num] op (id) op (type)((type)id op num) op num;\n                  if(*(type)id != num){\n                    id = ;\n                    if(*(type)((type)id op num) != ){\n                      id = ;\n                    }\n                    call(, id);\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }elseif(*(type)id != num){\n                  call(, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id op num) == ){\n        id = (type)id != num;\n      }\n    }while(id);\n    if(id != (type)num){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = id;\n    call(&id, num, num);\n    call(&id, num, num);\n    id = (type)num;\n    id = bool;\n    id = num;\n    call();\n    do{\n      if(num < *(type)id){\n        call(, (type)*(type)(id op num));\n        call(, (id) op (type)(*id op num), *(type)(*id op num) op num, *(type)(*id op num) op num, *(type)(*id op num) op num);\n      }\n      id = call(&id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(&id);\n      if(*(type)id != num){\n        call(&id);\n      }\n      if(id.id != num){\n        id = (type)call(id, (type)id.id);\n        if(id == (type)num){\n          if(*(type)id != num){\n            call(*(type)id, , (type)id.id);\n          }\n          id = num;\n          break;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != num){\n            call(*(type)id, );\n          }\n          id = num;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      id = id op num;\n      if(id != num){\n        if(id == num){\n          if(*(type)id != num){\n            call();\n            for(id = num;  id < (type)(id op num); id = id op num){\n              call(, (id) op (type)((type)id op (type)id));\n            }\n            call();\n          }\n        }elseif(id == num){\n          *(type)((type)id op num) = *(type)id;\n          if(*(type)id != num){\n            call(, (id) op (type)((type)id op num));\n          }\n        }else{\n          if(id == num){\n            id = num;\n            break;\n          }\n          if(id == num){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (id) op (type)(id op num));\n              call(, (id) op (type)((type)id op num));\n              call(, (id) op (type)(id op num));\n              if(id != num){\n                call(, id);\n              }\n            }\n          }elseif(id == num){\n            if(id){\n              if(((type)id == num) && (id = call(id, id, id.id)id != num))break;\n              id = id;\n            }\n          }elseif(id == num){\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, (id) op id op num, (id) op id op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n            }\n          }elseif(id == num){\n            *(type)((type)id op num) = (id) op (type)id op (id) op (type)((type)id op num) op num;\n            if(*(type)id != num){\n              call(, (id) op (type)((type)id op num));\n            }\n          }elseif(id == num){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != num)break;\n          }elseif(id == num){\n            if(num < *(type)id){\n              id = id op num;\n              id = *(type)id;\n              id = *(type)((type)id op num);\n              for(id = num;  id < (type)((type)id op (type)id op num); id = id op num){\n                call(, call(id op num), (id) op (type)id, (id) op (type)((type)id op num), (id) op (type)(id op num));\n                id = id op num;\n              }\n            }\n          }elseif(id == num){\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(, (id) op id);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n              }\n            }\n          }else{\n            if(id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id == num){\n                if(*(type)id != num){\n                  call(, call(*id op num));\n                  if((*id op num) == num){\n                    id = (type)call(id op num, (type)(type)((id op num) op num), num, id);\n                    call(, id);\n                    call(id);\n                  }else{\n                    call(, (id) op (type)(id op num));\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }\n              }else{\n                if(id == num){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == num){\n                  *(type)((type)id op num) = (id) op (type)id op (id) op (type)((type)id op num) op num != num;\n                  *(type)((type)id op num) = (id) op (type)(id op num) op (id) op (type)((type)id op num) op num;\n                  if(*(type)id != num){\n                    id = ;\n                    if(*(type)((type)id op num) != ){\n                      id = ;\n                    }\n                    call(, id);\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }elseif(*(type)id != num){\n                  call(, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id op num) == ){\n        id = (type)id != num;\n      }\n    }while(id);\n    if(id != (type)num){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.5,
          "base_ppl": 4.1875,
          "pr_ppl": 4.125,
          "source_ast_ppl": 3.203125,
          "base_ast_ppl": 3.0625,
          "pr_ast_ppl": 2.875,
          "delta_ppl": -0.0625
        },
        "llm_ast": {
          "motivation": "B has fewer goto nodes and cleaner control flow, indicating better idiom usage and high-level structure.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type ;\n  type *id = ;\n  type id = num;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), , id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), , id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = ;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), , id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = (type)call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = (type)call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.25,
          "pr_ppl": 3.25,
          "source_ast_ppl": 3.28125,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type ;\n  type *id = ;\n  type id = num;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), , id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), , id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = ;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), , id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = (type)call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = (type)call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.25,
          "pr_ppl": 3.25,
          "source_ast_ppl": 3.28125,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "B has cleaner control flow with fewer goto jumps and more standard patterns, making it more human-like.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type id = num;\n  type *id = ;\n  type id = num;\n  type id = num op id;\n  type *id = ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = ;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != ){\n            type id = (*id) op ;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, , (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = (type)call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = (type)call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.953125,
          "pr_ppl": 3.890625,
          "source_ast_ppl": 3.859375,
          "base_ast_ppl": 3.328125,
          "pr_ast_ppl": 3.328125,
          "delta_ppl": -0.0625
        },
        "llm_ast": {
          "motivation": "Candidate B exhibits a more logical and high-level control flow with cleaner constructs, fewer goto statements, and a more compact structure, making it more idiomatic and human-like.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type id = num;\n  type *id = ;\n  type id = num;\n  type id = num op id;\n  type *id = ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = ;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != ){\n            type id = (*id) op ;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, , (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = (type)call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = (type)call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.984375,
          "pr_ppl": 3.953125,
          "source_ast_ppl": 3.859375,
          "base_ast_ppl": 3.328125,
          "pr_ast_ppl": 3.328125,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "Candidate B demonstrates more logical control flow with fewer goto statements and higher compactness, indicating a more human-like and idiomatically written code.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type ;\n  type *id = ;\n  type id = num;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), , id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), , id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = ;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), , id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != ){\n      id = (type)[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, , id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == ){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, , id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == ){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == ){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, , (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != ){\n      id = (type)[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = (type)call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, , id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == ){\n        id = (type)call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, , id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == ){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == ){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, , (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.234375,
          "pr_ppl": 3.203125,
          "source_ast_ppl": 3.28125,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "Candidate B demonstrates a more logical and high-level control flow with fewer goto labels, cleaner loops, and a more compact structure compared to Candidate A, which relies on complex conditionals and excessive nesting.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type id = num;\n  type *id = ;\n  type id = num;\n  type id = num op id;\n  type *id = ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = ;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != ){\n            type id = (*id) op ;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, , (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != ){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == ) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, , (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != ){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = (type)call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == ) && (id = (type)call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, , (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.359375,
          "pr_ppl": 3.390625,
          "source_ast_ppl": 3.859375,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.671875,
          "delta_ppl": 0.03125
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "Okay, so I'm trying to figure out which of the two AST candidates, A or B, represents a more logical and high-level design. The user mentioned that I should focus on control flow skeleton patterns, especially loops and branching. They also emphasized avoiding goto and label jumps because those are more like compiler optimizations and not idiomatic code.\n\nLooking at the code, both A and B have a for loop, which is good because for loops are more readable than while loops. But then, inside the loop, there are a lot of if-else conditions and some while loops. Wait, in both, I see a lot of goto lbl; statements. That's a red flag because go-to statements are considered low-level and can make the code harder to understand. They can also lead to spaghetti code, which is bad for maintainability.\n\nIn candidate A, I notice that after the for loop, there are several if conditions and some while loops. But then, inside those, there are multiple goto statements. That means the code is jumping around without a clear structure. It's like the code is doing something, but it's not very organized. The use of goto makes it look more like assembly code than actual high-level code.\n\nCandidate B, on the other hand, seems a bit better. It also has a for loop, but the structure inside is a bit more nested. There are some if statements and while loops, but not as many goto jumps. However, I still see some goto statements, but maybe they're used in a way that's a bit more controlled. But overall, both have a lot of goto, which is a bad sign.\n\nAnother thing to look at is the use of control flow. In both, the code is doing a lot of operations on id variables, sometimes with complex casts and operations. This might be part of the control flow, but it's getting too deep into the weeds. High-level control flow should be simpler and more abstract.\n\nThe code also has a lot of id = id; statements, which might be dead code or unnecessary assignments. This could indicate that the code is trying to do too much in one place, making it less clean and more error-prone.\n\nIn terms of compactness, both have if(A && B) instead of if(A){if(B)...}, which is better for readability. But the presence of goto and the complex control flow inside loops makes both less ideal.\n\nThe user mentioned that the cleanest code would have fewer nesting depth and fewer goto. Comparing A and B, both have similar issues, but A has more goto statements. So, even though B has some goto, it's fewer than A. But both are still problematic.\n\nThe user also mentioned that the cleanest code should have fewer nesting depth and fewer wrapper blocks. Looking at both, I don't see a lot of wrapper blocks, but the code inside loops is pretty nested with multiple if and while statements.\n\nIn the end, both candidates have significant issues with goto and complex control flow. However, since the user has to pick one, and A has more goto statements, I think B is the better choice because it has fewer goto jumps, even though both are bad. So, B is more logical and higher-level than A.\n</think>\n\nThe analysis focuses on control flow patterns, loop usage, and the avoidance of low-level constructs like `goto`. Both candidates use `for` loops, which are preferable over `while` loops. However, both have significant issues with excessive `goto` statements, which are considered non-idempotent and bad practice. Candidate B has fewer `goto` jumps compared to A, making it more logical and high-level. The code in B is somewhat better structured, though still complex, and avoids some unnecessary complexity compared to A.\n\n**Motivation**: B has fewer `goto` statements and cleaner control flow, making it more idiomatic and maintainable despite still containing problematic code.\n\n**Winner**: B"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type ;\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.625,
          "source_ast_ppl": 3.0625,
          "base_ast_ppl": 3.359375,
          "pr_ast_ppl": 3.4375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate B demonstrates a more logical and human-readable structure with cleaner control flow, fewer goto labels, and simpler conditionals compared to Candidate A, which exhibits complex spaghetti code and lower-level patterns.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type ;\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.625,
          "source_ast_ppl": 3.0625,
          "base_ast_ppl": 3.359375,
          "pr_ast_ppl": 3.4375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "B recovered high-level loop structures and control flow patterns, such as switch statements and compact if-else chains, which are characteristic of human-written code. A relied on goto jumps and more complex spaghetti code, which are signs of lower-level compilation artifacts.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op );\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.4375,
          "source_ast_ppl": 3.171875,
          "base_ast_ppl": 3.75,
          "pr_ast_ppl": 3.796875,
          "delta_ppl": 0.03125
        },
        "llm_ast": {
          "motivation": "Candidate B uses standard control flow patterns without goto jumps, making it more human-readable and following higher-level programming practices. The code is cleaner and more compact, avoiding unnecessary complexity.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op );\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.4375,
          "source_ast_ppl": 3.171875,
          "base_ast_ppl": 3.75,
          "pr_ast_ppl": 3.796875,
          "delta_ppl": 0.03125
        },
        "llm_ast": {
          "motivation": "B has fewer goto labels and less nesting, making it more human-like and logical.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id ==  || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if((id != (type)num) && (id = *idid != num)){\n    id = id op num;\n    id = num;\n    id = num;\n    id = num;\n    id = bool;\n    do{\n      id = num;\n      id = bool;\n      switch(id){\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          id = bool;\n          id = num;\n          break;\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          goto lbl;\n        case num:\n          break;\n        case def:\n          id = num;\n          id = bool;\n          if(num < id op num){\n            return num;\n          }\n      }\n      if(!id){\n        return num;\n      }\n      id = id op id;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      id = id;\n    }while(id != num);\n    if((id == num && id < num) && (id < num)){\n      *id = id;\n      id = num;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 3.390625,
          "pr_ppl": 3.390625,
          "source_ast_ppl": 10.75,
          "base_ast_ppl": 3.796875,
          "pr_ast_ppl": 4.0625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate B is more logical and human-like due to its clean control flow, absence of spaghetti code, and compact structure. It avoids unnecessary nesting and wrapper blocks, making its logic clearer and more maintainable.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id ==  || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if((id != (type)num) && (id = *idid != num)){\n    id = id op num;\n    id = num;\n    id = num;\n    id = num;\n    id = bool;\n    do{\n      id = num;\n      id = bool;\n      switch(id){\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          id = bool;\n          id = num;\n          break;\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          goto lbl;\n        case num:\n          break;\n        case def:\n          id = num;\n          id = bool;\n          if(num < id op num){\n            return num;\n          }\n      }\n      if(!id){\n        return num;\n      }\n      id = id op id;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      id = id;\n    }while(id != num);\n    if((id == num && id < num) && (id < num)){\n      *id = id;\n      id = num;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 3.390625,
          "pr_ppl": 3.390625,
          "source_ast_ppl": 10.75,
          "base_ast_ppl": 3.796875,
          "pr_ast_ppl": 4.0625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate B uses more compact and readable control flow structures with fewer unnecessary blocks and low-level jumps, indicating human design. It avoids excessive nesting and switch-case chains, which are typical of decompiled code.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013e6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013e6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        if(id == num)goto lbl;\n        lbl:\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        id = *id;\n        if(id != num)goto lbl;\n        lbl:\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        call(id op num, num);\n        call(id op num, num);\n        id = call(num);\n        id = call(id op num, id op num, (type)id);\n        if(id != num){\n          return num;\n        }\n        id = call(id op id, *id op id, id[num]);\n        id[num] = id;\n        *id = num;\n      case num:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return num;\n          }\n          id = id[num];\n          id = id[num];\n          *id = id op num;\n          if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n          id = *id;\n          *id = id op num;\n          if(num < id op num){\n            return num;\n          }\n        }\n        return num;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 6.28125,
          "base_ppl": 4.625,
          "pr_ppl": 4.375,
          "source_ast_ppl": 5.40625,
          "base_ast_ppl": 3.796875,
          "pr_ast_ppl": 3.71875,
          "delta_ppl": -0.25
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013d6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013d6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        if(id == num)goto lbl;\n        lbl:\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        id = *id;\n        if(id != num)goto lbl;\n        lbl:\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        call(id op num, num);\n        call(id op num, num);\n        id = call(num);\n        id = call(id op num, id op num, (type)id);\n        if(id != num){\n          return num;\n        }\n        id = call(id op id, *id op id, id[num]);\n        id[num] = id;\n        *id = num;\n      case num:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return num;\n          }\n          id = id[num];\n          id = id[num];\n          *id = id op num;\n          if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n          id = *id;\n          *id = id op num;\n          if(num < id op num){\n            return num;\n          }\n        }\n        return num;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 6.28125,
          "base_ppl": 4.6875,
          "pr_ppl": 4.46875,
          "source_ast_ppl": 5.40625,
          "base_ast_ppl": 3.6875,
          "pr_ast_ppl": 3.625,
          "delta_ppl": -0.21875
        },
        "llm_ast": {
          "motivation": "A uses complex control flow with unnecessary wrapper blocks and 'call' functions, which are typical of decompiled code. B has a more compact and readable structure with better branching and fewer artificial constructs, indicating higher-level logic.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op ;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 5.375,
          "base_ppl": 5.0,
          "pr_ppl": 5.09375,
          "source_ast_ppl": 4.4375,
          "base_ast_ppl": 4.34375,
          "pr_ast_ppl": 4.4375,
          "delta_ppl": 0.09375
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps. B uses a switch statement which is a higher-level control flow construct, making the code more readable and maintainable. B also avoids unnecessary complexity and wrapper blocks, adhering to the principles of clean code.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op ;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 5.375,
          "base_ppl": 5.0,
          "pr_ppl": 5.09375,
          "source_ast_ppl": 4.4375,
          "base_ast_ppl": 4.34375,
          "pr_ast_ppl": 4.4375,
          "delta_ppl": 0.09375
        },
        "llm_ast": {
          "motivation": "Candidate B uses high-level constructs like do-while loops and switch statements, avoiding unnecessary goto and label jumps. Its structure is more compact and logical, with fewer nesting depths and no artificial scope. This makes it more human-like compared to Candidate A, which has excessive low-level constructs and complex nesting.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id){\n  type *id = ;\n  type id, id;\n  type ;\n  type ;\n  type id, id, id = num;\n  type id = id->id op id;\n  type id = id->id;\n  type *id = call(id op id->id);\n  type id = id->id;\n  type id = num;\n  type id;\n  if((id->id op id) == num)return num;\n  for(id = num;  id < id; id upd){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < num){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == num;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, num, (id));\n      id.id = id;\n      id = call(id, &id, &id) != num;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id op id), id, &id, &id);\n    call(id, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, num, , id, id, id);\n        if(id == num)goto lbl;\n        id = num;\n        if((id->id op id) != num)goto lbl;\n        if(id != id && id != num)goto lbl;\n        if((call(id, (id ?  : ))) == num)goto lbl;\n        if((id = call(id)) == )goto lbl;\n        if(call(id, num, , , id, id) == num){\n          if(call(id, id) != )call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != ){\n          if(call(id, , id) == num){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, ) == num)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = num;\n        break;\n    }\n  }\n  lbl:\n  call(, id);\n  if(id && id.id != id)(type)call(id, &id, );\n  call(id);\n  id->id = id;\n  call(, id);\n  return id;\n}",
        "base_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < num){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "pr_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(num < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 14.4375,
          "base_ppl": 7.09375,
          "pr_ppl": 7.0,
          "source_ast_ppl": 7.5,
          "base_ast_ppl": 4.65625,
          "pr_ast_ppl": 4.65625,
          "delta_ppl": -0.09375
        },
        "llm_ast": {
          "motivation": "Candidate B uses high-level constructs like 'do-while' loops and avoids 'goto' labels, making it more readable and logical. It has a cleaner structure with fewer unnecessary blocks compared to A, which relies on low-level jumps and complex control flow.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id){\n  type *id = ;\n  type id, id;\n  type ;\n  type ;\n  type id, id, id = num;\n  type id = id->id op id;\n  type id = id->id;\n  type *id = call(id op id->id);\n  type id = id->id;\n  type id = num;\n  type id;\n  if((id->id op id) == num)return num;\n  for(id = num;  id < id; id upd){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < num){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == num;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, num, (id));\n      id.id = id;\n      id = call(id, &id, &id) != num;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id op id), id, &id, &id);\n    call(id, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, num, , id, id, id);\n        if(id == num)goto lbl;\n        id = num;\n        if((id->id op id) != num)goto lbl;\n        if(id != id && id != num)goto lbl;\n        if((call(id, (id ?  : ))) == num)goto lbl;\n        if((id = call(id)) == )goto lbl;\n        if(call(id, num, , , id, id) == num){\n          if(call(id, id) != )call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != ){\n          if(call(id, , id) == num){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, ) == num)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = num;\n        break;\n    }\n  }\n  lbl:\n  call(, id);\n  if(id && id.id != id)(type)call(id, &id, );\n  call(id);\n  id->id = id;\n  call(, id);\n  return id;\n}",
        "base_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < num){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "pr_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(num < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 14.4375,
          "base_ppl": 7.09375,
          "pr_ppl": 7.0,
          "source_ast_ppl": 7.5,
          "base_ast_ppl": 4.65625,
          "pr_ast_ppl": 4.65625,
          "delta_ppl": -0.09375
        },
        "llm_ast": {
          "motivation": "Candidate B uses fewer 'goto' labels and a cleaner control flow structure compared to A, making it more logical and high-level.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id){\n  type id = num;\n  type id = id;\n  type *id = id->id;\n  type *id = call(num, (id));\n  type *id = call(num, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > num)id->id = id->id;\n  if(call(id, id->id) == num){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(num, id, id->id)) == num){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), );\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(num, id, id->id) == num){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), );\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() op id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? num : num);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == ){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == ){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != num){\n    type id = call(id->id, id->id);\n    if(id == (id) op num){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == num){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, num)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), , id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), , call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, typeid){\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = num;\n  id = *(type)((type)id op num);\n  id = id;\n  id = id;\n  id = id;\n  id = call(num, num);\n  id = call(num, num);\n  call(id, id, num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = id;\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = (type)*(type)((type)id op num);\n  if(num < *(type)((type)id op num)){\n    *(type)((type)id op num) = (type)*(type)((type)id op num);\n  }\n  id = call(id, id[num]);\n  if(id == num){\n    id = num;\n  }else{\n    id = call(num, num, id[num]);\n    *(type)((type)id op num) = id;\n    if(id == num){\n      id = num;\n      if(*(type)((type)id op num) != num){\n        call((type)((type)id op num), num, );\n        call((type)id op num, *(type)((type)id op num));\n      }\n    }else{\n      id = call(num, num, id[num]);\n      if(id == num){\n        id = num;\n        if(*(type)((type)id op num) != num){\n          call((type)((type)id op num), num, );\n          call((type)id op num, *(type)((type)id op num));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id op num), id);\n        if(id == num){\n          *(type)((type)id op num) = id[num];\n          *(type)((type)id op num) = *id;\n          *(type)((type)id op num) = id[num];\n          id = call();\n          *(type)((type)id op num) = id op *id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          id = num;\n          if(*(type)((type)id op num) != num){\n            id = num;\n          }\n          *(type)((type)id op num) = (type)id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = id[num];\n          if(*(type)((type)id op num) == num){\n            *(type)((type)id op num) = *(type)(id op num);\n          }\n          id = call(*(type)((type)id op num));\n          *(type)((type)id op num) = id;\n          if(id == num){\n            id = num;\n          }else{\n            if(((*(type)((type)id op num) != num) && (*(type)((type)id op num) != num)) && (id = call(*(type)((type)id op num), *(type)((type)id op num))id != num)){\n              id = call(*(type)((type)id op num), *(type)((type)id op num));\n              if(id == (type)num){\n                id = num;\n                goto lbl;\n              }\n              *(type)((type)id op num) = id;\n            }\n            id = call((type)id op num, num, id op num, num, *(type)((type)id op num));\n            if(((id == num) && (id = call(id, &id)id == num)) && (id = call(id, id)id == num)){\n              id = call(*(type)((type)id op num), num, id[num]);\n              if(id == num){\n                id = num;\n                if(*(type)((type)id op num) != num){\n                  call((type)((type)id op num), num, , *(type)((type)id op num));\n                  call((type)id op num, *(type)((type)id op num));\n                }\n              }else{\n                id = call(id);\n                if((id == num) && (id = call(id, num)id == num)){\n                  if((*(type)((type)id op num) == num) || (*(type)((type)id op num) == *(type)((type)id op num))){\n                    id = call(id);\n                  }else{\n                    id = num;\n                    if(*(type)((type)id op num) != num){\n                      call((type)((type)id op num), num, , (id) op (type)((type)id op num), (id) op (type)((type)id op num));\n                      call((type)id op num, *(type)((type)id op num));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[num]);\n  if((((id == num) || (id == num)) || (id == num)) && (*(type)((type)id op num) != num)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id op num), num, , id, (type)id, id, *id);\n    call((type)id op num, id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, typeid){\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = num;\n  id = *(type)((type)id op num);\n  id = id;\n  id = id;\n  id = id;\n  id = call(num, num);\n  id = (type)call(num, num);\n  call(id, id, num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = id;\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = (type)*(type)((type)id op num);\n  if(num < *(type)((type)id op num)){\n    *(type)((type)id op num) = (type)*(type)((type)id op num);\n  }\n  id = call(id, id[num]);\n  if(id == num){\n    id = num;\n  }else{\n    id = call(num, num, id[num]);\n    *(type)((type)id op num) = id;\n    if(id == num){\n      id = num;\n      if(*(type)((type)id op num) != num){\n        call((type)((type)id op num), num, );\n        call((type)id op num, *(type)((type)id op num));\n      }\n    }else{\n      id = call(num, num, id[num]);\n      if(id == num){\n        id = num;\n        if(*(type)((type)id op num) != num){\n          call((type)((type)id op num), num, );\n          call((type)id op num, *(type)((type)id op num));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id op num), id);\n        if(id == num){\n          *(type)((type)id op num) = id[num];\n          *(type)((type)id op num) = *id;\n          *(type)((type)id op num) = id[num];\n          id = call();\n          *(type)((type)id op num) = id op *id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          id = num;\n          if(*(type)((type)id op num) != num){\n            id = num;\n          }\n          *(type)((type)id op num) = (type)id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = id[num];\n          if(*(type)((type)id op num) == num){\n            *(type)((type)id op num) = *(type)(id op num);\n          }\n          id = call(*(type)((type)id op num));\n          *(type)((type)id op num) = id;\n          if(id == num){\n            id = num;\n          }else{\n            if(((*(type)((type)id op num) != num) && (*(type)((type)id op num) != num)) && (id = call(*(type)((type)id op num), *(type)((type)id op num))id != num)){\n              id = call(*(type)((type)id op num), *(type)((type)id op num));\n              if(id == (type)num){\n                id = num;\n                goto lbl;\n              }\n              *(type)((type)id op num) = id;\n            }\n            id = call((type)id op num, num, id op num, num, *(type)((type)id op num));\n            if(((id == num) && (id = call(id, &id)id == num)) && (id = call(id, id)id == num)){\n              id = call(*(type)((type)id op num), num, id[num]);\n              if(id == num){\n                id = num;\n                if(*(type)((type)id op num) != num){\n                  call((type)((type)id op num), num, , *(type)((type)id op num));\n                  call((type)id op num, *(type)((type)id op num));\n                }\n              }else{\n                id = call(id);\n                if((id == num) && (id = call(id, num)id == num)){\n                  if((*(type)((type)id op num) == num) || (*(type)((type)id op num) == *(type)((type)id op num))){\n                    id = call(id);\n                  }else{\n                    id = num;\n                    if(*(type)((type)id op num) != num){\n                      call((type)((type)id op num), num, , (id) op (type)((type)id op num), (id) op (type)((type)id op num));\n                      call((type)id op num, *(type)((type)id op num));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[num]);\n  if((((id == num) || (id == num)) || (id == num)) && (*(type)((type)id op num) != num)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id op num), num, , id, (type)id, id, *id);\n    call((type)id op num, id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.984375,
          "base_ppl": 3.984375,
          "pr_ppl": 3.984375,
          "source_ast_ppl": 2.734375,
          "base_ast_ppl": 2.515625,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate B avoids spaghetti code and unnecessary jumps, using more logical control flow structures. It has cleaner, more compact code with fewer unnecessary wrapper blocks and calls, making it a more human-like AST.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O2.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      param_3 = __src;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      param_3 = __src + sVar2;\n      if (pbVar3 < param_3) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    param_3 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    if (pbVar3 <= param_3) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    pbVar7 = __src;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = __src + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    pbVar7 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid){\n  type *id = (type)id;\n  type *id = id;\n  type id = num;\n  type *id = (type)id;\n  while(id < (type)id op id){\n    type id = *id upd;\n    type id = (id op num) op num;\n    type id = (id op num);\n    type id = num;\n    type id = num;\n    type id = ;\n    if(id op id[id] > (type)id op id){\n      return num;\n    }\n    switch(id){\n      case id:\n        id = (*id upd) op num op id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = *id upd;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = *id upd;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id op id > (type)id op id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    if(num < id){\n      lbl:\n      id = id;\n      id = id;\n      goto lbl;\n    }\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    id = id;\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    id = id;\n    id = id;\n    if(num < id)goto lbl;\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    id = id;\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.96875,
          "pr_ppl": 2.78125,
          "source_ast_ppl": 2.84375,
          "base_ast_ppl": 3.03125,
          "pr_ast_ppl": 2.984375,
          "delta_ppl": -0.1875
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "Okay, so I'm trying to figure out which of the two AST candidates, A or B, represents the most logical and high-level structural design. The goal is to pick the one that's more idiomatic and human-like. Let's break this down step by step.\n\nFirst, I need to understand what the ASTs are showing. Both are control flow skeletons, so they're abstract representations of how the program flows. The critical goal is to distinguish between high-level logic (which humans would write) and control flow artifacts from a decompiler.\n\nLooking at the evaluation hierarchy, the first point is about high-level abstraction. It says that loops, especially 'for' loops, are preferred over 'while' loops or 'goto' cycles. So, I should look for the use of loops versus other control structures.\n\nNext, the 'goto' penalty is significant. Any presence of 'goto' or 'label' nodes is a negative signal. So, if one AST has fewer 'goto's, it's probably better. Both A and B have 'do' loops, which are similar to 'for' loops, so that's good.\n\nThen, there's the nesting and complexity part. Compactness is preferred, meaning fewer unnecessary nested blocks. Also, artificial scope penalties apply if there are wrapper blocks that don't serve a logical purpose.\n\nLooking at Candidate A, I see a lot of 'if' statements and 'switch' structures. The AST uses a 'switch' which is more of a low-level artifact because it's a control flow graph artifact. The presence of 'switch' might indicate that the decompiler recognized a jump table pattern, which is a lower-level structure. Also, the AST has a lot of 'goto' labels, which are bad because they indicate a preference for low-level jumps.\n\nCandidate B, on the other hand, uses 'do' loops and 'while' loops, which are higher-level constructs. It doesn't have any 'switch' or 'goto' nodes. The control flow is more compact and uses loops instead of jumps. This suggests that B is more human-like because it uses higher-level control structures.\n\nAnother thing to note is the nesting depth. Both have some nesting, but B seems to have less complexity overall. The AST for B doesn't have the artificial wrapper blocks that A has, which are penalized for not being logically necessary.\n\nAlso, looking at the code, both have similar loops, but B's structure is cleaner without the 'switch' which is a low-level artifact. The use of 'do' loops in B indicates a more natural control flow, which aligns with human-readable code.\n\nIn terms of cleanliness, B has fewer 'goto's and no 'switch', which are bad signs. A has both, which makes it less clean. So, B is cleaner and more idiomatic.\n\nPutting it all together, Candidate B is more likely to represent human-level code because it uses higher-level loops, has fewer control flow artifacts, and is more compact without unnecessary nesting or artificial blocks. The absence of 'switch' and 'goto' makes it look more like how a human would structure the code, whereas A's use of 'switch' and 'goto' suggests it's lower-level or a decompiled version.\n</think>\n\nThe analysis focuses on identifying the AST that represents human-readable code by evaluating loop structures, control flow artifacts, and code compactness.\n\n**Motivation**: Candidate B demonstrates a preference for high-level control structures like 'do' and 'while' loops, avoiding low-level artifacts such as 'switch' and 'goto'. It maintains cleaner code with less nesting and no unnecessary blocks, aligning with human-level programming practices.\n\n**Winner**: B"
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O3.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid){\n  type *id = (type)id;\n  type *id = id;\n  type id = num;\n  type *id = (type)id;\n  while(id < (type)id op id){\n    type id = *id upd;\n    type id = (id op num) op num;\n    type id = (id op num);\n    type id = num;\n    type id = num;\n    type id = ;\n    if(id op id[id] > (type)id op id){\n      return num;\n    }\n    switch(id){\n      case id:\n        id = (*id upd) op num op id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = *id upd;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = *id upd;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id op id > (type)id op id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    if(num < id){\n      lbl:\n      id = id;\n      goto lbl;\n    }\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    id = id;\n    if(num < id)goto lbl;\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.9375,
          "pr_ppl": 2.78125,
          "source_ast_ppl": 2.84375,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": -0.15625
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      }
    ],
    "llama3.1": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type*id){\n  if(!id)return id;\n  type id = idnumidnum;\n  type id = idnumidnum;\n  type *id = ;\n  type id = num;\n  type id = id;\n  call();\n  do{\n    if(id > num){\n      call(, (type)id->id);\n      call(, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, num, num, id->id) != num){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == ){\n        if(id)call(id, , (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, num, id.id, id->id) != id.id){\n        if(id)call(id, );\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[num] op (id[num] op num) != num);\n        id->id = id[num] op (id[num] op num);\n        if(id){\n          call(, (id->id ?  : ));\n          call(, id->id);\n        }\n        break;\n      case id:\n        id->id = id[num] op (id[num] op num);\n        if(id)call(, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call();\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }else{\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type ;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            if(id)call(, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type ;\n          id = (type)id;\n          call(, id->id op num);\n          if(id->id op num){\n            call(, id->id);\n            call(, id->id);\n          }else{\n            type *id = call((type)&id[num], id.id op num, num, id);\n            call(, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > num){\n          type *id = id op num;\n          type id, id;\n          id = id[num] op (id[num] op num);\n          for(id = num;  id < id; upd id){\n            call(, id op num, id[num], id[num], id[num]);\n            id = num;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call();\n          for(id = num;  id < id.id; upd id)call(, id[id]);\n          call();\n        }\n        break;\n      case def:\n        if(id){\n          call(, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = num;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)(type)id[num]);\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = call(id) op id;\n            *(type)((type)id op num) = (id) op id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)(type)id[num]);\n              call(, (id) op (type)((type)id op num));\n              call(, (type)(type)id[num]);\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (type)(type)id[id op num op num], (id) op (type)((type)id op id op num op num), (type)(type)id[id op num op num]);\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (type)(type)id[num]);\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)*(type)(id op num));\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = (type)call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = (id) op (type)id;\n            *(type)((type)id op num) = *(type)id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (id) op (type)(id op num));\n              call(, (id) op (type)((type)id op num));\n              call(, (id) op (type)(id op num));\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (id) op (type)(id op id op num op num), (id) op (type)((type)id op id op num op num), (id) op (type)(id op id op num op num));\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (id) op (type)(id op num));\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.34375,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 2.40625,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type*id){\n  if(!id)return id;\n  type id = idnumidnum;\n  type id = idnumidnum;\n  type *id = ;\n  type id = num;\n  type id = id;\n  call();\n  do{\n    if(id > num){\n      call(, (type)id->id);\n      call(, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, num, num, id->id) != num){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == ){\n        if(id)call(id, , (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, num, id.id, id->id) != id.id){\n        if(id)call(id, );\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[num] op (id[num] op num) != num);\n        id->id = id[num] op (id[num] op num);\n        if(id){\n          call(, (id->id ?  : ));\n          call(, id->id);\n        }\n        break;\n      case id:\n        id->id = id[num] op (id[num] op num);\n        if(id)call(, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call();\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }else{\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type ;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            if(id)call(, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type ;\n          id = (type)id;\n          call(, id->id op num);\n          if(id->id op num){\n            call(, id->id);\n            call(, id->id);\n          }else{\n            type *id = call((type)&id[num], id.id op num, num, id);\n            call(, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > num){\n          type *id = id op num;\n          type id, id;\n          id = id[num] op (id[num] op num);\n          for(id = num;  id < id; upd id){\n            call(, id op num, id[num], id[num], id[num]);\n            id = num;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call();\n          for(id = num;  id < id.id; upd id)call(, id[id]);\n          call();\n        }\n        break;\n      case def:\n        if(id){\n          call(, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = num;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)(type)id[num]);\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = call(id) op id;\n            *(type)((type)id op num) = (id) op id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)(type)id[num]);\n              call(, (id) op (type)((type)id op num));\n              call(, (type)(type)id[num]);\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (type)(type)id[id op num op num], (id) op (type)((type)id op id op num op num), (type)(type)id[id op num op num]);\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (type)(type)id[num]);\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)*(type)(id op num));\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = (type)call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = (id) op (type)id;\n            *(type)((type)id op num) = *(type)id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (id) op (type)(id op num));\n              call(, (id) op (type)((type)id op num));\n              call(, (id) op (type)(id op num));\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (id) op (type)(id op id op num op num), (id) op (type)((type)id op id op num op num), (id) op (type)(id op id op num op num));\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (id) op (type)(id op num));\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.34375,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 2.40625,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch(*(undefined *)(param_2 + 3)) {\n    case 1:\n      local_28 = (long)(char)param_3;\n      break;\n    case 2:\n    case 7:\n    case 10:\n      local_28 = (long)(short)param_3;\n      break;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x29:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      local_28 = (long)(int)param_3;\n      break;\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",*(undefined *)(param_2 + 3));\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "type id(type*id, type*id, typeid){\n  if(!(id->id op id)){\n    switch(id->id){\n      case id:\n        id = call(id, id, id);\n        break;\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        break;\n      case def:\n        if(id->id op id)call(id, , id->id);\n        return id;\n    }\n  }\n  return id;\n}",
        "base_ast": " id(id, type*id, id){\n  type id;\n  id = id;\n  if((*id op num) == num){\n    switch((type)id[num]){\n      case :\n        id = (type)(type)id;\n        break;\n      case :\n      case :\n      case :\n        id = (type)(type)id;\n        break;\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        break;\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        id = (type)(type)id;\n        break;\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        break;\n      case def:\n        if((*(type)(id op num) op num) != num){\n          call(id, , (type)id[num]);\n        }\n        return num;\n    }\n  }\n  return id;\n}",
        "pr_ast": " id(id, type*id, id){\n  type id;\n  id = id;\n  if((*id op num) == num){\n    switch(*(type)(id op num)){\n      case num:\n        id = (type)(type)id;\n        break;\n      case num:\n      case num:\n      case num:\n        id = (type)(type)id;\n        break;\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n        break;\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n        id = (type)(type)id;\n        break;\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n        break;\n      case def:\n        if((*(type)(id op num) op num) != num){\n          call(id, , *(type)(id op num));\n        }\n        return num;\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.390625,
          "base_ppl": 2.40625,
          "pr_ppl": 1.921875,
          "source_ast_ppl": 2.0625,
          "base_ast_ppl": 2.625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": -0.484375
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar3 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(local_18 + 1));\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = *(byte *)local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(local_28 + 5));\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(local_28 + 6));\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar3) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)*(byte *)local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              bVar1 = *(byte *)local_28;\n              bVar2 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)bVar1 + (uint)bVar2 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)*(byte *)local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)*(byte *)(local_78 + 1));\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(local_28 + 1));\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)*(byte *)local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 !=\n                       0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)*(byte *)(local_28 + 1) +\n                       (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar3 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type*id){\n  if(!id)return id;\n  type id = idnumidnum;\n  type id = idnumidnum;\n  type *id = ;\n  type id = num;\n  type id = id;\n  call();\n  do{\n    if(id > num){\n      call(, (type)id->id);\n      call(, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, num, num, id->id) != num){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == ){\n        if(id)call(id, , (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, num, id.id, id->id) != id.id){\n        if(id)call(id, );\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[num] op (id[num] op num) != num);\n        id->id = id[num] op (id[num] op num);\n        if(id){\n          call(, (id->id ?  : ));\n          call(, id->id);\n        }\n        break;\n      case id:\n        id->id = id[num] op (id[num] op num);\n        if(id)call(, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call();\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }else{\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type ;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            if(id)call(, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type ;\n          id = (type)id;\n          call(, id->id op num);\n          if(id->id op num){\n            call(, id->id);\n            call(, id->id);\n          }else{\n            type *id = call((type)&id[num], id.id op num, num, id);\n            call(, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > num){\n          type *id = id op num;\n          type id, id;\n          id = id[num] op (id[num] op num);\n          for(id = num;  id < id; upd id){\n            call(, id op num, id[num], id[num], id[num]);\n            id = num;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call();\n          for(id = num;  id < id.id; upd id)call(, id[id]);\n          call();\n        }\n        break;\n      case def:\n        if(id){\n          call(, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = num;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = id;\n    call(&id, num, num);\n    call(&id, num, num);\n    id = (type)num;\n    id = bool;\n    id = num;\n    call();\n    do{\n      if(num < *(type)id){\n        call(, (type)(type)id[num]);\n        call(, (id) op (type)(*id op num), *(type)(*id op num) op num, *(type)(*id op num) op num, *(type)(*id op num) op num);\n      }\n      id = call(&id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(&id);\n      if(*(type)id != num){\n        call(&id);\n      }\n      if(id.id != num){\n        id = call(id, (type)id.id);\n        if(id == (type)num){\n          if(*(type)id != num){\n            call(*(type)id, , (type)id.id);\n          }\n          id = num;\n          break;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != num){\n            call(*(type)id, );\n          }\n          id = num;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      id = id op num;\n      if(id != num){\n        if(id == num){\n          if(*(type)id != num){\n            call();\n            for(id = num;  id < (type)(id op num); id = id op num){\n              call(, (id) op (type)((type)id op (type)id));\n            }\n            call();\n          }\n        }elseif(id == num){\n          *(type)((type)id op num) = (id) op id;\n          if(*(type)id != num){\n            call(, (id) op (type)((type)id op num));\n          }\n        }else{\n          if(id == num){\n            id = num;\n            break;\n          }\n          if(id == num){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)(type)id[num]);\n              call(, (id) op (type)((type)id op num));\n              call(, (type)(type)id[num]);\n              if(id != num){\n                call(, id);\n              }\n            }\n          }elseif(id == num){\n            if(id){\n              if(((type)id == num) && (id = call(id, id, id.id)id != num))break;\n              id = id;\n            }\n          }elseif(id == num){\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, (id) op id op num, (id) op id op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n            }\n          }elseif(id == num){\n            *(type)((type)id op num) = call(id) op id op (id) op (type)((type)id op num) op num;\n            if(*(type)id != num){\n              call(, (id) op (type)((type)id op num));\n            }\n          }elseif(id == num){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != num)break;\n          }elseif(id == num){\n            if(num < *(type)id){\n              id = id op num;\n              id = *id;\n              id = *(type)((type)id op num);\n              for(id = num;  id < (type)((type)(type)id op (type)id op num); id = id op num){\n                call(, call(id op num), call(id) op id, (id) op (type)((type)id op num), (type)(type)id[num]);\n                id = id op num;\n              }\n            }\n          }elseif(id == num){\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(, (id) op id);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n              }\n            }\n          }else{\n            if(id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id == num){\n                if(*(type)id != num){\n                  call(, call(*id op num));\n                  if((*id op num) == num){\n                    id = (type)call(id op num, (type)(type)((id op num) op num), num, id);\n                    call(, id);\n                    call(id);\n                  }else{\n                    call(, (type)(type)id[num]);\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }\n              }else{\n                if(id == num){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == num){\n                  *(type)((type)id op num) = call(id) op id op (id) op (type)((type)id op num) op num != num;\n                  *(type)((type)id op num) = (type)(type)id[num] op (id) op (type)((type)id op num) op num;\n                  if(*(type)id != num){\n                    id = ;\n                    if(*(type)((type)id op num) != ){\n                      id = ;\n                    }\n                    call(, id);\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }elseif(*(type)id != num){\n                  call(, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id op num) == ){\n        id = (type)id != num;\n      }\n    }while(id);\n    if(id != (type)num){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = id;\n    call(&id, num, num);\n    call(&id, num, num);\n    id = (type)num;\n    id = bool;\n    id = num;\n    call();\n    do{\n      if(num < *(type)id){\n        call(, (type)*(type)(id op num));\n        call(, (id) op (type)(*id op num), *(type)(*id op num) op num, *(type)(*id op num) op num, *(type)(*id op num) op num);\n      }\n      id = call(&id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(&id);\n      if(*(type)id != num){\n        call(&id);\n      }\n      if(id.id != num){\n        id = (type)call(id, (type)id.id);\n        if(id == (type)num){\n          if(*(type)id != num){\n            call(*(type)id, , (type)id.id);\n          }\n          id = num;\n          break;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != num){\n            call(*(type)id, );\n          }\n          id = num;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      id = id op num;\n      if(id != num){\n        if(id == num){\n          if(*(type)id != num){\n            call();\n            for(id = num;  id < (type)(id op num); id = id op num){\n              call(, (id) op (type)((type)id op (type)id));\n            }\n            call();\n          }\n        }elseif(id == num){\n          *(type)((type)id op num) = *(type)id;\n          if(*(type)id != num){\n            call(, (id) op (type)((type)id op num));\n          }\n        }else{\n          if(id == num){\n            id = num;\n            break;\n          }\n          if(id == num){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (id) op (type)(id op num));\n              call(, (id) op (type)((type)id op num));\n              call(, (id) op (type)(id op num));\n              if(id != num){\n                call(, id);\n              }\n            }\n          }elseif(id == num){\n            if(id){\n              if(((type)id == num) && (id = call(id, id, id.id)id != num))break;\n              id = id;\n            }\n          }elseif(id == num){\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, (id) op id op num, (id) op id op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n            }\n          }elseif(id == num){\n            *(type)((type)id op num) = (id) op (type)id op (id) op (type)((type)id op num) op num;\n            if(*(type)id != num){\n              call(, (id) op (type)((type)id op num));\n            }\n          }elseif(id == num){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != num)break;\n          }elseif(id == num){\n            if(num < *(type)id){\n              id = id op num;\n              id = *(type)id;\n              id = *(type)((type)id op num);\n              for(id = num;  id < (type)((type)id op (type)id op num); id = id op num){\n                call(, call(id op num), (id) op (type)id, (id) op (type)((type)id op num), (id) op (type)(id op num));\n                id = id op num;\n              }\n            }\n          }elseif(id == num){\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(, (id) op id);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n              }\n            }\n          }else{\n            if(id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id == num){\n                if(*(type)id != num){\n                  call(, call(*id op num));\n                  if((*id op num) == num){\n                    id = (type)call(id op num, (type)(type)((id op num) op num), num, id);\n                    call(, id);\n                    call(id);\n                  }else{\n                    call(, (id) op (type)(id op num));\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }\n              }else{\n                if(id == num){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == num){\n                  *(type)((type)id op num) = (id) op (type)id op (id) op (type)((type)id op num) op num != num;\n                  *(type)((type)id op num) = (id) op (type)(id op num) op (id) op (type)((type)id op num) op num;\n                  if(*(type)id != num){\n                    id = ;\n                    if(*(type)((type)id op num) != ){\n                      id = ;\n                    }\n                    call(, id);\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }elseif(*(type)id != num){\n                  call(, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id op num) == ){\n        id = (type)id != num;\n      }\n    }while(id);\n    if(id != (type)num){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.40625,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type ;\n  type *id = ;\n  type id = num;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), , id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), , id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = ;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), , id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = (type)call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = (type)call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.234375,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type ;\n  type *id = ;\n  type id = num;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), , id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), , id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = ;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), , id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = (type)call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = (type)call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.234375,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type id = num;\n  type *id = ;\n  type id = num;\n  type id = num op id;\n  type *id = ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = ;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != ){\n            type id = (*id) op ;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, , (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = (type)call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = (type)call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 2.796875,
          "base_ast_ppl": 2.359375,
          "pr_ast_ppl": 2.359375,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "### Analysis\n\nAfter analyzing the provided Control Flow Skeletons, I conclude that:\n\n### Motivation\nCandidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps. This suggests that Candidate A exhibits more idiomatic programming patterns and human-like design.\n\n### Winner\n\"winner\": \"A\"\n\nThe reasoning behind this decision is as follows:\n\n1. **High-Level Abstraction Preference**: Candidate A uses a `do-while` loop, which is a more high-level structure than the `while` loop used in Candidate B. This indicates that Candidate A is more idiomatic and human-like.\n2. **Spaghetti Reduction**: Both candidates have a similar number of `goto` nodes, but Candidate A's structure is more compact and easier to follow. This suggests that Candidate A has fewer spaghetti-like constructs.\n3. **Nesting & Complexity**: Candidate A has fewer nested blocks and wrapper blocks, making its structure more compact and easier to understand.\n4. **Cleanliness Rule**: Both candidates have the same structures, but Candidate A has a shallower nesting depth and fewer `goto` nodes, making it the cleaner choice.\n\nOverall, Candidate A's high-level loop structures and more compact design make it the winner."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type id = num;\n  type *id = ;\n  type id = num;\n  type id = num op id;\n  type *id = ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = ;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != ){\n            type id = (*id) op ;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, , (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = (type)call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = (type)call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.359375,
          "pr_ppl": 2.34375,
          "source_ast_ppl": 2.796875,
          "base_ast_ppl": 2.359375,
          "pr_ast_ppl": 2.359375,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type ;\n  type *id = ;\n  type id = num;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), , id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), , id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = ;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), , id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != ){\n      id = (type)[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, , id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == ){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, , id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == ){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == ){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, , (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != ){\n      id = (type)[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = (type)call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, , id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == ){\n        id = (type)call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, , id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == ){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == ){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, , (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.03125,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type id = num;\n  type *id = ;\n  type id = num;\n  type id = num op id;\n  type *id = ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = ;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != ){\n            type id = (*id) op ;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, , (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != ){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == ) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, , (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != ){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = (type)call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == ) && (id = (type)call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, , (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.046875,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 2.796875,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type ;\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.765625,
          "source_ast_ppl": 2.3125,
          "base_ast_ppl": 2.5,
          "pr_ast_ppl": 2.53125,
          "delta_ppl": 0.03125
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type ;\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.765625,
          "source_ast_ppl": 2.3125,
          "base_ast_ppl": 2.5,
          "pr_ast_ppl": 2.53125,
          "delta_ppl": 0.03125
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op );\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 2.390625,
          "base_ast_ppl": 2.65625,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": 0.03125
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op );\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 2.390625,
          "base_ast_ppl": 2.65625,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": 0.03125
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id ==  || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if((id != (type)num) && (id = *idid != num)){\n    id = id op num;\n    id = num;\n    id = num;\n    id = num;\n    id = bool;\n    do{\n      id = num;\n      id = bool;\n      switch(id){\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          id = bool;\n          id = num;\n          break;\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          goto lbl;\n        case num:\n          break;\n        case def:\n          id = num;\n          id = bool;\n          if(num < id op num){\n            return num;\n          }\n      }\n      if(!id){\n        return num;\n      }\n      id = id op id;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      id = id;\n    }while(id != num);\n    if((id == num && id < num) && (id < num)){\n      *id = id;\n      id = num;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.09375,
          "pr_ppl": 1.9921875,
          "source_ast_ppl": 6.3125,
          "base_ast_ppl": 2.875,
          "pr_ast_ppl": 2.9375,
          "delta_ppl": -0.1015625
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id ==  || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if((id != (type)num) && (id = *idid != num)){\n    id = id op num;\n    id = num;\n    id = num;\n    id = num;\n    id = bool;\n    do{\n      id = num;\n      id = bool;\n      switch(id){\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          id = bool;\n          id = num;\n          break;\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          goto lbl;\n        case num:\n          break;\n        case def:\n          id = num;\n          id = bool;\n          if(num < id op num){\n            return num;\n          }\n      }\n      if(!id){\n        return num;\n      }\n      id = id op id;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      id = id;\n    }while(id != num);\n    if((id == num && id < num) && (id < num)){\n      *id = id;\n      id = num;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.09375,
          "pr_ppl": 1.9921875,
          "source_ast_ppl": 6.3125,
          "base_ast_ppl": 2.875,
          "pr_ast_ppl": 2.9375,
          "delta_ppl": -0.1015625
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013e6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013e6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        if(id == num)goto lbl;\n        lbl:\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        id = *id;\n        if(id != num)goto lbl;\n        lbl:\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        call(id op num, num);\n        call(id op num, num);\n        id = call(num);\n        id = call(id op num, id op num, (type)id);\n        if(id != num){\n          return num;\n        }\n        id = call(id op id, *id op id, id[num]);\n        id[num] = id;\n        *id = num;\n      case num:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return num;\n          }\n          id = id[num];\n          id = id[num];\n          *id = id op num;\n          if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n          id = *id;\n          *id = id op num;\n          if(num < id op num){\n            return num;\n          }\n        }\n        return num;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.15625,
          "base_ppl": 2.265625,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 3.546875,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.71875,
          "delta_ppl": -0.09375
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013d6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013d6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        if(id == num)goto lbl;\n        lbl:\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        id = *id;\n        if(id != num)goto lbl;\n        lbl:\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        call(id op num, num);\n        call(id op num, num);\n        id = call(num);\n        id = call(id op num, id op num, (type)id);\n        if(id != num){\n          return num;\n        }\n        id = call(id op id, *id op id, id[num]);\n        id[num] = id;\n        *id = num;\n      case num:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return num;\n          }\n          id = id[num];\n          id = id[num];\n          *id = id op num;\n          if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n          id = *id;\n          *id = id op num;\n          if(num < id op num){\n            return num;\n          }\n        }\n        return num;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.15625,
          "base_ppl": 2.265625,
          "pr_ppl": 2.171875,
          "source_ast_ppl": 3.546875,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": -0.09375
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op ;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.703125,
          "pr_ppl": 2.734375,
          "source_ast_ppl": 3.0625,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.125,
          "delta_ppl": 0.03125
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op ;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.703125,
          "pr_ppl": 2.734375,
          "source_ast_ppl": 3.0625,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.125,
          "delta_ppl": 0.03125
        },
        "llm_ast": {
          "motivation": "Candidate A recovered high-level loop structures, whereas Candidate B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id){\n  type *id = ;\n  type id, id;\n  type ;\n  type ;\n  type id, id, id = num;\n  type id = id->id op id;\n  type id = id->id;\n  type *id = call(id op id->id);\n  type id = id->id;\n  type id = num;\n  type id;\n  if((id->id op id) == num)return num;\n  for(id = num;  id < id; id upd){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < num){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == num;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, num, (id));\n      id.id = id;\n      id = call(id, &id, &id) != num;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id op id), id, &id, &id);\n    call(id, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, num, , id, id, id);\n        if(id == num)goto lbl;\n        id = num;\n        if((id->id op id) != num)goto lbl;\n        if(id != id && id != num)goto lbl;\n        if((call(id, (id ?  : ))) == num)goto lbl;\n        if((id = call(id)) == )goto lbl;\n        if(call(id, num, , , id, id) == num){\n          if(call(id, id) != )call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != ){\n          if(call(id, , id) == num){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, ) == num)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = num;\n        break;\n    }\n  }\n  lbl:\n  call(, id);\n  if(id && id.id != id)(type)call(id, &id, );\n  call(id);\n  id->id = id;\n  call(, id);\n  return id;\n}",
        "base_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < num){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "pr_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(num < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.59375,
          "base_ppl": 3.0625,
          "pr_ppl": 3.03125,
          "source_ast_ppl": 4.78125,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id){\n  type *id = ;\n  type id, id;\n  type ;\n  type ;\n  type id, id, id = num;\n  type id = id->id op id;\n  type id = id->id;\n  type *id = call(id op id->id);\n  type id = id->id;\n  type id = num;\n  type id;\n  if((id->id op id) == num)return num;\n  for(id = num;  id < id; id upd){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < num){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == num;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, num, (id));\n      id.id = id;\n      id = call(id, &id, &id) != num;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id op id), id, &id, &id);\n    call(id, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, num, , id, id, id);\n        if(id == num)goto lbl;\n        id = num;\n        if((id->id op id) != num)goto lbl;\n        if(id != id && id != num)goto lbl;\n        if((call(id, (id ?  : ))) == num)goto lbl;\n        if((id = call(id)) == )goto lbl;\n        if(call(id, num, , , id, id) == num){\n          if(call(id, id) != )call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != ){\n          if(call(id, , id) == num){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, ) == num)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = num;\n        break;\n    }\n  }\n  lbl:\n  call(, id);\n  if(id && id.id != id)(type)call(id, &id, );\n  call(id);\n  id->id = id;\n  call(, id);\n  return id;\n}",
        "base_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < num){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "pr_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(num < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.59375,
          "base_ppl": 3.0625,
          "pr_ppl": 3.03125,
          "source_ast_ppl": 4.78125,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id){\n  type id = num;\n  type id = id;\n  type *id = id->id;\n  type *id = call(num, (id));\n  type *id = call(num, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > num)id->id = id->id;\n  if(call(id, id->id) == num){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(num, id, id->id)) == num){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), );\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(num, id, id->id) == num){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), );\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() op id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? num : num);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == ){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == ){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != num){\n    type id = call(id->id, id->id);\n    if(id == (id) op num){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == num){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, num)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), , id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), , call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, typeid){\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = num;\n  id = *(type)((type)id op num);\n  id = id;\n  id = id;\n  id = id;\n  id = call(num, num);\n  id = call(num, num);\n  call(id, id, num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = id;\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = (type)*(type)((type)id op num);\n  if(num < *(type)((type)id op num)){\n    *(type)((type)id op num) = (type)*(type)((type)id op num);\n  }\n  id = call(id, id[num]);\n  if(id == num){\n    id = num;\n  }else{\n    id = call(num, num, id[num]);\n    *(type)((type)id op num) = id;\n    if(id == num){\n      id = num;\n      if(*(type)((type)id op num) != num){\n        call((type)((type)id op num), num, );\n        call((type)id op num, *(type)((type)id op num));\n      }\n    }else{\n      id = call(num, num, id[num]);\n      if(id == num){\n        id = num;\n        if(*(type)((type)id op num) != num){\n          call((type)((type)id op num), num, );\n          call((type)id op num, *(type)((type)id op num));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id op num), id);\n        if(id == num){\n          *(type)((type)id op num) = id[num];\n          *(type)((type)id op num) = *id;\n          *(type)((type)id op num) = id[num];\n          id = call();\n          *(type)((type)id op num) = id op *id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          id = num;\n          if(*(type)((type)id op num) != num){\n            id = num;\n          }\n          *(type)((type)id op num) = (type)id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = id[num];\n          if(*(type)((type)id op num) == num){\n            *(type)((type)id op num) = *(type)(id op num);\n          }\n          id = call(*(type)((type)id op num));\n          *(type)((type)id op num) = id;\n          if(id == num){\n            id = num;\n          }else{\n            if(((*(type)((type)id op num) != num) && (*(type)((type)id op num) != num)) && (id = call(*(type)((type)id op num), *(type)((type)id op num))id != num)){\n              id = call(*(type)((type)id op num), *(type)((type)id op num));\n              if(id == (type)num){\n                id = num;\n                goto lbl;\n              }\n              *(type)((type)id op num) = id;\n            }\n            id = call((type)id op num, num, id op num, num, *(type)((type)id op num));\n            if(((id == num) && (id = call(id, &id)id == num)) && (id = call(id, id)id == num)){\n              id = call(*(type)((type)id op num), num, id[num]);\n              if(id == num){\n                id = num;\n                if(*(type)((type)id op num) != num){\n                  call((type)((type)id op num), num, , *(type)((type)id op num));\n                  call((type)id op num, *(type)((type)id op num));\n                }\n              }else{\n                id = call(id);\n                if((id == num) && (id = call(id, num)id == num)){\n                  if((*(type)((type)id op num) == num) || (*(type)((type)id op num) == *(type)((type)id op num))){\n                    id = call(id);\n                  }else{\n                    id = num;\n                    if(*(type)((type)id op num) != num){\n                      call((type)((type)id op num), num, , (id) op (type)((type)id op num), (id) op (type)((type)id op num));\n                      call((type)id op num, *(type)((type)id op num));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[num]);\n  if((((id == num) || (id == num)) || (id == num)) && (*(type)((type)id op num) != num)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id op num), num, , id, (type)id, id, *id);\n    call((type)id op num, id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, typeid){\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = num;\n  id = *(type)((type)id op num);\n  id = id;\n  id = id;\n  id = id;\n  id = call(num, num);\n  id = (type)call(num, num);\n  call(id, id, num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = id;\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = (type)*(type)((type)id op num);\n  if(num < *(type)((type)id op num)){\n    *(type)((type)id op num) = (type)*(type)((type)id op num);\n  }\n  id = call(id, id[num]);\n  if(id == num){\n    id = num;\n  }else{\n    id = call(num, num, id[num]);\n    *(type)((type)id op num) = id;\n    if(id == num){\n      id = num;\n      if(*(type)((type)id op num) != num){\n        call((type)((type)id op num), num, );\n        call((type)id op num, *(type)((type)id op num));\n      }\n    }else{\n      id = call(num, num, id[num]);\n      if(id == num){\n        id = num;\n        if(*(type)((type)id op num) != num){\n          call((type)((type)id op num), num, );\n          call((type)id op num, *(type)((type)id op num));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id op num), id);\n        if(id == num){\n          *(type)((type)id op num) = id[num];\n          *(type)((type)id op num) = *id;\n          *(type)((type)id op num) = id[num];\n          id = call();\n          *(type)((type)id op num) = id op *id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          id = num;\n          if(*(type)((type)id op num) != num){\n            id = num;\n          }\n          *(type)((type)id op num) = (type)id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = id[num];\n          if(*(type)((type)id op num) == num){\n            *(type)((type)id op num) = *(type)(id op num);\n          }\n          id = call(*(type)((type)id op num));\n          *(type)((type)id op num) = id;\n          if(id == num){\n            id = num;\n          }else{\n            if(((*(type)((type)id op num) != num) && (*(type)((type)id op num) != num)) && (id = call(*(type)((type)id op num), *(type)((type)id op num))id != num)){\n              id = call(*(type)((type)id op num), *(type)((type)id op num));\n              if(id == (type)num){\n                id = num;\n                goto lbl;\n              }\n              *(type)((type)id op num) = id;\n            }\n            id = call((type)id op num, num, id op num, num, *(type)((type)id op num));\n            if(((id == num) && (id = call(id, &id)id == num)) && (id = call(id, id)id == num)){\n              id = call(*(type)((type)id op num), num, id[num]);\n              if(id == num){\n                id = num;\n                if(*(type)((type)id op num) != num){\n                  call((type)((type)id op num), num, , *(type)((type)id op num));\n                  call((type)id op num, *(type)((type)id op num));\n                }\n              }else{\n                id = call(id);\n                if((id == num) && (id = call(id, num)id == num)){\n                  if((*(type)((type)id op num) == num) || (*(type)((type)id op num) == *(type)((type)id op num))){\n                    id = call(id);\n                  }else{\n                    id = num;\n                    if(*(type)((type)id op num) != num){\n                      call((type)((type)id op num), num, , (id) op (type)((type)id op num), (id) op (type)((type)id op num));\n                      call((type)id op num, *(type)((type)id op num));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[num]);\n  if((((id == num) || (id == num)) || (id == num)) && (*(type)((type)id op num) != num)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id op num), num, , id, (type)id, id, *id);\n    call((type)id op num, id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.296875,
          "base_ppl": 2.0,
          "pr_ppl": 2.0,
          "source_ast_ppl": 2.140625,
          "base_ast_ppl": 1.9765625,
          "pr_ast_ppl": 1.984375,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O2.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      param_3 = __src;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      param_3 = __src + sVar2;\n      if (pbVar3 < param_3) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    param_3 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    if (pbVar3 <= param_3) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    pbVar7 = __src;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = __src + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    pbVar7 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid){\n  type *id = (type)id;\n  type *id = id;\n  type id = num;\n  type *id = (type)id;\n  while(id < (type)id op id){\n    type id = *id upd;\n    type id = (id op num) op num;\n    type id = (id op num);\n    type id = num;\n    type id = num;\n    type id = ;\n    if(id op id[id] > (type)id op id){\n      return num;\n    }\n    switch(id){\n      case id:\n        id = (*id upd) op num op id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = *id upd;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = *id upd;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id op id > (type)id op id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    if(num < id){\n      lbl:\n      id = id;\n      id = id;\n      goto lbl;\n    }\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    id = id;\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    id = id;\n    id = id;\n    if(num < id)goto lbl;\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    id = id;\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8984375,
          "base_ppl": 1.96875,
          "pr_ppl": 1.875,
          "source_ast_ppl": 2.3125,
          "base_ast_ppl": 2.40625,
          "pr_ast_ppl": 2.359375,
          "delta_ppl": -0.09375
        },
        "llm_ast": {
          "motivation": "A recovered high-level loop structures, whereas B relied on low-level jumps.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O3.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid){\n  type *id = (type)id;\n  type *id = id;\n  type id = num;\n  type *id = (type)id;\n  while(id < (type)id op id){\n    type id = *id upd;\n    type id = (id op num) op num;\n    type id = (id op num);\n    type id = num;\n    type id = num;\n    type id = ;\n    if(id op id[id] > (type)id op id){\n      return num;\n    }\n    switch(id){\n      case id:\n        id = (*id upd) op num op id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = *id upd;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = *id upd;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id op id > (type)id op id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    if(num < id){\n      lbl:\n      id = id;\n      goto lbl;\n    }\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    id = id;\n    if(num < id)goto lbl;\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8984375,
          "base_ppl": 2.0,
          "pr_ppl": 1.9140625,
          "source_ast_ppl": 2.3125,
          "base_ast_ppl": 2.390625,
          "pr_ast_ppl": 2.375,
          "delta_ppl": -0.0859375
        },
        "llm_ast": {
          "motivation": "B recovered high-level loop structures, whereas A relied on low-level jumps.",
          "winner": "PR"
        }
      }
    ],
    "gemma2": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type*id){\n  if(!id)return id;\n  type id = idnumidnum;\n  type id = idnumidnum;\n  type *id = ;\n  type id = num;\n  type id = id;\n  call();\n  do{\n    if(id > num){\n      call(, (type)id->id);\n      call(, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, num, num, id->id) != num){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == ){\n        if(id)call(id, , (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, num, id.id, id->id) != id.id){\n        if(id)call(id, );\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[num] op (id[num] op num) != num);\n        id->id = id[num] op (id[num] op num);\n        if(id){\n          call(, (id->id ?  : ));\n          call(, id->id);\n        }\n        break;\n      case id:\n        id->id = id[num] op (id[num] op num);\n        if(id)call(, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call();\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }else{\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type ;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            if(id)call(, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type ;\n          id = (type)id;\n          call(, id->id op num);\n          if(id->id op num){\n            call(, id->id);\n            call(, id->id);\n          }else{\n            type *id = call((type)&id[num], id.id op num, num, id);\n            call(, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > num){\n          type *id = id op num;\n          type id, id;\n          id = id[num] op (id[num] op num);\n          for(id = num;  id < id; upd id){\n            call(, id op num, id[num], id[num], id[num]);\n            id = num;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call();\n          for(id = num;  id < id.id; upd id)call(, id[id]);\n          call();\n        }\n        break;\n      case def:\n        if(id){\n          call(, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = num;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)(type)id[num]);\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = call(id) op id;\n            *(type)((type)id op num) = (id) op id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)(type)id[num]);\n              call(, (id) op (type)((type)id op num));\n              call(, (type)(type)id[num]);\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (type)(type)id[id op num op num], (id) op (type)((type)id op id op num op num), (type)(type)id[id op num op num]);\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (type)(type)id[num]);\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)*(type)(id op num));\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = (type)call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = (id) op (type)id;\n            *(type)((type)id op num) = *(type)id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (id) op (type)(id op num));\n              call(, (id) op (type)((type)id op num));\n              call(, (id) op (type)(id op num));\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (id) op (type)(id op id op num op num), (id) op (type)((type)id op id op num op num), (id) op (type)(id op id op num op num));\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (id) op (type)(id op num));\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.015625,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A demonstrates a more structured approach with a `switch` statement for handling different cases, indicating a clearer intent to recognize and utilize jump table patterns. Candidate B relies heavily on nested `if-else` chains and `goto` statements, suggesting a more procedural and less idiomatic approach.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type*id){\n  if(!id)return id;\n  type id = idnumidnum;\n  type id = idnumidnum;\n  type *id = ;\n  type id = num;\n  type id = id;\n  call();\n  do{\n    if(id > num){\n      call(, (type)id->id);\n      call(, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, num, num, id->id) != num){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == ){\n        if(id)call(id, , (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, num, id.id, id->id) != id.id){\n        if(id)call(id, );\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[num] op (id[num] op num) != num);\n        id->id = id[num] op (id[num] op num);\n        if(id){\n          call(, (id->id ?  : ));\n          call(, id->id);\n        }\n        break;\n      case id:\n        id->id = id[num] op (id[num] op num);\n        if(id)call(, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call();\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }else{\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type ;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            if(id)call(, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type ;\n          id = (type)id;\n          call(, id->id op num);\n          if(id->id op num){\n            call(, id->id);\n            call(, id->id);\n          }else{\n            type *id = call((type)&id[num], id.id op num, num, id);\n            call(, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > num){\n          type *id = id op num;\n          type id, id;\n          id = id[num] op (id[num] op num);\n          for(id = num;  id < id; upd id){\n            call(, id op num, id[num], id[num], id[num]);\n            id = num;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call();\n          for(id = num;  id < id.id; upd id)call(, id[id]);\n          call();\n        }\n        break;\n      case def:\n        if(id){\n          call(, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = num;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)(type)id[num]);\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = call(id) op id;\n            *(type)((type)id op num) = (id) op id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)(type)id[num]);\n              call(, (id) op (type)((type)id op num));\n              call(, (type)(type)id[num]);\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (type)(type)id[id op num op num], (id) op (type)((type)id op id op num op num), (type)(type)id[id op num op num]);\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (type)(type)id[num]);\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = (type)id;\n    call();\n    id = num;\n    id = (type)&id op num;\n    id = (type)num;\n    id = num;\n    id = num;\n    do{\n      if(num < *(type)id){\n        call(, (type)*(type)(id op num));\n        id = *id;\n        call(, (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num), (id) op (type)(id op num));\n      }\n      id = call(id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(id);\n      if(*(type)id != num){\n        call(id);\n      }\n      if(id op num != num){\n        id = (type)call(id, id op num);\n        if(id == (type)num){\n          if(*(type)id == num){\n            return num;\n          }\n          call(*(type)id, , (type)id.id);\n          return num;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id op num){\n          id = num;\n          if(*(type)id != num){\n            call(, num, num, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      if(id.id < num){\n        switch(id.id){\n          case num:\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            if(*(type)id != num){\n              call();\n              if(id.id != num){\n                id = num;\n                do{\n                  call(, (id) op (type)((type)id op id));\n                  id = id op num;\n                }while(id < id op num);\n              }\n              call(num);\n            }\n            break;\n          case num:\n            id = (id) op (type)id;\n            *(type)((type)id op num) = *(type)id;\n            if(*(type)id != num){\n              id = ;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case num:\n            id = num;\n            goto lbl;\n          case num:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (id) op (type)(id op num));\n              call(, (id) op (type)((type)id op num));\n              call(, (id) op (type)(id op num));\n              if(id != num){\n                call(, id);\n              }\n            }\n            break;\n          case num:\n            if(id == num){\n              if((id == num) && (id = call(id, id, id.id)id != num))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case num:\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, call(*id op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, call(id[num] op num));\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n            break;\n          case num:\n            id = (id) op id;\n            *(type)((type)id op num) = *id;\n            if(*(type)id != num){\n              id = ;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != num){\n              call(, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < num){\n        if(id.id < num){\n          if(id.id == num){\n            if((num < *(type)id) && (id = *idid != num)){\n              id = num;\n              do{\n                call(, call((type)id op num), (id) op (type)(id op id op num op num), (id) op (type)((type)id op id op num op num), (id) op (type)(id op id op num op num));\n                id = id op num;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != num)goto lbl;\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id == num){\n                if(*(type)id != num){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != num)break;\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              id = (type)id[num];\n              id = ;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != num)break;\n        }elseif(id.id != num)goto lbl;\n      }elseif(id.id < num){\n        if(id.id == num)goto lbl;\n        if(id.id != num)goto lbl;\n        if(*(type)id != num){\n          call(, call(*id op num));\n          if((type)*id < num){\n            call(, (id) op (type)(id op num));\n            id = (id) op (type)((type)id op num);\n            id = ;\n            goto lbl;\n          }\n          id = (type)call(id op num, (id op num) op num, num, id);\n          call(, id);\n          call(id);\n        }\n      }else{\n        if(id.id == num){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != num)goto lbl;\n        id = *id;\n        *(type)((type)id op num) = id != num;\n        *(type)((type)id op num) = id[num];\n        if(*(type)id != num){\n          id = ;\n          if(id != num){\n            id = ;\n          }\n          call(, id);\n          id = (id) op (type)((type)id op num);\n          id = ;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = num;\n      if(*(type)(*id op num) != )break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != num);\n    lbl:\n    if(id != (type)num){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.015625,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A demonstrates a more structured approach with a clear `for` loop and a `switch` statement for handling different cases. Candidate B relies heavily on nested `if-else` blocks and `goto` statements, indicating a more procedural and less idiomatic design.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch(*(undefined *)(param_2 + 3)) {\n    case 1:\n      local_28 = (long)(char)param_3;\n      break;\n    case 2:\n    case 7:\n    case 10:\n      local_28 = (long)(short)param_3;\n      break;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x29:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      local_28 = (long)(int)param_3;\n      break;\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",*(undefined *)(param_2 + 3));\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "type id(type*id, type*id, typeid){\n  if(!(id->id op id)){\n    switch(id->id){\n      case id:\n        id = call(id, id, id);\n        break;\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        break;\n      case def:\n        if(id->id op id)call(id, , id->id);\n        return id;\n    }\n  }\n  return id;\n}",
        "base_ast": " id(id, type*id, id){\n  type id;\n  id = id;\n  if((*id op num) == num){\n    switch((type)id[num]){\n      case :\n        id = (type)(type)id;\n        break;\n      case :\n      case :\n      case :\n        id = (type)(type)id;\n        break;\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        break;\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        id = (type)(type)id;\n        break;\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        break;\n      case def:\n        if((*(type)(id op num) op num) != num){\n          call(id, , (type)id[num]);\n        }\n        return num;\n    }\n  }\n  return id;\n}",
        "pr_ast": " id(id, type*id, id){\n  type id;\n  id = id;\n  if((*id op num) == num){\n    switch(*(type)(id op num)){\n      case num:\n        id = (type)(type)id;\n        break;\n      case num:\n      case num:\n      case num:\n        id = (type)(type)id;\n        break;\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n        break;\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n        id = (type)(type)id;\n        break;\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n      case num:\n        break;\n      case def:\n        if((*(type)(id op num) op num) != num){\n          call(id, , *(type)(id op num));\n        }\n        return num;\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.875,
          "base_ppl": 2.046875,
          "pr_ppl": 1.7265625,
          "source_ast_ppl": 1.8515625,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.015625,
          "delta_ppl": -0.3203125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit similar control flow structures, primarily relying on `if` and `switch` statements. However, Candidate A demonstrates a slightly more compact and readable structure with fewer nested blocks and a more direct `switch` statement usage. Candidate B's `switch` statement appears to be slightly more convoluted due to the way it handles the `*(type)(id op num)` expression.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar3 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(local_18 + 1));\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = *(byte *)local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(local_28 + 5));\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(local_28 + 6));\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar3) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)*(byte *)local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              bVar1 = *(byte *)local_28;\n              bVar2 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)bVar1 + (uint)bVar2 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)*(byte *)local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)*(byte *)(local_78 + 1));\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(local_28 + 1));\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)*(byte *)local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 !=\n                       0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)*(byte *)(local_28 + 1) +\n                       (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar3 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type*id){\n  if(!id)return id;\n  type id = idnumidnum;\n  type id = idnumidnum;\n  type *id = ;\n  type id = num;\n  type id = id;\n  call();\n  do{\n    if(id > num){\n      call(, (type)id->id);\n      call(, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, num, num, id->id) != num){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == ){\n        if(id)call(id, , (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, num, id.id, id->id) != id.id){\n        if(id)call(id, );\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[num] op (id[num] op num) != num);\n        id->id = id[num] op (id[num] op num);\n        if(id){\n          call(, (id->id ?  : ));\n          call(, id->id);\n        }\n        break;\n      case id:\n        id->id = id[num] op (id[num] op num);\n        if(id)call(, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call();\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id op num);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n          }\n        }else{\n          type ;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type ;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            call(, id->id);\n            if(id)call(, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type ;\n          id = (type)id;\n          call(, id->id op num);\n          if(id->id op num){\n            call(, id->id);\n            call(, id->id);\n          }else{\n            type *id = call((type)&id[num], id.id op num, num, id);\n            call(, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > num){\n          type *id = id op num;\n          type id, id;\n          id = id[num] op (id[num] op num);\n          for(id = num;  id < id; upd id){\n            call(, id op num, id[num], id[num], id[num]);\n            id = num;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call();\n          for(id = num;  id < id.id; upd id)call(, id[id]);\n          call();\n        }\n        break;\n      case def:\n        if(id){\n          call(, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = num;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = id;\n    call(&id, num, num);\n    call(&id, num, num);\n    id = (type)num;\n    id = bool;\n    id = num;\n    call();\n    do{\n      if(num < *(type)id){\n        call(, (type)(type)id[num]);\n        call(, (id) op (type)(*id op num), *(type)(*id op num) op num, *(type)(*id op num) op num, *(type)(*id op num) op num);\n      }\n      id = call(&id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(&id);\n      if(*(type)id != num){\n        call(&id);\n      }\n      if(id.id != num){\n        id = call(id, (type)id.id);\n        if(id == (type)num){\n          if(*(type)id != num){\n            call(*(type)id, , (type)id.id);\n          }\n          id = num;\n          break;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != num){\n            call(*(type)id, );\n          }\n          id = num;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      id = id op num;\n      if(id != num){\n        if(id == num){\n          if(*(type)id != num){\n            call();\n            for(id = num;  id < (type)(id op num); id = id op num){\n              call(, (id) op (type)((type)id op (type)id));\n            }\n            call();\n          }\n        }elseif(id == num){\n          *(type)((type)id op num) = (id) op id;\n          if(*(type)id != num){\n            call(, (id) op (type)((type)id op num));\n          }\n        }else{\n          if(id == num){\n            id = num;\n            break;\n          }\n          if(id == num){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)(type)id[num]);\n              call(, (id) op (type)((type)id op num));\n              call(, (type)(type)id[num]);\n              if(id != num){\n                call(, id);\n              }\n            }\n          }elseif(id == num){\n            if(id){\n              if(((type)id == num) && (id = call(id, id, id.id)id != num))break;\n              id = id;\n            }\n          }elseif(id == num){\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, (id) op id op num, (id) op id op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n            }\n          }elseif(id == num){\n            *(type)((type)id op num) = call(id) op id op (id) op (type)((type)id op num) op num;\n            if(*(type)id != num){\n              call(, (id) op (type)((type)id op num));\n            }\n          }elseif(id == num){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != num)break;\n          }elseif(id == num){\n            if(num < *(type)id){\n              id = id op num;\n              id = *id;\n              id = *(type)((type)id op num);\n              for(id = num;  id < (type)((type)(type)id op (type)id op num); id = id op num){\n                call(, call(id op num), call(id) op id, (id) op (type)((type)id op num), (type)(type)id[num]);\n                id = id op num;\n              }\n            }\n          }elseif(id == num){\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(, (id) op id);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n              }\n            }\n          }else{\n            if(id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id == num){\n                if(*(type)id != num){\n                  call(, call(*id op num));\n                  if((*id op num) == num){\n                    id = (type)call(id op num, (type)(type)((id op num) op num), num, id);\n                    call(, id);\n                    call(id);\n                  }else{\n                    call(, (type)(type)id[num]);\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }\n              }else{\n                if(id == num){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == num){\n                  *(type)((type)id op num) = call(id) op id op (id) op (type)((type)id op num) op num != num;\n                  *(type)((type)id op num) = (type)(type)id[num] op (id) op (type)((type)id op num) op num;\n                  if(*(type)id != num){\n                    id = ;\n                    if(*(type)((type)id op num) != ){\n                      id = ;\n                    }\n                    call(, id);\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }elseif(*(type)id != num){\n                  call(, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id op num) == ){\n        id = (type)id != num;\n      }\n    }while(id);\n    if(id != (type)num){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  if(id == (type)num){\n    id = num;\n  }else{\n    id = id;\n    call(&id, num, num);\n    call(&id, num, num);\n    id = (type)num;\n    id = bool;\n    id = num;\n    call();\n    do{\n      if(num < *(type)id){\n        call(, (type)*(type)(id op num));\n        call(, (id) op (type)(*id op num), *(type)(*id op num) op num, *(type)(*id op num) op num, *(type)(*id op num) op num);\n      }\n      id = call(&id, num, num, *id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      call(&id);\n      if(*(type)id != num){\n        call(&id);\n      }\n      if(id.id != num){\n        id = (type)call(id, (type)id.id);\n        if(id == (type)num){\n          if(*(type)id != num){\n            call(*(type)id, , (type)id.id);\n          }\n          id = num;\n          break;\n        }\n        id = call(id, num, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != num){\n            call(*(type)id, );\n          }\n          id = num;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != num){\n        id = num;\n        break;\n      }\n      id = id op num;\n      if(id != num){\n        if(id == num){\n          if(*(type)id != num){\n            call();\n            for(id = num;  id < (type)(id op num); id = id op num){\n              call(, (id) op (type)((type)id op (type)id));\n            }\n            call();\n          }\n        }elseif(id == num){\n          *(type)((type)id op num) = *(type)id;\n          if(*(type)id != num){\n            call(, (id) op (type)((type)id op num));\n          }\n        }else{\n          if(id == num){\n            id = num;\n            break;\n          }\n          if(id == num){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != num){\n              call(, (id) op id);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (id) op (type)(id op num));\n              call(, (id) op (type)((type)id op num));\n              call(, (id) op (type)(id op num));\n              if(id != num){\n                call(, id);\n              }\n            }\n          }elseif(id == num){\n            if(id){\n              if(((type)id == num) && (id = call(id, id, id.id)id != num))break;\n              id = id;\n            }\n          }elseif(id == num){\n            call(id);\n            *(type)(id op num) = id[num];\n            if(*(type)id != num){\n              call();\n              call(, (id) op id op num, (id) op id op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num] op num, (type)id[num] op num);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n              call(, (type)id[num]);\n            }\n          }elseif(id == num){\n            *(type)((type)id op num) = (id) op (type)id op (id) op (type)((type)id op num) op num;\n            if(*(type)id != num){\n              call(, (id) op (type)((type)id op num));\n            }\n          }elseif(id == num){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != num)break;\n          }elseif(id == num){\n            if(num < *(type)id){\n              id = id op num;\n              id = *(type)id;\n              id = *(type)((type)id op num);\n              for(id = num;  id < (type)((type)id op (type)id op num); id = id op num){\n                call(, call(id op num), (id) op (type)id, (id) op (type)((type)id op num), (id) op (type)(id op num));\n                id = id op num;\n              }\n            }\n          }elseif(id == num){\n            if(*(type)((type)id op num) == ){\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != num)break;\n              if(*(type)id != num){\n                call(, (id) op id);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n                call(, (type)id[num]);\n              }\n            }\n          }else{\n            if(id == num){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id == num){\n                if(*(type)id != num){\n                  call(, call(*id op num));\n                  if((*id op num) == num){\n                    id = (type)call(id op num, (type)(type)((id op num) op num), num, id);\n                    call(, id);\n                    call(id);\n                  }else{\n                    call(, (id) op (type)(id op num));\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }\n              }else{\n                if(id == num){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == num){\n                  *(type)((type)id op num) = (id) op (type)id op (id) op (type)((type)id op num) op num != num;\n                  *(type)((type)id op num) = (id) op (type)(id op num) op (id) op (type)((type)id op num) op num;\n                  if(*(type)id != num){\n                    id = ;\n                    if(*(type)((type)id op num) != ){\n                      id = ;\n                    }\n                    call(, id);\n                    call(, (id) op (type)((type)id op num));\n                  }\n                }elseif(*(type)id != num){\n                  call(, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id op num) == ){\n        id = (type)id != num;\n      }\n    }while(id);\n    if(id != (type)num){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.96875,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Candidate A demonstrates a more structured approach with a clear `do...while` loop and nested conditional statements. Candidate B, while functional, relies heavily on nested `if-else` blocks and jumps, suggesting a more procedural and less idiomatic design.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type ;\n  type *id = ;\n  type id = num;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), , id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), , id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = ;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), , id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = (type)call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = (type)call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": -1,
          "pr_ppl": 1.7578125,
          "source_ast_ppl": 2.234375,
          "base_ast_ppl": 2.125,
          "pr_ast_ppl": 2.109375,
          "delta_ppl": 2.7578125
        },
        "llm_ast": {
          "motivation": "Candidate A exhibits a more structured and logical flow, resembling a series of nested conditional statements and loops. Candidate B, on the other hand, relies heavily on chained `if-else` blocks and `goto` statements, indicating a more procedural and less idiomatic approach.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type ;\n  type *id = ;\n  type id = num;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), , id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), , id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = ;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), , id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = call(id);\n  id = id op (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == num){\n    id = num;\n    id = (type)num;\n    id = (type)num;\n  }else{\n    id = num op (type)id;\n    id = num;\n    id = (type)num;\n    id = (type)num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op *(type)(id op id op num);\n      id = (id) op (type)(id op id op num);\n      id = (type)(type)id[id];\n      id = id op ((type)id op num);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id op (type)id op num;\n            id = id op id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id op (type)id;\n              goto lbl;\n            }\n            id = id op num;\n            if(id < id)goto lbl;\n          }\n          id = id op num;\n        }while(id <= id);\n      }\n      lbl:\n      id = id op id;\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op id;\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != num) && (id = (type)[id op num][id op num] != )){\n        id =  op id op num;\n        do{\n          id = id;\n          switch(id[num]){\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n              break;\n            case :\n            case :\n              id = id;\n              break;\n            case :\n            case :\n              id = id op -(type)id;\n              break;\n            case :\n              id = id;\n              id = (type)call(id, id, id, num, id);\n              id = id;\n              if(id == (type)num){\n                call(id, num, , id);\n                id = id;\n                if(*(type)(id op num) != (type)num){\n                  call(id, *(type)(id op num));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = id op num;\n                  }while(id <= id);\n                }\n                id = id op num;\n                if(((type)id op (type)id op num) op num < (type)id){\n                  id = id op id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != num)break;\n                    call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                    id = (type)id op num;\n                    id = id op num;\n                    id = id op num;\n                  }while(id op num < (type)id);\n                }\n              }\n              break;\n            case :\n              call(id, id, (type)id);\n              id[(type)id] = num;\n          }\n          id = id op num;\n          id = id op num;\n        }while(id != num);\n      }\n      id = id;\n      if((type)id == num)goto lbl;\n      id = id op num;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)[(type)(type)id[id] op num];\n  if([(type)(type)id[id] op num] != ){\n    id =  op (type)(type)id[id] op num;\n    id = id op -(type)id;\n    id = (type)(num op (type)id);\n    do{\n      id = id;\n      id = id[num];\n      id = id;\n      if(id != ){\n        id = id;\n        if(id == ){\n          call(id, id, (type)id);\n          id[(type)id] = num;\n        }elseif(id == ){\n          id = (type)call(id, id, id, num, id);\n          if(id == (type)num){\n            call(id, num, , id);\n            if(*(type)(id op num) != (type)num){\n              call(id, *(type)(id op num));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = id op num;\n              }while(id <= id);\n            }\n            id = id op num;\n            if(((type)id op (type)id op num) op num < (type)id){\n              id = id op (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != num)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , (type)id op num, id);\n                id = (type)id op num;\n                id = id op num;\n                id = id op num;\n              }while(id op num < (type)id);\n            }\n          }\n        }\n      }\n      id = id op num;\n      id = id op num;\n      id = id;\n    }while(id != num);\n  }\n  id = num;\n  if(id < num){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, num, , id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.75,
          "pr_ppl": 1.7578125,
          "source_ast_ppl": 2.234375,
          "base_ast_ppl": 2.125,
          "pr_ast_ppl": 2.109375,
          "delta_ppl": 0.0078125
        },
        "llm_ast": {
          "motivation": "Candidate A exhibits a more structured approach with nested `if` statements and `while` loops, indicating a higher level of abstraction. Candidate B relies heavily on `goto` statements and a complex chain of nested blocks, suggesting a more decompiled and less idiomatic structure.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type id = num;\n  type *id = ;\n  type id = num;\n  type id = num op id;\n  type *id = ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = ;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != ){\n            type id = (*id) op ;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, , (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = (type)call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = (type)call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.875,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 2.40625,
          "base_ast_ppl": 2.171875,
          "pr_ast_ppl": 2.171875,
          "delta_ppl": -0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit a complex, nested structure, but Candidate A demonstrates a clearer attempt at higher-level abstraction. It uses a `switch` statement within a loop, suggesting a recognition of pattern matching, while Candidate B relies heavily on chained `if-else` blocks and `goto` statements, indicative of a more direct translation from low-level control flow.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type id = num;\n  type *id = ;\n  type id = num;\n  type id = num op id;\n  type *id = ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = ;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != ){\n            type id = (*id) op ;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, , (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  id = call(id);\n  id = id op id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == num){\n    id = num;\n    id = num;\n  }else{\n    id = num;\n    id = num;\n    id = (type)num;\n    id = num;\n    id = id;\n    do{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if(id != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((num op ((type)(type)id[id] op num) op num) == num){\n        id = (type)(type)id[(type)id[id]];\n        if(id != num){\n          id = id op (type)id[id];\n          do{\n            switch(id[num]){\n              case num:\n                call(id, id, id);\n                id[id] = ;\n                break;\n              case num:\n                id = id;\n                break;\n              case num:\n                id = (type)id op (type)id;\n                break;\n              case num:\n                id = (type)call(id, id, (type)id, num, id);\n                id = id;\n                if(id != (type)num){\n                  do{\n                    id = id;\n                    id = id op num;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == num);\n                  id = id op (num op (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id op num) op num)break;\n                    id = call(id op num, id);\n                    id = id op num;\n                    id = id op num;\n                  }while(id == num);\n                  if(id <= id){\n                    id = *(type)(id op num);\n                    do{\n                      id = *(type)(id op (type)*(type)(id op num) op num);\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      *(type)(id op num) = id;\n                      id = id op num;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case num:\n                if(*id != num){\n                  id = *id op num;\n                  if(~(type)id op num < id){\n                    id = id op num;\n                    goto lbl;\n                  }\n                  id = (type)id op id op num;\n                }\n                break;\n              case num:\n                id = num;\n            }\n            id = id op num;\n            id = id op num;\n          }while(id != num);\n        }\n      }\n      if(id == num)goto lbl;\n      id = id op num;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != ){\n    id = id op (type)id[id];\n    do{\n      if((id[num] == ) && (id = (type)call(id, id, (type)id, num, id)id = idid != (type)num)){\n        do{\n          id = id;\n          id = id op num;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == num);\n        id = id op (num op (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id op num) op num)break;\n          id = call(id op num, id);\n          id = id op num;\n          id = id op num;\n        }while(id == num);\n        if(id <= id){\n          id = *(type)(id op num);\n          do{\n            id = *(type)(id op (type)*(type)(id op num) op num);\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            *(type)(id op num) = id;\n            id = id op num;\n          }while(id <= id);\n        }\n      }\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n  }\n  lbl:\n  if((id < num) || (id = numid != id)){\n    lbl:\n    id = num;\n    if(*(type)(id op num) != num){\n      call(id, (type)(id op num), , (type)id op (type)id, (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.8828125,
          "pr_ppl": 1.875,
          "source_ast_ppl": 2.40625,
          "base_ast_ppl": 2.171875,
          "pr_ast_ppl": 2.171875,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Candidate A exhibits a clearer structure with nested loops and conditional statements resembling typical programming patterns. Candidate B relies heavily on `goto` statements and lacks the logical flow of a human-written program.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type ;\n  type *id = ;\n  type id = num;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), , id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), , (type)id, id);\n              id upd;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), , id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), , (type)id, id);\n                id upd;\n              }\n            }\n          }\n          break;\n          case num:\n          {\n            call(id, id, id);\n            id[id] = ;\n          }\n          break;\n          case num:\n          {\n            id = id op id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, (id), , id, (type)id, (type)(id op id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != ){\n      id = (type)[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, , id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == ){\n        id = call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, , id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == ){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == ){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, , (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op (type)id;\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)*(type)(id op (type)id op num);\n    id = (id) op (type)(id op (type)id op num);\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != ){\n      id = (type)[(type)(type)(type)id[id] op num];\n      id = &id op (type)(type)id[id];\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = (type)call(id, id, (type)id, num, id);\n            id = id;\n            if(id == (type)num){\n              call(id, num, , id);\n              if(*(type)(id op num) != num){\n                call(id, *(type)(id op num));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id op num;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n                id = id;\n              }\n            }\n            break;\n          case num:\n            call(id, id, id);\n            id[id] = num;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)[(type)(type)(type)id[id] op num];\n    id = &id op (type)(type)id[id];\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == ){\n        id = (type)call(id, id, (type)id, num, id);\n        id = id;\n        if(id == (type)num){\n          call(id, num, , id);\n          if(*(type)(id op num) != num){\n            call(id, *(type)(id op num));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id op num;\n          }\n          while(bool){\n            id = id op num;\n            id = bool;\n            if(((type)id op (type)id) op num < (type)id){\n              id = call(id, id);\n              id = id == num;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num), num, , id op num, id);\n            id = id;\n          }\n        }\n      }elseif(id == ){\n        call(id, id, id);\n        id[id] = num;\n      }elseif(id == ){\n        id = (type)id op (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, num, , (type)id, id, (type)id op (type)id, id, (id) op id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.734375,
          "pr_ppl": 1.7265625,
          "source_ast_ppl": 2.234375,
          "base_ast_ppl": 2.0,
          "pr_ast_ppl": 1.9921875,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, but Candidate A demonstrates a more structured approach. It utilizes a `for` loop, suggesting a higher-level understanding of iteration compared to Candidate B's reliance on nested `while` loops and `goto` statements.  The presence of a `switch` statement in Candidate A further indicates a more idiomatic representation of conditional logic.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type ;\n  type id = num;\n  type *id = ;\n  type id = num;\n  type id = num op id;\n  type *id = ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type *id = ;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type ;\n    type id;\n    type ;\n    if(id == id)goto lbl;\n    if(id == num)goto lbl;\n    lbl:\n    id = id op id[id];\n    id = id[id];\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op id op num;\n      while(num){\n        if(id < id)break;\n        id = id op ((id op id) op num);\n        if((*id) < *id)id = id op num;elseif((*id) > *id)id = id op num;else{\n          id = (type)(id op id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > num){\n      type *id = id;\n      type ;\n      type *id = id op (id op num) op num;\n      while(num){\n        if(id < id)break;\n        id = id op (((id op id) op num) op ~num);\n        if((*id) < id[num])id = id op num;elseif((*id) > id[num])id = id op num;else{\n          id = (type)((id op id) op num);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == num)goto lbl;\n    id = id op id[id];\n    id = (type)*id upd;\n    while(id upd > num){\n      switch(*id upd){\n        case num:\n        {\n          call(id, id, id);\n          id[id] = ;\n        }\n        break;\n        case num:\n        {\n          id = id;\n        }\n        break;\n        case num:\n        {\n          id = id op id;\n        }\n        break;\n        case num:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id op num;\n            while(id >= id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            id = id op num;\n            while(id op id < id && call(id->id, id) == num){\n              id = id;\n              id upd;\n            }\n            for(id = id;  id <= id; id upd){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          if((*id) != ){\n            type id = (*id) op ;\n            if(id <= (id op id) op num){\n              id = num op id op id;\n            }else{\n              {\n                id upd;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case num:\n        {\n          id = num;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == num)goto lbl;\n    if(upd id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id op id[id];\n      type id = (type)*id upd;\n      while(id upd > num){\n        switch(*id upd){\n          case num:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id op num;\n              while(id >= id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              id = id op num;\n              while(id op id < id && call(id->id, id) == num){\n                id = id;\n                id upd;\n              }\n              for(id = id;  id <= id; id upd){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < num || id != id){\n    if(id->id.id){\n      call(id, id, , (type)(id op id), (type)(id op id), (type)(id op id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != ){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == ) && (id = call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, , (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = num;\n  id = num;\n  id = (type)num;\n  id = num;\n  id = id op num;\n  id = id op id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = num;\n  for(; id != id; id = id op num){\n    id = id op (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id op (type)id op num;\n      id = id;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= *id){\n            id = ((type)id op (type)id) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n      id = id op id;\n    }\n    id = (type)(type)id[id];\n    if(num < id){\n      id = id;\n      id = id op (type)(id op num) op num;\n      while(id <= id){\n        id = id op ((type)id op (type)id op num op num);\n        if(*id < *id){\n          id = id op num;\n        }else{\n          if(*id <= id[num]){\n            id = (type)((type)id op (type)id op num) op id;\n            goto lbl;\n          }\n          id = id op num;\n        }\n      }\n      id = id op id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != ){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id op (type)(type)(type)id[id] op num;\n      while(id = id op numid != num){\n        id = id op num;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case num:\n            call(id, id, id);\n            id[id] = ;\n            break;\n          case num:\n            id = id;\n            break;\n          case num:\n            id = (type)id op (type)id;\n            break;\n          case num:\n            id = (type)call(id, id, (type)id, num, id);\n            id = id;\n            if(id != (type)num){\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id op num;\n                id = bool;\n                if(((type)id op (type)id) op num < (type)id){\n                  id = call(id, id);\n                  id = id == num;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id op num){\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n                *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n              }\n            }\n            break;\n          case num:\n            if(*id != num){\n              if((-call(*id op num) op num) op num < id){\n                id = id op num;\n                goto lbl;\n              }\n              id = id op num op call(*id op num);\n            }\n            break;\n          case num:\n            id = num;\n        }\n      }\n    }\n    if(id == num)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id op (type)(type)(type)id[id] op num;\n    while(id = id op numid != num){\n      id = id op num;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == ) && (id = (type)call(id, id, (type)id, num, id)id = idid != (type)num)){\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id op num;\n          id = bool;\n          if(((type)id op (type)id) op num < (type)id){\n            id = call(id, id);\n            id = id == num;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id op num){\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n          *(type)(*(type)(*(type)(id op num) op (type)*(type)(id op num) op num) op num) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < num) || (id != id)){\n    if(*(type)(id op num) != num){\n      call(id, (type)id, , (type)id op (type)id, (type)id op (type)id, call((type)id op (type)id), id);\n      call(id, *(type)(id op num));\n    }\n    id = num;\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.71875,
          "pr_ppl": 1.7109375,
          "source_ast_ppl": 2.40625,
          "base_ast_ppl": 1.984375,
          "pr_ast_ppl": 1.984375,
          "delta_ppl": -0.0078125
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, but Candidate A demonstrates a more structured approach with nested loops and a clear `switch` statement for handling different cases. Candidate B relies heavily on `goto` statements and deeply nested blocks, indicating a less idiomatic and potentially less maintainable design.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type ;\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.078125,
          "base_ast_ppl": 2.40625,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit a complex, nested structure that's difficult to interpret directly. However, Candidate A demonstrates a more organized flow with a clear `do-while` loop and a `switch` statement, suggesting a higher level of abstraction. Candidate B relies heavily on nested `if-else` blocks and `goto` statements, which are more characteristic of a decompiler's struggle to reconstruct idiomatic code.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id op num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    type ;\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)id op num) op num;\n      }\n    }else{\n      id = (type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)*id op id op num op num;\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = id op num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = id;\n        }\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if((id != id) || (id = numid < )){\n        if(id != (type)num){\n          call(id, num, , id op num, id op num, id);\n          call(id, id);\n        }\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.078125,
          "base_ast_ppl": 2.40625,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, heavily reliant on nested loops and conditional statements. However, Candidate A demonstrates a more structured approach with a clear `do-while` loop and a `switch` statement for handling multiple cases. Candidate B, on the other hand, relies on a series of nested `if-else` blocks and `goto` statements, indicating a less idiomatic and potentially less maintainable design.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op );\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 2.140625,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.5625,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, heavily relying on nested blocks and numerous conditional statements. However, Candidate A demonstrates a clearer attempt at structuring its logic using a `do-while` loop and a `switch` statement within a nested block. Candidate B, on the other hand, relies heavily on chained `if-else` blocks and `goto` statements, indicating a more decompiler-driven structure rather than a high-level design.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                type id = ((((*(id)))) op );\n                if(id >= num && id <= num){\n                  id = num op id op id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                if(id < num){\n                  id->id = num op id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = num;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = (type)*(type)(id op (type)(type)id op num) op num;\n      }\n    }else{\n      id = (type)(type)id;\n      id =  op (type)id[id];\n      id = (id) op (type)(id op id op num);\n      if(id < num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id op (type)id) op id;\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)(type)id[id];\n      if( < (type)id[id]){\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != num) && (id = id[id]id != )){\n      id = num;\n      do{\n        id = id;\n        switch(*(type)(id op num op id)){\n          case num:\n            id = (type)(type)(*id op num) op id op num;\n            if(num < call(*id op num)){\n              id = id;\n            }\n            break;\n          case num:\n            if(id < num){\n              *(type)(id op num) = id op num;\n            }else{\n              *(type)(id op num) = id;\n            }\n            break;\n          case num:\n            id = num;\n            break;\n          case num:\n            *(type)(id op num) = id;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n            break;\n          case num:\n            *(type)(id op num) = num;\n        }\n        id = id;\n        id = id op num;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id op numid == )){\n      if(((id != id) || (id = numid < )) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 2.140625,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.5625,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, but Candidate A demonstrates a more structured approach with nested loops and conditional statements. Candidate B relies heavily on `goto` statements and lacks the clear loop and branching patterns seen in A.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id ==  || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if((id != (type)num) && (id = *idid != num)){\n    id = id op num;\n    id = num;\n    id = num;\n    id = num;\n    id = bool;\n    do{\n      id = num;\n      id = bool;\n      switch(id){\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          id = bool;\n          id = num;\n          break;\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          goto lbl;\n        case num:\n          break;\n        case def:\n          id = num;\n          id = bool;\n          if(num < id op num){\n            return num;\n          }\n      }\n      if(!id){\n        return num;\n      }\n      id = id op id;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      id = id;\n    }while(id != num);\n    if((id == num && id < num) && (id < num)){\n      *id = id;\n      id = num;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.890625,
          "source_ast_ppl": 5.4375,
          "base_ast_ppl": 2.625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Candidate A exhibits a more structured approach with a `do-while` loop and a `switch` statement, indicating a better understanding of control flow patterns. Candidate B relies heavily on `goto` statements and lacks the clear iteration structure of a `for` loop, suggesting a more decompiler-generated and less human-like design.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type*id, type*id){\n  if(id ==  || id[num].id == id)return id;\n  type id = num;\n  type id = bool;\n  type id = bool;\n  type id = num;\n  do{\n    type id;\n    for(id = num;  id[id].id != id[id].id; upd id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[upd id].id != id);\n  if(id > id || !id || id > num)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if(id != (type)num){\n    id = *id;\n    if(id != num){\n      id = num;\n      id = num;\n      id = num;\n      id = bool;\n      do{\n        id = id op num;\n        id = num;\n        id = bool;\n        switch(id){\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            id = bool;\n            id = num;\n            break;\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n          case num:\n            goto lbl;\n          case num:\n            break;\n          case def:\n            id = num;\n            id = bool;\n            if(num < id op num)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id op id;\n        id = id op num;\n        id = *id;\n        id = id;\n      }while(id != num);\n      if((id == num && id < num) && (id < num)){\n        *id = id;\n        id = num;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id(*id, type*id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = num;\n  if((id != (type)num) && (id = *idid != num)){\n    id = id op num;\n    id = num;\n    id = num;\n    id = num;\n    id = bool;\n    do{\n      id = num;\n      id = bool;\n      switch(id){\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          id = bool;\n          id = num;\n          break;\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n        case num:\n          goto lbl;\n        case num:\n          break;\n        case def:\n          id = num;\n          id = bool;\n          if(num < id op num){\n            return num;\n          }\n      }\n      if(!id){\n        return num;\n      }\n      id = id op id;\n      id = id op num;\n      id = *id;\n      id = id op num;\n      id = id;\n    }while(id != num);\n    if((id == num && id < num) && (id < num)){\n      *id = id;\n      id = num;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.890625,
          "source_ast_ppl": 5.4375,
          "base_ast_ppl": 2.625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "While both candidates exhibit a complex control flow, Candidate A demonstrates a more structured approach with a clear `for` loop-like iteration pattern using `do-while`. Candidate B relies heavily on `goto` statements and nested `if` conditions, suggesting a less idiomatic and more control flow graph-like representation.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013e6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013e6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num){\n          lbl:\n          id = *id op id;\n          if(id == num){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        if(id == num)goto lbl;\n        lbl:\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        id = *id;\n        if(id != num)goto lbl;\n        lbl:\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        call(id op num, num);\n        call(id op num, num);\n        id = call(num);\n        id = call(id op num, id op num, (type)id);\n        if(id != num){\n          return num;\n        }\n        id = call(id op id, *id op id, id[num]);\n        id[num] = id;\n        *id = num;\n      case num:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return num;\n          }\n          id = id[num];\n          id = id[num];\n          *id = id op num;\n          if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n          id = *id;\n          *id = id op num;\n          if(num < id op num){\n            return num;\n          }\n        }\n        return num;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  id = *id op id;\n  if(id == num){\n    return num;\n  }\n  lbl:\n  id = call(id op id, id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 2.0,
          "pr_ppl": 1.953125,
          "source_ast_ppl": 3.109375,
          "base_ast_ppl": 2.4375,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": -0.046875
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit a similar control flow structure with nested loops and conditional branches. However, Candidate A utilizes a `switch` statement for the primary decision-making, indicating a better understanding of the code's intent compared to Candidate B's reliance on chained `if-else` blocks.  Candidate A also avoids the use of `goto` statements within the main loop, promoting a more readable and maintainable structure.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013d6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013d6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type*id, type*id, type*id, typeid){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id) upd] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = num;\n        id->id = (id->id == num ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = num;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (upd id->id == num ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(num) op call(id->id.id, id->id.id)) op num;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > num){\n        upd id->id;\n        if(id[(*id) upd] != num)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != num)return id;\n      id->id = call(id op id, *id op id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id op (id->id op num)) op num) != id[(*id) upd]){\n          idreturn id;\n        }\n      }while(upd id->id < num);\n      return id;\n    case def:\n      call(num);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id op id;\n    if(id > num)id->id = call(id op id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        goto lbl;\n      case num:\n        id = *id;\n        lbl:\n        if(id == num){\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) != *(type)(id op num)){\n            return num;\n          }\n          call(id op num, num);\n          call(id op num, num);\n          id = call(num);\n          id = call(id op num, id op num, (type)id);\n          if(id != num){\n            return num;\n          }\n          id = call(id op id, *id op id, id[num]);\n          id[num] = id;\n          *id = num;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return num;\n            }\n            id = id[num];\n            id = id[num];\n            *id = id op num;\n            if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n            id = *id;\n            *id = id op num;\n            if(num < id op num){\n              return num;\n            }\n          }\n          return num;\n        }\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        goto lbl;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "pr_ast": "type id(type*id, id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = *id;\n  if(id <= id){\n    return num;\n  }\n  id = (type)(id op num);\n  id = (type)(id op num);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case num:\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        break;\n      case num:\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        *id = num;\n        id = call(*(type)(id op num) == num) op num op num;\n        break;\n      case num:\n      case num:\n        id = id op num;\n        if(id != num){\n          id = id op num;\n        }\n        id = call(id, id, id, id, id);\n        if(id != num)goto lbl;\n        id[num] = num;\n        id[num] = num;\n        if(*id == num){\n          id = num;\n          if(*(type)(id op num) op num < num){\n            return num;\n          }\n        }else{\n          call(id op num, *(type)(id op num), *(type)(id op num));\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          if(*(type)(id op num) < *(type)(id op num)){\n            return num;\n          }\n          *id = *id op num;\n          id = call(*id == num) op num op num;\n        }\n        break;\n      case num:\n        id = call(*(type)(id op num), *(type)(id op num));\n        id = call(-id op num);\n        *(type)(id op num) = id;\n        *id = num;\n        if(id == num)goto lbl;\n        lbl:\n        *id = id op num;\n        id = *id;\n        *id = id op num;\n        id = num;\n        if(*(type)(id op id) != ){\n          return num;\n        }\n        goto lbl;\n      case num:\n        id = *id;\n        if(id != num)goto lbl;\n        lbl:\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        if(*(type)(id op num) != *(type)(id op num)){\n          return num;\n        }\n        call(id op num, num);\n        call(id op num, num);\n        id = call(num);\n        id = call(id op num, id op num, (type)id);\n        if(id != num){\n          return num;\n        }\n        id = call(id op id, *id op id, id[num]);\n        id[num] = id;\n        *id = num;\n      case num:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return num;\n          }\n          id = id[num];\n          id = id[num];\n          *id = id op num;\n          if(*(type)(id op id) != (type)(id op (call(id op num) op num)))break;\n          id = *id;\n          *id = id op num;\n          if(num < id op num){\n            return num;\n          }\n        }\n        return num;\n      case def:\n        return num;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = num;\n  lbl:\n  if(*id op id == num){\n    return id;\n  }\n  id = call(id op id, *id op id, id[num]);\n  id[num] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 2.015625,
          "pr_ppl": 1.9609375,
          "source_ast_ppl": 3.109375,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": -0.0546875
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit excessive nesting and complex control flow, but Candidate A demonstrates a clearer attempt at using a `switch` statement for case handling, suggesting a higher level of abstraction compared to Candidate B's reliance on numerous `goto` statements and nested `if-else` blocks.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op ;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 2.796875,
          "pr_ast_ppl": 2.875,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit excessive nesting and complex control flow, heavily reliant on `goto` statements. Candidate A, however, demonstrates a slightly more structured approach with a `do-while` loop, hinting at a potential attempt to represent iteration. Candidate B's reliance on nested `if-else` blocks and `goto`s within the `switch` statement suggests a less idiomatic and more decompiler-generated structure.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid, type*id){\n  type id = id;\n  type ;\n  type *id = id;\n  type *id = id op id;\n  type *id = id;\n  type id;\n  type id = num;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = num;\n    type ;\n    type ;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > num){\n        id = (type)id[id] op num;\n      }\n    }else{\n      id = (id op (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op id op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id op ((id op id) op num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id)))id = id op num;else{\n            id = (type)(id op id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > num){\n        type *id = id;\n        type *id = id op (id op num) op num;\n        type ;\n        while(num){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id op (((id op id) op num) op ~num);\n          if(((*(id))) < (*(id)))id = id op num;elseif(((*(id))) > (*(id op num)))id = id op num;else{\n            id = (type)((id op id) op num);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != num){\n      id = (id op (id[id]));\n      id = (type)(*(id));\n      id = num;\n      while(id > num){\n        switch((*(id))){\n          case num:\n            {\n              {\n                id = num op id op ((((*(id)))) op );\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = num;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id = (((*(id)))) op ;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case num:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = num;\n        id = num;\n      }\n    }\n    if(id == id){\n      if(id >= num)goto lbl;\n    }else{\n      if(id != num){\n        id = num;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  num;\n  id != id\n  {\n    if(id){\n      call(id, (id), , (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type*id, typeid, type*id, type*id, typeid){\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  id = id op id;\n  id = num;\n  id = num;\n  id = num;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != num){\n        id = call((type)(type)id[id] op num);\n      }\n    }else{\n      id = (type)id;\n      id = id op (type)id[id];\n      id = (type)(type)id[id];\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op ((type)id op num);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id op (type)id op num;\n              id = id op id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id op (type)id) op id);\n                goto lbl;\n              }\n              id = id op num;\n              if(id < id)goto lbl;\n            }\n            id = id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = id op id;\n        id = id op id;\n      }\n      id = (type)id;\n      if((num op (id op num) op num) != num){\n        id = (type)(type)id[id];\n        id = id op (type)id op num op num;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id op (type)id op num op num*id < (type)id[id]){\n              id = id op (id op num);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id op num]){\n              id = call(call(id op (id op (type)id)) op num);\n              break;\n            }\n            id = id op id op num;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id op id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((num op (id op num) op num) == num){\n      id = id[id];\n      id = id[id];\n      if(id != ){\n        id = num;\n        do{\n          switch(*(type)((type)id op num op id)){\n            case num:\n              id = (type)*id op id op num op num;\n              break;\n            case num:\n              id = num;\n              break;\n            case num:\n              id = *id op num;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              id[num] = id;\n              break;\n            case num:\n              *id = id;\n          }\n          id = id op num;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id op num(num op (id op num) op num) == num)){\n      if(((id != id) || (id = num(num op (id op num) op num) != num)) && (id = numid != (type)num)){\n        call(id, num, , id op num, id op num, id);\n        call(id, id);\n        id = num;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 2.796875,
          "pr_ast_ppl": 2.875,
          "delta_ppl": 0.015625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit complex control flow, heavily reliant on nested blocks and numerous conditional statements. However, Candidate A demonstrates a more structured approach with a clear `do-while` loop, suggesting a higher-level abstraction. Candidate B, on the other hand, relies heavily on nested `if-else` blocks and `goto` statements, indicating a more fragmented and potentially less idiomatic design.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id){\n  type *id = ;\n  type id, id;\n  type ;\n  type ;\n  type id, id, id = num;\n  type id = id->id op id;\n  type id = id->id;\n  type *id = call(id op id->id);\n  type id = id->id;\n  type id = num;\n  type id;\n  if((id->id op id) == num)return num;\n  for(id = num;  id < id; id upd){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < num){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == num;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, num, (id));\n      id.id = id;\n      id = call(id, &id, &id) != num;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id op id), id, &id, &id);\n    call(id, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, num, , id, id, id);\n        if(id == num)goto lbl;\n        id = num;\n        if((id->id op id) != num)goto lbl;\n        if(id != id && id != num)goto lbl;\n        if((call(id, (id ?  : ))) == num)goto lbl;\n        if((id = call(id)) == )goto lbl;\n        if(call(id, num, , , id, id) == num){\n          if(call(id, id) != )call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != ){\n          if(call(id, , id) == num){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, ) == num)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = num;\n        break;\n    }\n  }\n  lbl:\n  call(, id);\n  if(id && id.id != id)(type)call(id, &id, );\n  call(id);\n  id->id = id;\n  call(, id);\n  return id;\n}",
        "base_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < num){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "pr_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(num < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.546875,
          "base_ppl": 2.5,
          "pr_ppl": 2.5,
          "source_ast_ppl": 4.15625,
          "base_ast_ppl": 2.796875,
          "pr_ast_ppl": 2.78125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit excessive nesting and rely heavily on `goto` statements, indicating a decompiler struggling to reconstruct natural control flow. However, Candidate A demonstrates a slight improvement by attempting to encapsulate some logic within a `do-while` loop, hinting at a higher-level abstraction.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id){\n  type *id = ;\n  type id, id;\n  type ;\n  type ;\n  type id, id, id = num;\n  type id = id->id op id;\n  type id = id->id;\n  type *id = call(id op id->id);\n  type id = id->id;\n  type id = num;\n  type id;\n  if((id->id op id) == num)return num;\n  for(id = num;  id < id; id upd){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < num){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == num;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, num, (id));\n      id.id = id;\n      id = call(id, &id, &id) != num;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id op id), id, &id, &id);\n    call(id, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, num, , id, id, id);\n        if(id == num)goto lbl;\n        id = num;\n        if((id->id op id) != num)goto lbl;\n        if(id != id && id != num)goto lbl;\n        if((call(id, (id ?  : ))) == num)goto lbl;\n        if((id = call(id)) == )goto lbl;\n        if(call(id, num, , , id, id) == num){\n          if(call(id, id) != )call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != ){\n          if(call(id, , id) == num){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, ) == num)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = num;\n        break;\n    }\n  }\n  lbl:\n  call(, id);\n  if(id && id.id != id)(type)call(id, &id, );\n  call(id);\n  id->id = id;\n  call(, id);\n  return id;\n}",
        "base_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < num){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "pr_ast": "type id(id, type*id, typeid){\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  id = (type)num;\n  id = num;\n  if((*(type)(id op num) op num) != num){\n    id = *(type)(id op num) op num;\n    id = *id;\n    id = *(type)(id op num);\n    id = *(type)(id op num);\n    id = ;\n    if(id == num){\n      id = ;\n    }\n    id = (type)&id;\n    id = bool;\n    id = num;\n    id = num;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(num < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id op num < num){\n          id = call(id);\n          if(id != num){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, num, num);\n              id = (type)num;\n              id = call(num, (type)&id, (type)id);\n              id = id != num;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id op num), id, *(type)(id op num) op num, id, &id, &id);\n            if(id != num){\n              if(id == num)goto lbl;\n              if(id != num)goto lbl;\n            }\n            *(type)(id op num) = *(type)(id op num) op num;\n            if(id == num){\n              id = call(id, id, id);\n            }else{\n              id = call(id, num, num, id, id, id);\n            }\n            if(id != num){\n              id = num;\n              if(((*(type)(id op num) op num) != num) || ((id != num && (id != num))))break;\n              id = call(id, id);\n              if((id != num) && (id = call(id)id != num)){\n                id = call(id, num, num, num, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == num){\n                  if(id != (type)num){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)num){\n                    id = id;\n                    id = call(id, , id);\n                    call(id);\n                    if(id == num)goto lbl;\n                  }\n                  id = num;\n                  if((id != num) || (id = call(id, &id)id != num))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = num;\n          }\n        }else{\n          id = call(id, *(type)(id op num), (type)id);\n          if(id == num)goto lbl;\n        }\n      }\n      lbl:\n      id = id op num;\n      id = id op num;\n    }while(id != num);\n    if((id) && (id[num].id != (type)num)){\n      call(num, (type)id, (type)num);\n    }\n    call(id);\n    *(type)(id op num) = *(type)(id op num) op num;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.546875,
          "base_ppl": 2.5,
          "pr_ppl": 2.5,
          "source_ast_ppl": 4.15625,
          "base_ast_ppl": 2.796875,
          "pr_ast_ppl": 2.78125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit excessive nesting and rely heavily on goto statements, indicating a decompiler struggling to reconstruct idiomatic patterns. Candidate A, however, demonstrates a slightly more structured approach with a `do-while` loop, suggesting a higher level of abstraction compared to the more fragmented control flow in Candidate B.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "type id(type*id, type*id, type*id){\n  type id = num;\n  type id = id;\n  type *id = id->id;\n  type *id = call(num, (id));\n  type *id = call(num, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > num)id->id = id->id;\n  if(call(id, id->id) == num){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(num, id, id->id)) == num){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), );\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(num, id, id->id) == num){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), );\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() op id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? num : num);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == ){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == ){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != num){\n    type id = call(id->id, id->id);\n    if(id == (id) op num){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == num){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, num)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), , id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), , call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type*id, typeid, typeid){\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = num;\n  id = *(type)((type)id op num);\n  id = id;\n  id = id;\n  id = id;\n  id = call(num, num);\n  id = call(num, num);\n  call(id, id, num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = id;\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = (type)*(type)((type)id op num);\n  if(num < *(type)((type)id op num)){\n    *(type)((type)id op num) = (type)*(type)((type)id op num);\n  }\n  id = call(id, id[num]);\n  if(id == num){\n    id = num;\n  }else{\n    id = call(num, num, id[num]);\n    *(type)((type)id op num) = id;\n    if(id == num){\n      id = num;\n      if(*(type)((type)id op num) != num){\n        call((type)((type)id op num), num, );\n        call((type)id op num, *(type)((type)id op num));\n      }\n    }else{\n      id = call(num, num, id[num]);\n      if(id == num){\n        id = num;\n        if(*(type)((type)id op num) != num){\n          call((type)((type)id op num), num, );\n          call((type)id op num, *(type)((type)id op num));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id op num), id);\n        if(id == num){\n          *(type)((type)id op num) = id[num];\n          *(type)((type)id op num) = *id;\n          *(type)((type)id op num) = id[num];\n          id = call();\n          *(type)((type)id op num) = id op *id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          id = num;\n          if(*(type)((type)id op num) != num){\n            id = num;\n          }\n          *(type)((type)id op num) = (type)id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = id[num];\n          if(*(type)((type)id op num) == num){\n            *(type)((type)id op num) = *(type)(id op num);\n          }\n          id = call(*(type)((type)id op num));\n          *(type)((type)id op num) = id;\n          if(id == num){\n            id = num;\n          }else{\n            if(((*(type)((type)id op num) != num) && (*(type)((type)id op num) != num)) && (id = call(*(type)((type)id op num), *(type)((type)id op num))id != num)){\n              id = call(*(type)((type)id op num), *(type)((type)id op num));\n              if(id == (type)num){\n                id = num;\n                goto lbl;\n              }\n              *(type)((type)id op num) = id;\n            }\n            id = call((type)id op num, num, id op num, num, *(type)((type)id op num));\n            if(((id == num) && (id = call(id, &id)id == num)) && (id = call(id, id)id == num)){\n              id = call(*(type)((type)id op num), num, id[num]);\n              if(id == num){\n                id = num;\n                if(*(type)((type)id op num) != num){\n                  call((type)((type)id op num), num, , *(type)((type)id op num));\n                  call((type)id op num, *(type)((type)id op num));\n                }\n              }else{\n                id = call(id);\n                if((id == num) && (id = call(id, num)id == num)){\n                  if((*(type)((type)id op num) == num) || (*(type)((type)id op num) == *(type)((type)id op num))){\n                    id = call(id);\n                  }else{\n                    id = num;\n                    if(*(type)((type)id op num) != num){\n                      call((type)((type)id op num), num, , (id) op (type)((type)id op num), (id) op (type)((type)id op num));\n                      call((type)id op num, *(type)((type)id op num));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[num]);\n  if((((id == num) || (id == num)) || (id == num)) && (*(type)((type)id op num) != num)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id op num), num, , id, (type)id, id, *id);\n    call((type)id op num, id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type*id, typeid, typeid){\n  type ;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  type id;\n  type id;\n  type id;\n  type id;\n  type ;\n  id = num;\n  id = *(type)((type)id op num);\n  id = id;\n  id = id;\n  id = id;\n  id = call(num, num);\n  id = (type)call(num, num);\n  call(id, id, num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = id;\n  *(type)((type)id op num) = *(type)((type)id op num);\n  *(type)((type)id op num) = (type)*(type)((type)id op num);\n  if(num < *(type)((type)id op num)){\n    *(type)((type)id op num) = (type)*(type)((type)id op num);\n  }\n  id = call(id, id[num]);\n  if(id == num){\n    id = num;\n  }else{\n    id = call(num, num, id[num]);\n    *(type)((type)id op num) = id;\n    if(id == num){\n      id = num;\n      if(*(type)((type)id op num) != num){\n        call((type)((type)id op num), num, );\n        call((type)id op num, *(type)((type)id op num));\n      }\n    }else{\n      id = call(num, num, id[num]);\n      if(id == num){\n        id = num;\n        if(*(type)((type)id op num) != num){\n          call((type)((type)id op num), num, );\n          call((type)id op num, *(type)((type)id op num));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id op num), id);\n        if(id == num){\n          *(type)((type)id op num) = id[num];\n          *(type)((type)id op num) = *id;\n          *(type)((type)id op num) = id[num];\n          id = call();\n          *(type)((type)id op num) = id op *id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          id = num;\n          if(*(type)((type)id op num) != num){\n            id = num;\n          }\n          *(type)((type)id op num) = (type)id;\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = *(type)(id op num);\n          *(type)((type)id op num) = id[num];\n          if(*(type)((type)id op num) == num){\n            *(type)((type)id op num) = *(type)(id op num);\n          }\n          id = call(*(type)((type)id op num));\n          *(type)((type)id op num) = id;\n          if(id == num){\n            id = num;\n          }else{\n            if(((*(type)((type)id op num) != num) && (*(type)((type)id op num) != num)) && (id = call(*(type)((type)id op num), *(type)((type)id op num))id != num)){\n              id = call(*(type)((type)id op num), *(type)((type)id op num));\n              if(id == (type)num){\n                id = num;\n                goto lbl;\n              }\n              *(type)((type)id op num) = id;\n            }\n            id = call((type)id op num, num, id op num, num, *(type)((type)id op num));\n            if(((id == num) && (id = call(id, &id)id == num)) && (id = call(id, id)id == num)){\n              id = call(*(type)((type)id op num), num, id[num]);\n              if(id == num){\n                id = num;\n                if(*(type)((type)id op num) != num){\n                  call((type)((type)id op num), num, , *(type)((type)id op num));\n                  call((type)id op num, *(type)((type)id op num));\n                }\n              }else{\n                id = call(id);\n                if((id == num) && (id = call(id, num)id == num)){\n                  if((*(type)((type)id op num) == num) || (*(type)((type)id op num) == *(type)((type)id op num))){\n                    id = call(id);\n                  }else{\n                    id = num;\n                    if(*(type)((type)id op num) != num){\n                      call((type)((type)id op num), num, , (id) op (type)((type)id op num), (id) op (type)((type)id op num));\n                      call((type)id op num, *(type)((type)id op num));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[num]);\n  if((((id == num) || (id == num)) || (id == num)) && (*(type)((type)id op num) != num)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id op num), num, , id, (type)id, id, *id);\n    call((type)id op num, id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  if(id != (type)num){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.0,
          "base_ppl": 1.8203125,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 1.953125,
          "pr_ast_ppl": 1.9453125,
          "delta_ppl": 0.0
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O2.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      param_3 = __src;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      param_3 = __src + sVar2;\n      if (pbVar3 < param_3) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    param_3 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    if (pbVar3 <= param_3) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    pbVar7 = __src;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = __src + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    pbVar7 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid){\n  type *id = (type)id;\n  type *id = id;\n  type id = num;\n  type *id = (type)id;\n  while(id < (type)id op id){\n    type id = *id upd;\n    type id = (id op num) op num;\n    type id = (id op num);\n    type id = num;\n    type id = num;\n    type id = ;\n    if(id op id[id] > (type)id op id){\n      return num;\n    }\n    switch(id){\n      case id:\n        id = (*id upd) op num op id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = *id upd;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = *id upd;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id op id > (type)id op id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    if(num < id){\n      lbl:\n      id = id;\n      id = id;\n      goto lbl;\n    }\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    id = id;\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    id = id;\n    id = id;\n    if(num < id)goto lbl;\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    id = id;\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.671875,
          "base_ppl": 1.7578125,
          "pr_ppl": 1.71875,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": -0.0390625
        },
        "llm_ast": {
          "motivation": "Both candidates exhibit excessive nesting and rely heavily on goto statements, indicating a decompiler struggle to reconstruct idiomatic patterns. However, Candidate A demonstrates a slightly better attempt at representing the logic with a `do-while` loop and a `switch` statement, albeit with nested `if` conditions within the `switch`.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O3.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type*id, typeid, type*id, typeid){\n  type *id = (type)id;\n  type *id = id;\n  type id = num;\n  type *id = (type)id;\n  while(id < (type)id op id){\n    type id = *id upd;\n    type id = (id op num) op num;\n    type id = (id op num);\n    type id = num;\n    type id = num;\n    type id = ;\n    if(id op id[id] > (type)id op id){\n      return num;\n    }\n    switch(id){\n      case id:\n        id = (*id upd) op num op id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = *id upd;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = (*id upd) op num op id op num;\n        id = ;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = id op num;\n        break;\n      case id:\n        id = *id upd;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case id:\n        id = ;\n        id = id op num;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id op id > (type)id op id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id op id > id){\n        return num;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    if(num < id){\n      lbl:\n      id = id;\n      goto lbl;\n    }\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(id, typeid, type*id, id){\n  type id;\n  type id;\n  type ;\n  type id;\n  type id;\n  type id;\n  type ;\n  if(id < num){\n    return num;\n  }\n  id = id op id;\n  id = num;\n  do{\n    id = id op num;\n    id = *id op num;\n    if(id < id op *(type)(id op (type)(type)id op num)){\n      return num;\n    }\n    id = id;\n    if(num < id)goto lbl;\n    id = *id op num;\n    switch((type)id){\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        lbl:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        goto lbl;\n      case num:\n        id = (type)id[num] op call(id op num) op num;\n        id = id[num];\n        id = id op num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        id = (type)id[num] op call(id op num) op num;\n        id = num;\n        break;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        goto lbl;\n      case num:\n        id = id op num;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        id = id op id;\n        if(id < id){\n          return num;\n        }\n        if(id != num){\n          call((type)(id op id), id, id);\n        }\n        goto lbl;\n      case num:\n        id = id[num];\n        id = id op num;\n        id = (type)(id op num);\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n        break;\n      case num:\n        id = (type)(id op num);\n        id = num;\n    }\n    id = id op id;\n    if(id < id){\n      return num;\n    }\n    if(id != num){\n      call((type)(id op id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.671875,
          "base_ppl": 1.7421875,
          "pr_ppl": 1.7109375,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.171875,
          "delta_ppl": -0.03125
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      }
    ]
  }
}