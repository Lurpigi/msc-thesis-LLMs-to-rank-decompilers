{
  "pr": "6722",
  "mean_delta_perplexity": -0.0140625,
  "mean_perplexity_base": 1.921875,
  "mean_perplexity_pr": 1.9078125,
  "mean_perplexity_source": 2.0790625,
  "mean_perplexity_base_ast": 2.1921875,
  "mean_perplexity_pr_ast": 2.1871875,
  "mean_perplexity_source_ast": 2.266875,
  "results": {
    "qwen-coder": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 2.0,
          "pr_ppl": 2.0,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.1875,
          "pr_ast_ppl": 2.1875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its use of meaningful variable names, structured control flow, and clear separation of concerns, which makes the code easier to understand and maintain compared to Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates have similar structures, but Candidate A uses explicit loop constructs (if, else, while), which align more closely with the source's control flow.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 2.0,
          "pr_ppl": 2.0,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.1875,
          "pr_ast_ppl": 2.1875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and follows a cleaner, more structured approach with clear variable names and a consistent coding style. The use of structs and enums makes the code easier to understand and maintain compared to Candidate A's raw pointers and bitwise operations.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A correctly recovers the for-loop structure present in the source code, whereas Candidate B uses a while-loop and goto statements, which adds unnecessary complexity.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch(*(undefined *)(param_2 + 3)) {\n    case 1:\n      local_28 = (long)(char)param_3;\n      break;\n    case 2:\n    case 7:\n    case 10:\n      local_28 = (long)(short)param_3;\n      break;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x29:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      local_28 = (long)(int)param_3;\n      break;\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",*(undefined *)(param_2 + 3));\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 1.8046875,
          "source_ast_ppl": 1.8984375,
          "base_ast_ppl": 1.8046875,
          "pr_ast_ppl": 1.8046875,
          "delta_ppl": -0.3671875
        },
        "llm_qualitative": {
          "motivation": "Candidate A maintains the original variable names and follows idiomatic C programming conventions, making it more human-readable despite minor discrepancies in some character comparisons.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar3 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(local_18 + 1));\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = *(byte *)local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(local_28 + 5));\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(local_28 + 6));\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar3) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)*(byte *)local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              bVar1 = *(byte *)local_28;\n              bVar2 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)bVar1 + (uint)bVar2 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)*(byte *)local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)*(byte *)(local_78 + 1));\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(local_28 + 1));\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)*(byte *)local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 !=\n                       0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)*(byte *)(local_28 + 1) +\n                       (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar3 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            \n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), , , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  \n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 1.96875,
          "pr_ppl": 1.9609375,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.3125,
          "pr_ast_ppl": 2.34375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more modern C syntax with structures and enums, which makes it easier to understand and maintain compared to the raw pointers and bit manipulation in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates have similar structures but Candidate A contains a ForLoop where the source code also uses a ForLoop. Since the loop type matches, we now compare the nesting depth. Candidate A has fewer unnecessary nested blocks compared to Candidate B.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.703125,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach, using variables and functions that make the code easier to understand and maintain. It also separates concerns into smaller blocks, which improves readability.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.703125,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear function definitions, use of variables, and proper control flow, making it more human-readable compared to the unstructured and repetitive nature of Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.9375,
          "pr_ppl": 1.9296875,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more readable due to its use of standard loop constructs and clear logical structure, which makes it easier for a human developer to understand and maintain compared to the highly obfuscated and nested control flow of Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.9453125,
          "pr_ppl": 1.9453125,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear function boundaries, named variables, and a consistent use of standard control constructs, making it more readable and easier to understand compared to the spaghetti code in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.71875,
          "pr_ppl": 1.7109375,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.453125,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its use of structured control flow and clear function definitions, which makes the logic easier to understand and follow compared to the nested and repetitive structure in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.734375,
          "pr_ppl": 1.734375,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.921875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its cleaner structure and use of meaningful variable names, which makes the logic easier to follow.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses meaningful variable names and follows a structured approach, making it more human-readable compared to the disorganized and repetitive nature of Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with meaningful variable names and clear control flow, making it easier for humans to understand and maintain compared to Candidate A's more convoluted syntax.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 3.359375,
          "pr_ast_ppl": 3.359375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear variable names and a logical flow, making it easier for a human developer to understand and maintain compared to the highly obfuscated and repetitive nature of Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 3.359375,
          "pr_ast_ppl": 3.359375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its structured approach using meaningful variable names and clear logical flow, which makes it easier for humans to understand compared to the more cryptic and less structured Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_zsav_read_compressed_data-O0.so",
        "function": "zsav_read_compressed_data",
        "source_code": "readstat_error_t zsav_read_compressed_data(sav_ctx_t *ctx,\n        readstat_error_t (*row_handler)(unsigned char *, size_t, sav_ctx_t *)) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = ctx->io;\n    readstat_off_t data_offset = 0;\n\n    size_t uncompressed_row_len = ctx->var_offset * 8;\n    readstat_off_t uncompressed_offset = 0;\n    unsigned char *uncompressed_row = NULL;\n\n    uLongf uncompressed_block_len = 0;\n    unsigned char *compressed_block = NULL, *uncompressed_block = NULL;\n\n    struct sav_row_stream_s state = { \n        .missing_value = ctx->missing_double,\n        .bias = ctx->bias,\n        .bswap = ctx->bswap };\n\n    struct zheader zheader;\n    struct ztrailer ztrailer;\n    struct ztrailer_entry *ztrailer_entries = NULL;\n\n    int n_blocks = 0;\n    int block_i = 0;\n    int i;\n\n    if (io->read(&zheader, sizeof(struct zheader), io->io_ctx) < sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    zheader.zheader_ofs = ctx->bswap ? byteswap8(zheader.zheader_ofs) : zheader.zheader_ofs;\n    zheader.ztrailer_ofs = ctx->bswap ? byteswap8(zheader.ztrailer_ofs) : zheader.ztrailer_ofs;\n    zheader.ztrailer_len = ctx->bswap ? byteswap8(zheader.ztrailer_len) : zheader.ztrailer_len;\n\n    if (zheader.zheader_ofs != io->seek(0, READSTAT_SEEK_CUR, io->io_ctx) - sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    n_blocks = (zheader.ztrailer_len - 24) / 24;\n\n    if (io->seek(zheader.ztrailer_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->read(&ztrailer, sizeof(struct ztrailer), io->io_ctx) < sizeof(struct ztrailer)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ztrailer.bias = ctx->bswap ? byteswap8(ztrailer.bias) : ztrailer.bias;\n    ztrailer.zero = ctx->bswap ? byteswap8(ztrailer.zero) : ztrailer.zero;\n    ztrailer.block_size = ctx->bswap ? byteswap4(ztrailer.block_size) : ztrailer.block_size;\n    ztrailer.n_blocks = ctx->bswap ? byteswap4(ztrailer.n_blocks) : ztrailer.n_blocks;\n\n    if (n_blocks != ztrailer.n_blocks) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    if (n_blocks && (ztrailer_entries = readstat_malloc(n_blocks * sizeof(struct ztrailer_entry))) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (io->read(ztrailer_entries, n_blocks * sizeof(struct ztrailer_entry), io->io_ctx) < \n            n_blocks * sizeof(struct ztrailer_entry)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    for (i=0; i<n_blocks; i++) {\n        struct ztrailer_entry *entry = &ztrailer_entries[i];\n\n        entry->uncompressed_ofs = ctx->bswap ? byteswap8(entry->uncompressed_ofs) : entry->uncompressed_ofs;\n        entry->compressed_ofs = ctx->bswap ? byteswap8(entry->compressed_ofs) : entry->compressed_ofs;\n        entry->uncompressed_size = ctx->bswap ? byteswap4(entry->uncompressed_size) : entry->uncompressed_size;\n        entry->compressed_size = ctx->bswap ? byteswap4(entry->compressed_size) : entry->compressed_size;\n    }\n\n    if (uncompressed_row_len && (uncompressed_row = readstat_malloc(uncompressed_row_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    while (1) {\n        if (block_i == n_blocks)\n            goto cleanup;\n\n        struct ztrailer_entry *entry = &ztrailer_entries[block_i];\n        if (io->seek(entry->compressed_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n            retval = READSTAT_ERROR_SEEK;\n            goto cleanup;\n        }\n        if ((compressed_block = readstat_realloc(compressed_block, entry->compressed_size)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if (io->read(compressed_block, entry->compressed_size, io->io_ctx) != entry->compressed_size) {\n            retval = READSTAT_ERROR_READ;\n            goto cleanup;\n        }\n\n        uncompressed_block_len = entry->uncompressed_size;\n        if ((uncompressed_block = readstat_realloc(uncompressed_block, uncompressed_block_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        int status = uncompress(uncompressed_block, &uncompressed_block_len,\n                compressed_block, entry->compressed_size);\n        if (status != Z_OK || uncompressed_block_len != entry->uncompressed_size) {\n            retval = READSTAT_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        block_i++;\n        state.status = SAV_ROW_STREAM_HAVE_DATA;\n        data_offset = 0;\n\n        while (state.status != SAV_ROW_STREAM_NEED_DATA) {\n            state.next_in = &uncompressed_block[data_offset];\n            state.avail_in = uncompressed_block_len - data_offset;\n\n            state.next_out = &uncompressed_row[uncompressed_offset];\n            state.avail_out = uncompressed_row_len - uncompressed_offset;\n\n            sav_decompress_row(&state);\n\n            uncompressed_offset = uncompressed_row_len - state.avail_out;\n            data_offset = uncompressed_block_len - state.avail_in;\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ROW) {\n                retval = row_handler(uncompressed_row, uncompressed_row_len, ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                uncompressed_offset = 0;\n            }\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ALL)\n                goto cleanup;\n            if (ctx->row_limit > 0 && ctx->current_row == ctx->row_limit)\n                goto cleanup;\n        }\n    }\n\ncleanup:\n    if (uncompressed_row)\n        free(uncompressed_row);\n    if (ztrailer_entries)\n        free(ztrailer_entries);\n    if (compressed_block)\n        free(compressed_block);\n    if (uncompressed_block)\n        free(uncompressed_block);\n\n    return retval;\n}\n",
        "function_base": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined1 auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined1 auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "function_pr": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(){\n    \n    goto label\n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  for(;;){\n    \n    (? call(): )\n    (? call(): )\n    (? call(): )\n    (? call(): )\n  }\n  if(call()){\n    \n    goto label\n  }\n  while(){\n    if()goto label\n    \n    if(call(, , )){\n      \n      goto label\n    }\n    if(call(, )){\n      \n      goto label\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    \n    if(call(, )){\n      \n      goto label\n    }\n    call(, , , )\n    if(){\n      \n      goto label\n    }\n    \n    \n    \n    while(){\n      \n      \n      \n      \n      call()\n      \n      \n      if(){\n        call(, , )\n        if()goto label\n        \n      }\n      if()goto label\n      if()goto label\n    }\n  }\n  if()call()\n  if()call()\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 1.53125,
          "pr_ppl": 1.53125,
          "source_ast_ppl": 2.6875,
          "base_ast_ppl": 2.234375,
          "pr_ast_ppl": 2.234375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear variable names, logical control flow, and adherence to common coding practices. While Candidate A maintains the same functionality as the ground truth, its lack of readability makes it less suitable for maintenance and understanding.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.890625,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 3.015625,
          "pr_ast_ppl": 3.015625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its use of named variables, structured loops, and clear control flow, which makes it easier to understand and maintain compared to Candidate A's more verbose and less organized code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    do{\n      \n      \n      switch(){\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          \n          \n          \n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          goto label\n        case :\n          \n        case :\n          \n          \n          \n          if(){\n            return\n          }\n      }\n      if(){\n        return\n      }\n      \n      \n      \n      \n      \n    }while()\n    if(){\n      \n      \n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 6.46875,
          "base_ast_ppl": 3.03125,
          "pr_ast_ppl": 2.9375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    do{\n      \n      \n      switch(){\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          \n          \n          \n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          goto label\n        case :\n          \n        case :\n          \n          \n          \n          if(){\n            return\n          }\n      }\n      if(){\n        return\n      }\n      \n      \n      \n      \n      \n    }while()\n    if(){\n      \n      \n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 6.46875,
          "base_ast_ppl": 3.03125,
          "pr_ast_ppl": 2.9375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.03125,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear variable names and logical control flow, making it easier to understand compared to the disorganized structure of Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O0.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined1 local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined1 local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined1 local_208 [60];\n  undefined1 auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined local_208 [60];\n  undefined auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            \n                            \n                            goto label\n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            \n                            \n                            goto label\n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 1.8828125,
          "pr_ppl": 1.8828125,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.421875,
          "pr_ast_ppl": 2.421875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear function definitions, variable names, and logical flow, making it more readable and easier to understand compared to the raw assembly-like structure of Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_ctx_init-O0.so",
        "function": "dta_ctx_init",
        "source_code": "readstat_error_t dta_ctx_init(dta_ctx_t *ctx, uint32_t nvar, uint64_t nobs,\n        unsigned char byteorder, unsigned char ds_format,\n        const char *input_encoding, const char *output_encoding) {\n    readstat_error_t retval = READSTAT_OK;\n    int machine_byteorder = DTA_HILO;\n    if (ds_format < DTA_MIN_VERSION || ds_format > DTA_MAX_VERSION)\n        return READSTAT_ERROR_UNSUPPORTED_FILE_FORMAT_VERSION;\n\n    if (machine_is_little_endian()) {\n        machine_byteorder = DTA_LOHI;\n    }\n\n    ctx->bswap = (byteorder != machine_byteorder);\n    ctx->ds_format = ds_format;\n    ctx->endianness = byteorder == DTA_LOHI ? READSTAT_ENDIAN_LITTLE : READSTAT_ENDIAN_BIG;\n\n    ctx->nvar = nvar;\n    ctx->nobs = nobs;\n\n    if (ctx->nvar) {\n        if ((ctx->variables = readstat_calloc(ctx->nvar, sizeof(readstat_variable_t *))) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->machine_is_twos_complement = READSTAT_MACHINE_IS_TWOS_COMPLEMENT;\n\n    if (ds_format < 105) {\n        ctx->fmtlist_entry_len = 7;\n    } else if (ds_format < 114) {\n        ctx->fmtlist_entry_len = 12;\n    } else if (ds_format < 118) {\n        ctx->fmtlist_entry_len = 49;\n    } else {\n        ctx->fmtlist_entry_len = 57;\n    }\n    \n    if (ds_format >= 117) {\n        ctx->typlist_version = 117;\n    } else if (ds_format >= 111) {\n        ctx->typlist_version = 111;\n    } else {\n        ctx->typlist_version = 0;\n    }\n\n    if (ds_format >= 118) {\n        ctx->data_label_len_len = 2;\n        ctx->strl_v_len = 2;\n        ctx->strl_o_len = 6;\n    } else if (ds_format >= 117) {\n        ctx->data_label_len_len = 1;\n        ctx->strl_v_len = 4;\n        ctx->strl_o_len = 4;\n    }\n\n    if (ds_format < 105) {\n        ctx->expansion_len_len = 0;\n    } else if (ds_format < 110) {\n        ctx->expansion_len_len = 2;\n    } else {\n        ctx->expansion_len_len = 4;\n    }\n    \n    if (ds_format < 110) {\n        ctx->lbllist_entry_len = 9;\n        ctx->variable_name_len = 9;\n        ctx->ch_metadata_len = 9;\n    } else if (ds_format < 118) {\n        ctx->lbllist_entry_len = 33;\n        ctx->variable_name_len = 33;\n        ctx->ch_metadata_len = 33;\n    } else {\n        ctx->lbllist_entry_len = 129;\n        ctx->variable_name_len = 129;\n        ctx->ch_metadata_len = 129;\n    }\n\n    if (ds_format < 108) {\n        ctx->variable_labels_entry_len = 32;\n        ctx->data_label_len = 32;\n    } else if (ds_format < 118) {\n        ctx->variable_labels_entry_len = 81;\n        ctx->data_label_len = 81;\n    } else {\n        ctx->variable_labels_entry_len = 321;\n        ctx->data_label_len = 321;\n    }\n\n    if (ds_format < 105) {\n        ctx->timestamp_len = 0;\n        ctx->value_label_table_len_len = 2;\n        ctx->value_label_table_labname_len = 12;\n        ctx->value_label_table_padding_len = 2;\n    } else {\n        ctx->timestamp_len = 18;\n        ctx->value_label_table_len_len = 4;\n        if (ds_format < 118) {\n            ctx->value_label_table_labname_len = 33;\n        } else {\n            ctx->value_label_table_labname_len = 129;\n        }\n        ctx->value_label_table_padding_len = 3;\n    }\n\n    if (ds_format < 117) {\n        ctx->typlist_entry_len = 1;\n        ctx->file_is_xmlish = 0;\n    } else {\n        ctx->typlist_entry_len = 2;\n        ctx->file_is_xmlish = 1;\n    }\n\n    if (ds_format < 113) {\n        ctx->max_int8 = DTA_OLD_MAX_INT8;\n        ctx->max_int16 = DTA_OLD_MAX_INT16;\n        ctx->max_int32 = DTA_OLD_MAX_INT32;\n        ctx->max_float = DTA_OLD_MAX_FLOAT;\n        ctx->max_double = DTA_OLD_MAX_DOUBLE;\n    } else {\n        ctx->max_int8 = DTA_113_MAX_INT8;\n        ctx->max_int16 = DTA_113_MAX_INT16;\n        ctx->max_int32 = DTA_113_MAX_INT32;\n        ctx->max_float = DTA_113_MAX_FLOAT;\n        ctx->max_double = DTA_113_MAX_DOUBLE;\n\n        ctx->supports_tagged_missing = 1;\n    }\n\n    if (output_encoding) {\n        if (input_encoding) {\n            ctx->converter = iconv_open(output_encoding, input_encoding);\n        } else if (ds_format < 118) {\n            ctx->converter = iconv_open(output_encoding, \"WINDOWS-1252\");\n        } else if (strcmp(output_encoding, \"UTF-8\") != 0) {\n            ctx->converter = iconv_open(output_encoding, \"UTF-8\");\n        }\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n\n    if (ds_format < 119) {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int16_t);\n    } else {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int32_t);\n    }\n\n    if ((ctx->srtlist = readstat_malloc(ctx->srtlist_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->nvar > 0) {\n        ctx->typlist_len = ctx->nvar * sizeof(uint16_t);\n        ctx->varlist_len = ctx->variable_name_len * ctx->nvar * sizeof(char);\n        ctx->fmtlist_len = ctx->fmtlist_entry_len * ctx->nvar * sizeof(char);\n        ctx->lbllist_len = ctx->lbllist_entry_len * ctx->nvar * sizeof(char);\n        ctx->variable_labels_len = ctx->variable_labels_entry_len * ctx->nvar * sizeof(char);\n\n        if ((ctx->typlist = readstat_malloc(ctx->typlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->varlist = readstat_malloc(ctx->varlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->fmtlist = readstat_malloc(ctx->fmtlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->lbllist = readstat_malloc(ctx->lbllist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->variable_labels = readstat_malloc(ctx->variable_labels_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->initialized = 1;\n\ncleanup:\n    return retval;\n}\n",
        "function_base": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined1 *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined1 *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined1 *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "function_pr": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "source_ast": "{\n  \n  \n  if()return\n  if(call()){\n    \n  }\n  \n  \n  (? : )\n  \n  \n  if(){\n    if(call(, )){\n      \n      goto label\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      call(, )\n    }elseif(){\n      call(, )\n    }elseif(call(, )){\n      call(, )\n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(){\n    \n    \n    \n    \n    \n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "metrics": {
          "source_ppl": 1.8359375,
          "base_ppl": 1.4609375,
          "pr_ppl": 1.4609375,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.296875,
          "pr_ast_ppl": 2.296875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses meaningful variable names and follows a more structured approach, making it easier to understand and maintain compared to Candidate A's less readable code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O2.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined1 auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined1 local_608 [60];\n  undefined1 local_5cc [148];\n  undefined1 local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined local_608 [60];\n  undefined local_5cc [148];\n  undefined local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.125,
          "pr_ppl": 2.109375,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear function definitions, variable naming conventions, and a cleaner control flow. It adheres to idiomatic C practices, making it easier to understand and maintain compared to the unstructured and repetitive nature of Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O3.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined1 auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined1 local_608 [60];\n  undefined1 local_5cc [148];\n  undefined1 local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined local_608 [60];\n  undefined local_5cc [148];\n  undefined local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.125,
          "pr_ppl": 2.109375,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows standard loop structures, clear function names, and proper use of control flow, making it more human-readable compared to the nested goto statements in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O0.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  uint uVar3;\n  int iVar4;\n  long lVar5;\n  int *local_60;\n  int local_3c;\n  \n  if (param_4 <= *param_3) {\n    return 10;\n  }\n  uVar1 = *param_3;\n  do {\n    local_3c = 0;\n    if (param_4 <= *param_3) goto LAB_001016a7;\n    switch(*param_1) {\n    case 0:\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      *param_1 = 1;\n      break;\n    case 1:\n      local_3c = lzma_vli_decode(param_1 + 0x46,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) goto LAB_001016a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      iVar4 = 2;\n      if (*(long *)(param_1 + 0x46) == 0) {\n        iVar4 = 4;\n      }\n      *param_1 = iVar4;\n      break;\n    case 2:\n    case 3:\n      if (*param_1 == 2) {\n        local_60 = param_1 + 0x48;\n      }\n      else {\n        local_60 = param_1 + 0x4a;\n      }\n      local_3c = lzma_vli_decode(local_60,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) {\nLAB_001016a7:\n        if (*param_3 - uVar1 != 0) {\n          iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n          param_1[0x4e] = iVar4;\n        }\n        return local_3c;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        if ((*(ulong *)(param_1 + 0x48) < 5) || (0x7ffffffffffffffc < *(ulong *)(param_1 + 0x48))) {\n          return 9;\n        }\n        *param_1 = 3;\n      }\n      else {\n        hash_append(param_1 + 0x24,*(undefined8 *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (((*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) ||\n            (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26))) ||\n           (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lVar5 = *(long *)(param_1 + 0x46);\n        *(long *)(param_1 + 0x46) = lVar5 + -1;\n        iVar4 = 2;\n        if (lVar5 + -1 == 0) {\n          iVar4 = 4;\n        }\n        *param_1 = iVar4;\n      }\n      break;\n    case 4:\n      lVar5 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      *(ulong *)(param_1 + 0x4c) = 4U - lVar5 & 3;\n      *param_1 = 5;\n    case 5:\n      if (*(long *)(param_1 + 0x4c) == 0) {\n        if (((*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) ||\n            (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26))) ||\n           (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar3 = lzma_check_size(10);\n        iVar4 = memcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar3);\n        if (iVar4 != 0) {\n          return 9;\n        }\n        iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n        param_1[0x4e] = iVar4;\n        *param_1 = 6;\nswitchD_001011ee_caseD_6:\n        while( true ) {\n          if (*param_3 == param_4) {\n            return 0;\n          }\n          uVar3 = param_1[0x4e];\n          lVar5 = *(long *)(param_1 + 0x4c);\n          uVar1 = *param_3;\n          *param_3 = uVar1 + 1;\n          if ((uVar3 >> ((byte)(lVar5 << 3) & 0x1f) & 0xff) != (uint)*(byte *)(param_2 + uVar1))\n          break;\n          lVar5 = *(long *)(param_1 + 0x4c);\n          *(ulong *)(param_1 + 0x4c) = lVar5 + 1U;\n          if (3 < lVar5 + 1U) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *(long *)(param_1 + 0x4c) = *(long *)(param_1 + 0x4c) + -1;\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      break;\n    case 6:\n      goto switchD_001011ee_caseD_6;\n    default:\n      return 0xb;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  uint uVar3;\n  int iVar4;\n  long lVar5;\n  int *local_60;\n  int local_3c;\n  \n  if (param_4 <= *param_3) {\n    return 10;\n  }\n  uVar1 = *param_3;\n  do {\n    local_3c = 0;\n    if (param_4 <= *param_3) goto LAB_001016a7;\n    switch(*param_1) {\n    case 0:\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      *param_1 = 1;\n      break;\n    case 1:\n      local_3c = lzma_vli_decode(param_1 + 0x46,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) goto LAB_001016a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      iVar4 = 2;\n      if (*(long *)(param_1 + 0x46) == 0) {\n        iVar4 = 4;\n      }\n      *param_1 = iVar4;\n      break;\n    case 2:\n    case 3:\n      if (*param_1 == 2) {\n        local_60 = param_1 + 0x48;\n      }\n      else {\n        local_60 = param_1 + 0x4a;\n      }\n      local_3c = lzma_vli_decode(local_60,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) {\nLAB_001016a7:\n        if (*param_3 - uVar1 != 0) {\n          iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n          param_1[0x4e] = iVar4;\n        }\n        return local_3c;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        if ((*(ulong *)(param_1 + 0x48) < 5) || (0x7ffffffffffffffc < *(ulong *)(param_1 + 0x48))) {\n          return 9;\n        }\n        *param_1 = 3;\n      }\n      else {\n        hash_append(param_1 + 0x24,*(undefined8 *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (((*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) ||\n            (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26))) ||\n           (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lVar5 = *(long *)(param_1 + 0x46);\n        *(long *)(param_1 + 0x46) = lVar5 + -1;\n        iVar4 = 2;\n        if (lVar5 + -1 == 0) {\n          iVar4 = 4;\n        }\n        *param_1 = iVar4;\n      }\n      break;\n    case 4:\n      lVar5 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      *(ulong *)(param_1 + 0x4c) = 4U - lVar5 & 3;\n      *param_1 = 5;\n    case 5:\n      if (*(long *)(param_1 + 0x4c) == 0) {\n        if (((*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) ||\n            (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26))) ||\n           (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar3 = lzma_check_size(10);\n        iVar4 = memcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar3);\n        if (iVar4 != 0) {\n          return 9;\n        }\n        iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n        param_1[0x4e] = iVar4;\n        *param_1 = 6;\nLAB_001015f6:\n        while( true ) {\n          if (*param_3 == param_4) {\n            return 0;\n          }\n          uVar3 = param_1[0x4e];\n          lVar5 = *(long *)(param_1 + 0x4c);\n          uVar1 = *param_3;\n          *param_3 = uVar1 + 1;\n          if ((uVar3 >> ((byte)(lVar5 << 3) & 0x1f) & 0xff) != (uint)*(byte *)(param_2 + uVar1))\n          break;\n          lVar5 = *(long *)(param_1 + 0x4c);\n          *(ulong *)(param_1 + 0x4c) = lVar5 + 1U;\n          if (3 < lVar5 + 1U) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *(long *)(param_1 + 0x4c) = *(long *)(param_1 + 0x4c) + -1;\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      break;\n    case 6:\n      goto LAB_001015f6;\n    default:\n      return 0xb;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  if()return\n  \n  \n  \n  \n  \n  while()switch(){\n    case :\n      \n      if()return\n      \n      \n    case :\n      {\n        call(, , , , )\n        if()goto label\n        \n        if()return\n        \n        \n        \n        (? : )\n        \n      }\n    case :\n    case :\n      {\n        (? : )\n        call(, , , , )\n        if()goto label\n        \n        \n        if(){\n          if()return\n          \n        }else{\n          \n          call(, , )\n          \n          \n          \n          \n          \n          \n          if()return\n          \n          (? : )\n        }\n        \n      }\n    case :\n      call()call(, )\n      \n      \n    case :\n      if(){\n        \n        if()return\n        \n      }\n      \n      if()return\n      \n      call(, )\n      call(, )\n      if(call(, , call()))return\n      \n      call(, , )\n      \n      \n    case :\n      do{\n        if()return\n        if(){\n          return\n        }\n      }while()\n      return\n    case :\n      \n      call()\n      return\n  }\n  {\n    \n    if()call(, , )\n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  \n  do{\n    \n    if()goto label\n    switch(){\n      case :\n        \n        \n        if(){\n          return\n        }\n        \n        \n      case :\n        call(, , , , )\n        if()goto label\n        if(){\n          return\n        }\n        \n        \n        \n        if(){\n          \n        }\n        \n        \n      case :\n      case :\n        if(){\n          \n        }else{\n          \n        }\n        call(, , , , )\n        if(){\n          if(){\n            call(, , )\n            \n          }\n          return\n        }\n        \n        \n        if(){\n          if(){\n            return\n          }\n          \n        }else{\n          call(, , )\n          if(){\n            return\n          }\n          \n          \n          \n          if(){\n            \n          }\n          \n        }\n        \n      case :\n        call(, )\n        \n        \n      case :\n        if(){\n          if(){\n            return\n          }\n          call(, )\n          call(, )\n          call()\n          call(, , )\n          if(){\n            return\n          }\n          call(, , )\n          \n          \n          while(){\n            if(){\n              return\n            }\n            \n            \n            \n            \n            if(call())\n            \n            \n            if(){\n              return\n            }\n          }\n          return\n        }\n        \n        \n        \n        if(){\n          return\n        }\n        \n      case :\n        goto label\n      case :\n        \n        return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  \n  do{\n    \n    if()goto label\n    switch(){\n      case :\n        \n        \n        if(){\n          return\n        }\n        \n        \n      case :\n        call(, , , , )\n        if()goto label\n        if(){\n          return\n        }\n        \n        \n        \n        if(){\n          \n        }\n        \n        \n      case :\n      case :\n        if(){\n          \n        }else{\n          \n        }\n        call(, , , , )\n        if(){\n          if(){\n            call(, , )\n            \n          }\n          return\n        }\n        \n        \n        if(){\n          if(){\n            return\n          }\n          \n        }else{\n          call(, , )\n          if(){\n            return\n          }\n          \n          \n          \n          if(){\n            \n          }\n          \n        }\n        \n      case :\n        call(, )\n        \n        \n      case :\n        if(){\n          if(){\n            return\n          }\n          call(, )\n          call(, )\n          call()\n          call(, , )\n          if(){\n            return\n          }\n          call(, , )\n          \n          \n          while(){\n            if(){\n              return\n            }\n            \n            \n            \n            \n            if(call())\n            \n            \n            if(){\n              return\n            }\n          }\n          return\n        }\n        \n        \n        \n        if(){\n          return\n        }\n        \n      case :\n        goto label\n      case :\n        \n        return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 2.46875,
          "base_ppl": 1.8671875,
          "pr_ppl": 1.8515625,
          "source_ast_ppl": 4.875,
          "base_ast_ppl": 3.25,
          "pr_ast_ppl": 3.25,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its structured approach using standard loops and clear variable names, making it easier for a human developer to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_dta-O2.so",
        "function": "readstat_parse_dta",
        "source_code": "readstat_error_t readstat_parse_dta(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    int i;\n    dta_ctx_t    *ctx;\n    size_t file_size = 0;\n\n    ctx = dta_ctx_alloc(io);\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    char magic[4];\n    if (io->read(magic, 4, io->io_ctx) != 4) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx);\n    if (file_size == -1) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"Failed to seek to start of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (strncmp(magic, \"<sta\", 4) == 0) {\n        dta_header64_t header;\n        if ((retval = dta_read_xmlish_header(ctx, &header)) != READSTAT_OK) {\n            goto cleanup;\n        }\n        retval = dta_ctx_init(ctx, header.nvar, header.nobs, header.byteorder, header.ds_format,\n                parser->input_encoding, parser->output_encoding);\n    } else {\n        dta_header_t header;\n        if ((retval = dta_read_header(ctx, &header)) != READSTAT_OK) {\n            goto cleanup;\n        }\n        retval = dta_ctx_init(ctx, header.nvar, header.nobs, header.byteorder, header.ds_format,\n                parser->input_encoding, parser->output_encoding);\n    }\n    if (retval != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->user_ctx = user_ctx;\n    ctx->file_size = file_size;\n    ctx->handle = parser->handlers;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n    int64_t nobs_after_skipping = ctx->nobs - ctx->row_offset;\n    if (nobs_after_skipping < 0) {\n        nobs_after_skipping = 0;\n        ctx->row_offset = ctx->nobs;\n    }\n    ctx->row_limit = nobs_after_skipping;\n    if (parser->row_limit > 0 && parser->row_limit < nobs_after_skipping)\n        ctx->row_limit = parser->row_limit;\n\n    retval = dta_update_progress(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if ((retval = dta_read_label_and_timestamp(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_read_tag(ctx, \"</header>\")) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.metadata) {\n        readstat_metadata_t metadata = {\n            .row_count = ctx->row_limit,\n            .var_count = ctx->nvar,\n            .file_label = ctx->data_label,\n            .creation_time = ctx->timestamp,\n            .modified_time = ctx->timestamp,\n            .file_format_version = ctx->ds_format,\n            .is64bit = ctx->ds_format >= 118,\n            .endianness = ctx->endianness\n        };\n        if (ctx->handle.metadata(&metadata, user_ctx) != READSTAT_HANDLER_OK) {\n            retval = READSTAT_ERROR_USER_ABORT;\n            goto cleanup;\n        }\n    }\n\n    if ((retval = dta_read_map(ctx)) != READSTAT_OK) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    if ((retval = dta_read_descriptors(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    for (i=0; i<ctx->nvar; i++) {\n        size_t      max_len;\n        if ((retval = dta_type_info(ctx->typlist[i], ctx, &max_len, NULL)) != READSTAT_OK)\n            goto cleanup;\n\n        ctx->record_len += max_len;\n    }\n\n    if ((ctx->nvar > 0 || ctx->nobs > 0) && ctx->record_len == 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    if ((retval = dta_handle_variables(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_read_expansion_fields(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if (!ctx->file_is_xmlish) {\n        ctx->data_offset = io->seek(0, READSTAT_SEEK_CUR, io->io_ctx);\n        if (ctx->data_offset == -1) {\n            retval = READSTAT_ERROR_SEEK;\n            goto cleanup;\n        }\n        ctx->value_labels_offset = ctx->data_offset + ctx->record_len * ctx->nobs;\n    }\n\n    if ((retval = dta_read_strls(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_read_data(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_handle_value_labels(ctx)) != READSTAT_OK)\n        goto cleanup;\n\ncleanup:\n    io->close(io->io_ctx);\n    if (ctx)\n        dta_ctx_free(ctx);\n\n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_dta(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long lVar6;\n  code *pcVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  long lVar10;\n  uint uVar11;\n  int local_94;\n  undefined8 local_90;\n  ulong local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  long local_70;\n  undefined4 local_68;\n  undefined4 local_64;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined1 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar4 = (undefined8 *)dta_ctx_alloc(puVar1);\n  iVar2 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar2 == -1) {\n    iVar2 = 1;\n    goto LAB_0010154b;\n  }\n  lVar5 = (*(code *)puVar1[3])(&local_94,4,puVar1[5]);\n  iVar2 = 2;\n  if (lVar5 != 4) goto LAB_0010154b;\n  lVar5 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n  if (lVar5 == -1) {\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 0x1f2) = 0x656c696620666f;\n    uVar8 = 0x666f20646e65206f;\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    if (lVar6 != -1) {\n      if (local_94 == 0x6174733c) {\n        iVar2 = dta_read_xmlish_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88;\n        uVar11 = local_90._4_4_;\n      }\n      else {\n        iVar2 = dta_read_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88 & 0xffffffff;\n        uVar11 = (uint)local_90._4_2_;\n      }\n      iVar2 = dta_ctx_init(puVar4,uVar11,uVar9,local_90._1_1_,local_90 & 0xff,param_1[9],param_1[10]\n                          );\n      if (iVar2 != 0) goto LAB_0010154b;\n      puVar4[0x39] = param_3;\n      puVar4[0x38] = lVar5;\n      puVar4[0x37] = param_1[7];\n      puVar4[0x36] = param_1[6];\n      puVar4[0x35] = param_1[5];\n      puVar4[0x34] = param_1[4];\n      puVar4[0x33] = param_1[3];\n      puVar4[0x32] = param_1[2];\n      uVar8 = *param_1;\n      puVar4[0x31] = param_1[1];\n      puVar4[0x30] = uVar8;\n      lVar5 = param_1[0xc];\n      if (lVar5 < 1) {\n        lVar5 = puVar4[0x25];\n      }\n      else {\n        puVar4[0x25] = lVar5;\n      }\n      lVar5 = puVar4[0x22] - lVar5;\n      if (lVar5 < 0) {\n        puVar4[0x25] = puVar4[0x22];\n        lVar5 = 0;\n      }\n      lVar6 = param_1[0xb];\n      lVar10 = lVar5;\n      if (lVar6 < lVar5) {\n        lVar10 = lVar6;\n      }\n      if (lVar6 < 1) {\n        lVar10 = lVar5;\n      }\n      puVar4[0x24] = lVar10;\n      iVar2 = dta_update_progress(puVar4);\n      if (((iVar2 != 0) || (iVar2 = dta_read_label_and_timestamp(puVar4), iVar2 != 0)) ||\n         (iVar2 = dta_read_tag(puVar4,\"</header>\"), iVar2 != 0)) goto LAB_0010154b;\n      if ((code *)puVar4[0x30] != (code *)0x0) {\n        local_90 = puVar4[0x24];\n        local_88 = (ulong)*(int *)((long)puVar4 + 0x10c);\n        local_80 = puVar4[3];\n        local_70 = (long)*(int *)(puVar4 + 0x21);\n        local_68 = 0;\n        local_64 = *(undefined4 *)(puVar4 + 0x2e);\n        local_60 = 0;\n        local_58 = *puVar4;\n        local_50 = 0;\n        local_48 = 0x75 < local_70;\n        local_40 = 0;\n        local_38 = 0;\n        local_78 = local_80;\n        iVar3 = (*(code *)puVar4[0x30])(&local_90,param_3);\n        iVar2 = 4;\n        if (iVar3 != 0) goto LAB_0010154b;\n      }\n      iVar3 = dta_read_map(puVar4);\n      iVar2 = 2;\n      if ((iVar3 != 0) || (iVar2 = dta_read_descriptors(puVar4), iVar2 != 0)) goto LAB_0010154b;\n      if (*(int *)((long)puVar4 + 0x10c) < 1) {\nLAB_00101689:\n        if (0 < (long)puVar4[0x22]) goto LAB_00101693;\n      }\n      else {\n        lVar5 = 0;\n        do {\n          iVar2 = dta_type_info(*(undefined2 *)(puVar4[7] + lVar5 * 2),puVar4,&local_90,0);\n          if (iVar2 != 0) goto LAB_0010154b;\n          puVar4[0x23] = puVar4[0x23] + local_90;\n          lVar5 = lVar5 + 1;\n        } while (lVar5 < *(int *)((long)puVar4 + 0x10c));\n        if (*(int *)((long)puVar4 + 0x10c) < 1) goto LAB_00101689;\nLAB_00101693:\n        if (puVar4[0x23] == 0) {\n          iVar2 = 5;\n          goto LAB_0010154b;\n        }\n      }\n      iVar2 = dta_handle_variables(puVar4);\n      if ((iVar2 == 0) && (iVar2 = dta_read_expansion_fields(puVar4), iVar2 == 0)) {\n        if ((*(byte *)(puVar4 + 0x27) & 4) == 0) {\n          lVar5 = (*(code *)puVar1[2])(0,1,puVar1[5]);\n          puVar4[0x1e] = lVar5;\n          if (lVar5 == -1) {\n            iVar2 = 0xf;\n            goto LAB_0010154b;\n          }\n          puVar4[0x20] = puVar4[0x22] * puVar4[0x23] + lVar5;\n        }\n        iVar2 = dta_read_strls(puVar4);\n        if ((iVar2 == 0) && (iVar2 = dta_read_data(puVar4), iVar2 == 0)) {\n          iVar2 = dta_handle_value_labels(puVar4);\n        }\n      }\n      goto LAB_0010154b;\n    }\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 500) = 0x656c696620666f;\n    uVar8 = 0x207472617473206f;\n  }\n  iVar2 = 0xf;\n  *(undefined8 *)((long)puVar4 + 0x1ec) = uVar8;\n  *(undefined8 *)((long)puVar4 + 0x1e4) = 0x74206b656573206f;\n  *(undefined8 *)((long)puVar4 + 0x1dc) = 0x742064656c696146;\n  (*pcVar7)((long)puVar4 + 0x1dc,puVar4[0x39]);\nLAB_0010154b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if (puVar4 != (undefined8 *)0x0) {\n    dta_ctx_free(puVar4);\n  }\n  return iVar2;\n}\n\n",
        "function_pr": "\nint readstat_parse_dta(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long lVar6;\n  code *pcVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  long lVar10;\n  uint uVar11;\n  int local_94;\n  undefined8 local_90;\n  ulong local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  long local_70;\n  undefined4 local_68;\n  undefined4 local_64;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar4 = (undefined8 *)dta_ctx_alloc(puVar1);\n  iVar2 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar2 == -1) {\n    iVar2 = 1;\n    goto LAB_0010154b;\n  }\n  lVar5 = (*(code *)puVar1[3])(&local_94,4,puVar1[5]);\n  iVar2 = 2;\n  if (lVar5 != 4) goto LAB_0010154b;\n  lVar5 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n  if (lVar5 == -1) {\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 0x1f2) = 0x656c696620666f;\n    uVar8 = 0x666f20646e65206f;\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    if (lVar6 != -1) {\n      if (local_94 == 0x6174733c) {\n        iVar2 = dta_read_xmlish_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88;\n        uVar11 = local_90._4_4_;\n      }\n      else {\n        iVar2 = dta_read_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88 & 0xffffffff;\n        uVar11 = (uint)local_90._4_2_;\n      }\n      iVar2 = dta_ctx_init(puVar4,uVar11,uVar9,local_90._1_1_,local_90 & 0xff,param_1[9],param_1[10]\n                          );\n      if (iVar2 != 0) goto LAB_0010154b;\n      puVar4[0x39] = param_3;\n      puVar4[0x38] = lVar5;\n      puVar4[0x37] = param_1[7];\n      puVar4[0x36] = param_1[6];\n      puVar4[0x35] = param_1[5];\n      puVar4[0x34] = param_1[4];\n      puVar4[0x33] = param_1[3];\n      puVar4[0x32] = param_1[2];\n      uVar8 = *param_1;\n      puVar4[0x31] = param_1[1];\n      puVar4[0x30] = uVar8;\n      lVar5 = param_1[0xc];\n      if (lVar5 < 1) {\n        lVar5 = puVar4[0x25];\n      }\n      else {\n        puVar4[0x25] = lVar5;\n      }\n      lVar5 = puVar4[0x22] - lVar5;\n      if (lVar5 < 0) {\n        puVar4[0x25] = puVar4[0x22];\n        lVar5 = 0;\n      }\n      lVar6 = param_1[0xb];\n      lVar10 = lVar5;\n      if (lVar6 < lVar5) {\n        lVar10 = lVar6;\n      }\n      if (lVar6 < 1) {\n        lVar10 = lVar5;\n      }\n      puVar4[0x24] = lVar10;\n      iVar2 = dta_update_progress(puVar4);\n      if (((iVar2 != 0) || (iVar2 = dta_read_label_and_timestamp(puVar4), iVar2 != 0)) ||\n         (iVar2 = dta_read_tag(puVar4,\"</header>\"), iVar2 != 0)) goto LAB_0010154b;\n      if ((code *)puVar4[0x30] != (code *)0x0) {\n        local_90 = puVar4[0x24];\n        local_88 = (ulong)*(int *)((long)puVar4 + 0x10c);\n        local_80 = puVar4[3];\n        local_70 = (long)*(int *)(puVar4 + 0x21);\n        local_68 = 0;\n        local_64 = *(undefined4 *)(puVar4 + 0x2e);\n        local_60 = 0;\n        local_58 = *puVar4;\n        local_50 = 0;\n        local_48 = 0x75 < local_70;\n        local_40 = 0;\n        local_38 = 0;\n        local_78 = local_80;\n        iVar3 = (*(code *)puVar4[0x30])(&local_90,param_3);\n        iVar2 = 4;\n        if (iVar3 != 0) goto LAB_0010154b;\n      }\n      iVar3 = dta_read_map(puVar4);\n      iVar2 = 2;\n      if ((iVar3 != 0) || (iVar2 = dta_read_descriptors(puVar4), iVar2 != 0)) goto LAB_0010154b;\n      if (*(int *)((long)puVar4 + 0x10c) < 1) {\nLAB_00101689:\n        if (0 < (long)puVar4[0x22]) goto LAB_00101693;\n      }\n      else {\n        lVar5 = 0;\n        do {\n          iVar2 = dta_type_info(*(undefined2 *)(puVar4[7] + lVar5 * 2),puVar4,&local_90,0);\n          if (iVar2 != 0) goto LAB_0010154b;\n          puVar4[0x23] = puVar4[0x23] + local_90;\n          lVar5 = lVar5 + 1;\n        } while (lVar5 < *(int *)((long)puVar4 + 0x10c));\n        if (*(int *)((long)puVar4 + 0x10c) < 1) goto LAB_00101689;\nLAB_00101693:\n        if (puVar4[0x23] == 0) {\n          iVar2 = 5;\n          goto LAB_0010154b;\n        }\n      }\n      iVar2 = dta_handle_variables(puVar4);\n      if ((iVar2 == 0) && (iVar2 = dta_read_expansion_fields(puVar4), iVar2 == 0)) {\n        if ((*(byte *)(puVar4 + 0x27) & 4) == 0) {\n          lVar5 = (*(code *)puVar1[2])(0,1,puVar1[5]);\n          puVar4[0x1e] = lVar5;\n          if (lVar5 == -1) {\n            iVar2 = 0xf;\n            goto LAB_0010154b;\n          }\n          puVar4[0x20] = puVar4[0x22] * puVar4[0x23] + lVar5;\n        }\n        iVar2 = dta_read_strls(puVar4);\n        if ((iVar2 == 0) && (iVar2 = dta_read_data(puVar4), iVar2 == 0)) {\n          iVar2 = dta_handle_value_labels(puVar4);\n        }\n      }\n      goto LAB_0010154b;\n    }\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 500) = 0x656c696620666f;\n    uVar8 = 0x207472617473206f;\n  }\n  iVar2 = 0xf;\n  *(undefined8 *)((long)puVar4 + 0x1ec) = uVar8;\n  *(undefined8 *)((long)puVar4 + 0x1e4) = 0x74206b656573206f;\n  *(undefined8 *)((long)puVar4 + 0x1dc) = 0x742064656c696146;\n  (*pcVar7)((long)puVar4 + 0x1dc,puVar4[0x39]);\nLAB_0010154b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if (puVar4 != (undefined8 *)0x0) {\n    dta_ctx_free(puVar4);\n  }\n  return iVar2;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  if(call(, )){\n    \n    goto label\n  }\n  \n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , )\n  if(){\n    if(){\n      call(, , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    if(){\n      call(, , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(call(, )){\n      goto label\n    }\n    call(, , , , , , )\n  }else{\n    \n    if(call(, )){\n      goto label\n    }\n    call(, , , , , , )\n  }\n  if(){\n    goto label\n  }\n  \n  \n  \n  if()\n  \n  if(){\n    \n    \n  }\n  \n  if()\n  call()\n  if()goto label\n  if(call())goto label\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(call(, )){\n      \n      goto label\n    }\n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  for(;;){\n    \n    if(call(, , , ))goto label\n    \n  }\n  if(){\n    \n    goto label\n  }\n  if(call())goto label\n  if(call())goto label\n  if(){\n    call(, , )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call())goto label\n  if(call())goto label\n  if(call())goto label\n  call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  if(){\n    \n    goto label\n  }\n  call(, , )\n  \n  if()goto label\n  call(, , )\n  if(){\n    \n    \n    if()goto label\n    \n    \n  }else{\n    call(, , )\n    if(){\n      if(){\n        call(, )\n        if()goto label\n        \n        \n      }else{\n        call(, )\n        if()goto label\n        \n        \n      }\n      call(, , , , , , )\n      if()goto label\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      if(){\n        \n      }else{\n        \n      }\n      \n      if(){\n        \n        \n      }\n      \n      \n      if(){\n        \n      }\n      if(){\n        \n      }\n      \n      call()\n      if(call()call(, ))goto label\n      if(){\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        call(, )\n        \n        if()goto label\n      }\n      call()\n      \n      if(call())goto label\n      if(){\n        if()goto label\n      }else{\n        \n        do{\n          call(, , , )\n          if()goto label\n          \n          \n        }while()\n        if()goto label\n        if(){\n          \n          goto label\n        }\n      }\n      call()\n      if(call()){\n        if(){\n          call(, , )\n          \n          if(){\n            \n            goto label\n          }\n          \n        }\n        call()\n        if(call()){\n          call()\n        }\n      }\n      goto label\n    }\n    \n    \n    if()goto label\n    \n    \n  }\n  \n  \n  \n  \n  call(, )\n  call()\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  if(){\n    \n    goto label\n  }\n  call(, , )\n  \n  if()goto label\n  call(, , )\n  if(){\n    \n    \n    if()goto label\n    \n    \n  }else{\n    call(, , )\n    if(){\n      if(){\n        call(, )\n        if()goto label\n        \n        \n      }else{\n        call(, )\n        if()goto label\n        \n        \n      }\n      call(, , , , , , )\n      if()goto label\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      if(){\n        \n      }else{\n        \n      }\n      \n      if(){\n        \n        \n      }\n      \n      \n      if(){\n        \n      }\n      if(){\n        \n      }\n      \n      call()\n      if(call()call(, ))goto label\n      if(){\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        call(, )\n        \n        if()goto label\n      }\n      call()\n      \n      if(call())goto label\n      if(){\n        if()goto label\n      }else{\n        \n        do{\n          call(, , , )\n          if()goto label\n          \n          \n        }while()\n        if()goto label\n        if(){\n          \n          goto label\n        }\n      }\n      call()\n      if(call()){\n        if(){\n          call(, , )\n          \n          if(){\n            \n            goto label\n          }\n          \n        }\n        call()\n        if(call()){\n          call()\n        }\n      }\n      goto label\n    }\n    \n    \n    if()goto label\n    \n    \n  }\n  \n  \n  \n  \n  call(, )\n  call()\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.0625,
          "base_ppl": 1.9609375,
          "pr_ppl": 1.96875,
          "source_ast_ppl": 2.609375,
          "base_ast_ppl": 3.4375,
          "pr_ast_ppl": 3.4375,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured and idiomatic approach, using standard loop constructs and clean variable names, making it easier for a human developer to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      }
    ],
    "deepseek-r1": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.5,
          "base_ppl": 4.3125,
          "pr_ppl": 4.21875,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 4.0625,
          "pr_ast_ppl": 4.125,
          "delta_ppl": -0.09375
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "motivation": "Candidate B better preserves the original nesting structure and loop types compared to the source AST, making it more topologically similar.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.5,
          "base_ppl": 4.3125,
          "pr_ppl": 4.21875,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 4.0625,
          "pr_ast_ppl": 4.125,
          "delta_ppl": -0.09375
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch(*(undefined *)(param_2 + 3)) {\n    case 1:\n      local_28 = (long)(char)param_3;\n      break;\n    case 2:\n    case 7:\n    case 10:\n      local_28 = (long)(short)param_3;\n      break;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x29:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      local_28 = (long)(int)param_3;\n      break;\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",*(undefined *)(param_2 + 3));\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 8.5,
          "base_ppl": 3.984375,
          "pr_ppl": 2.78125,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 2.65625,
          "pr_ast_ppl": 2.65625,
          "delta_ppl": -1.203125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and uses standard C practices with proper error handling and type casting. While it's a different function, the original code's logic is replicated more cleanly in B.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar3 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(local_18 + 1));\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = *(byte *)local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(local_28 + 5));\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(local_28 + 6));\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar3) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)*(byte *)local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              bVar1 = *(byte *)local_28;\n              bVar2 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)bVar1 + (uint)bVar2 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)*(byte *)local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)*(byte *)(local_78 + 1));\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(local_28 + 1));\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)*(byte *)local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 !=\n                       0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)*(byte *)(local_28 + 1) +\n                       (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar3 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            \n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), , , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  \n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.5,
          "base_ppl": 4.1875,
          "pr_ppl": 4.125,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 4.65625,
          "pr_ast_ppl": 4.78125,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "Alright, let's dive into this problem. So, I'm supposed to compare two ASTs, A and B, and determine which one is topologically closer to the source AST. The criteria are based on topological shape, loop fidelity, and complexity penalty. Also, there's a forced decision where if both loops are wrong, pick the one with correct nesting, and if loops are same, pick the one with correct nesting depth.\n\nFirst, I need to understand what each candidate's AST looks like compared to the source. The source has a ForLoop where candidate B uses a for(;;) loop, which is a do-while loop. So, loop fidelity is crucial here. The source has a ForLoop, and candidate B uses a do-while loop, which is similar but not the same. Candidate A uses a for(;;) loop as well, which is exactly the same as the source's ForLoop. So, both A and B have the correct loop type, but A uses the exact loop structure, while B uses do-while.\n\nNext, looking at the nesting depth. The source has some if statements and loops that are nested. I need to see how deep the nesting goes in both candidates. In the source, there are loops inside conditionals, and vice versa. Candidate A seems to have similar nesting, but I notice that in the source, there's a for(;;) loop inside a do-while loop, which is inside a case : switch. In candidate A, there's a for(;;) loop inside a do-while loop as well, but I also see that in A, there are goto labels which the source doesn't have. The source uses goto label in some places, but A adds more goto statements, which might mean more complexity.\n\nCandidate B, on the other hand, uses do-while loops where the source uses ForLoop. But B also has some goto labels, similar to A. However, since both A and B have the correct loop type, the next criterion is loop fidelity. Since both are correct, we move to the next one, which is nesting depth.\n\nIn the source, the nesting depth is quite significant. In A, I notice that there's a do-while loop inside a case : switch, which is inside another switch. So, the nesting depth is a bit deeper. In B, I see that it's using do-while loops but perhaps the nesting isn't as deep as in A. However, both have similar levels of nesting, but A might have a slightly deeper structure.\n\nAnother point is complexity penalty. Both A and B add extra nesting levels and goto labels, which increases complexity. However, the source doesn't use goto labels at all, so having more of them is a penalty. But in A, the for-loop is used where the source has a ForLoop, so that's correct. In B, the do-while is used, which is also correct but might have more complexity because of the extra labels.\n\nWait, no, actually, both A and B have the correct loop types because the source has a ForLoop, and both A and B have do-while loops, which are similar but not the same. So, the loop fidelity is same for both because they're both do-while loops, just like the source's ForLoop is a different structure. Hmm, no, loop fidelity should consider whether they're ForLoop or do-while. Since the source has a ForLoop, and both A and B have do-while, they are not the same. So, in that case, the loop fidelity for A is correct, but for B, it's not. Wait, no, the source has a ForLoop, and both A and B have do-while loops, which are not ForLoops, so loop fidelity should be considered as incorrect for both? Or maybe not, because the source has a ForLoop, and the candidates have do-while loops, which are similar in structure but different.\n\nWait, the criteria say: \"Loop Fidelity: ForLoop vs WhileLoop. If Source has a ForLoop, the candidate with ForLoop wins.\" So, in the source, the loop is a ForLoop. In A, the loop is a for(;;) which is a do-while loop, which is a type of while loop. In B, the same. So, since the source has a ForLoop, the candidate needs to have a ForLoop to win on loop fidelity. But both A and B have do-while loops, so neither has a ForLoop. Therefore, according to the forced decision, if both are bad, pick the one with correct loop type. But since the source is ForLoop, and neither has ForLoop, we look at the next criteria: nesting depth.\n\nSo, both A and B have correct loop type (do-while is a while loop, but the source is ForLoop). So, moving on to nesting depth. In the source, the nesting is deeper because of the case : switch inside another switch. In A, the structure is similar but includes goto labels, which are not in the source. In B, the structure is similar, but again with more goto labels. So, perhaps A has a slightly deeper nesting.\n\nBut wait, in the source, after the case : switch, there's a switch() case : which goes deep. In A, it's similar, but with some additional goto labels. So, the nesting depth is similar. However, since both A and B have do-while loops, which are while loops, but the source has ForLoop, which is a different structure. So, in terms of loop fidelity, neither A nor B have the same loop type as the source. Therefore, both have incorrect loop types, so we have to pick the one with correct loop type, which would be neither, but since both are while loops, perhaps we have to look at the nesting depth.\n\nWait, the source has a ForLoop, which is a for loop. The candidates have do-while loops, which are while loops. So, both have incorrect loop types. Therefore, under the forced decision, if both are bad, pick the one with the correct loop type. But since both are while loops, neither is correct. So, perhaps the criteria says that if both are bad, pick the one with correct loop type, but since neither is correct, maybe we have to look at the next criteria, which is nesting depth.\n\nBut the source has a ForLoop, which is more structured with a fixed initialization, condition, and increment. Do-while loops are similar but have a different structure. So, perhaps in terms of loop fidelity, since the source is ForLoop, the candidate should have ForLoop. But neither A nor B have ForLoop; they have do-while. So, both have incorrect loop types. Therefore, under the forced decision, pick the one with correct loop type, but since both are while loops, neither is correct. So, perhaps we have to look at the next criteria, which is nesting depth.\n\nLooking at nesting depth, both A and B have similar nesting, but A might have a slightly deeper structure because of the case : switch inside another switch, which might make the nesting deeper. However, both have the same complexity in terms of nesting.\n\nAnother point is that both A and B have the same number of loops and similar structure, but A uses ForLoop-like do-while, which is correct, and B uses do-while, which is also a while loop but not the same as ForLoop.\n\nWait, but in the source, the loop is a ForLoop, which is more structured. In A, the loop is a for(;;) which is similar to a do-while, but in the source, it's a ForLoop. So, A is correct in loop type, but B is not. Therefore, A should win because it correctly uses a do-while loop, which is a while loop, but the source uses ForLoop, which is a different loop type. So, since A's loop is a correct while loop, it's better than B's loop, which is also a correct while loop. Wait, but the source is ForLoop, which is more specific. So, perhaps A is better because it's using the same loop structure as the source, even though it's a do-while.\n\nWait, the source is a ForLoop, which is a for loop. The candidates have do-while loops, which are while loops. So, in terms of loop type, both A and B are using while loops, but the source is using a for loop. So, in terms of loop fidelity, neither is correct. Therefore, we have to look at the next criteria, which is nesting depth.\n\nIn the source, there's a case : switch inside another switch, which makes the nesting deeper. In A, it's similar, but with some extra goto labels. In B, it's similar as well. So, the nesting depth is similar, but A has more goto labels, which adds complexity. So, perhaps A is more topologically closer because it has the correct loop type (do-while is a while loop, but the source is ForLoop). Wait, but the source is ForLoop, which is a different type. So, perhaps the loop fidelity is not met for both, but the source is ForLoop, so the candidate should have ForLoop. Since neither has ForLoop, we have to pick the one with correct loop type, but both have do-while, which is correct in being a while loop. So, perhaps both are equally correct in loop type, but the source has a ForLoop, which is more specific.\n\nAlternatively, perhaps the loop fidelity is that the candidate should have ForLoop, but since neither has it, we have to pick based on the structure. So, between A and B, both have do-while loops, which are correct as they are while loops."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.25,
          "pr_ppl": 3.25,
          "source_ast_ppl": 5.125,
          "base_ast_ppl": 6.375,
          "pr_ast_ppl": 6.375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A provides a more readable and maintainable implementation with clear variable names and comprehensive comments that explain the logic and flow of the code. While Candidate B is more compact and potentially faster, it sacrifices clarity and makes the control flow less obvious without consulting the provided RL files. The priority of this evaluation is to select the implementation that is more human-readable and maintains higher-level control structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.25,
          "pr_ppl": 3.25,
          "source_ast_ppl": 5.125,
          "base_ast_ppl": 6.375,
          "pr_ast_ppl": 6.375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A preserves the original code structure and logic exactly, making it more human-readable and maintainable. Candidate B attempts to rewrite the code in a different style but deviates significantly from the original implementation, potentially introducing bugs and reducing readability.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.953125,
          "pr_ppl": 3.890625,
          "source_ast_ppl": 8.375,
          "base_ast_ppl": 10.25,
          "pr_ast_ppl": 10.25,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.984375,
          "pr_ppl": 3.953125,
          "source_ast_ppl": 8.375,
          "base_ast_ppl": 10.25,
          "pr_ast_ppl": 10.25,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.234375,
          "pr_ppl": 3.203125,
          "source_ast_ppl": 5.125,
          "base_ast_ppl": 6.3125,
          "pr_ast_ppl": 6.3125,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.359375,
          "pr_ppl": 3.390625,
          "source_ast_ppl": 8.375,
          "base_ast_ppl": 9.625,
          "pr_ast_ppl": 9.625,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A provides a more readable and maintainable implementation while preserving the original functionality. It uses clearer variable names, better organization, and includes helpful comments, making it easier to understand the complex string parsing logic.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.625,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 10.125,
          "pr_ast_ppl": 10.125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.625,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 10.125,
          "pr_ast_ppl": 10.125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.4375,
          "source_ast_ppl": 5.15625,
          "base_ast_ppl": 11.25,
          "pr_ast_ppl": 11.25,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A preserves the original code's structure and style while maintaining readability and correctness. It closely mirrors the original C implementation, making it easier to maintain and understand for those familiar with the Savitzky-Golay parser's original design. Candidate B, while functionally equivalent, introduces unnecessary complexity and deviations from the original C code's style and structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.4375,
          "source_ast_ppl": 5.15625,
          "base_ast_ppl": 11.25,
          "pr_ast_ppl": 11.25,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is the more human-readable and accurate approximation because it closely mirrors the original code's structure and uses standard C constructs, making it easier to understand and maintain.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_zsav_read_compressed_data-O0.so",
        "function": "zsav_read_compressed_data",
        "source_code": "readstat_error_t zsav_read_compressed_data(sav_ctx_t *ctx,\n        readstat_error_t (*row_handler)(unsigned char *, size_t, sav_ctx_t *)) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = ctx->io;\n    readstat_off_t data_offset = 0;\n\n    size_t uncompressed_row_len = ctx->var_offset * 8;\n    readstat_off_t uncompressed_offset = 0;\n    unsigned char *uncompressed_row = NULL;\n\n    uLongf uncompressed_block_len = 0;\n    unsigned char *compressed_block = NULL, *uncompressed_block = NULL;\n\n    struct sav_row_stream_s state = { \n        .missing_value = ctx->missing_double,\n        .bias = ctx->bias,\n        .bswap = ctx->bswap };\n\n    struct zheader zheader;\n    struct ztrailer ztrailer;\n    struct ztrailer_entry *ztrailer_entries = NULL;\n\n    int n_blocks = 0;\n    int block_i = 0;\n    int i;\n\n    if (io->read(&zheader, sizeof(struct zheader), io->io_ctx) < sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    zheader.zheader_ofs = ctx->bswap ? byteswap8(zheader.zheader_ofs) : zheader.zheader_ofs;\n    zheader.ztrailer_ofs = ctx->bswap ? byteswap8(zheader.ztrailer_ofs) : zheader.ztrailer_ofs;\n    zheader.ztrailer_len = ctx->bswap ? byteswap8(zheader.ztrailer_len) : zheader.ztrailer_len;\n\n    if (zheader.zheader_ofs != io->seek(0, READSTAT_SEEK_CUR, io->io_ctx) - sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    n_blocks = (zheader.ztrailer_len - 24) / 24;\n\n    if (io->seek(zheader.ztrailer_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->read(&ztrailer, sizeof(struct ztrailer), io->io_ctx) < sizeof(struct ztrailer)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ztrailer.bias = ctx->bswap ? byteswap8(ztrailer.bias) : ztrailer.bias;\n    ztrailer.zero = ctx->bswap ? byteswap8(ztrailer.zero) : ztrailer.zero;\n    ztrailer.block_size = ctx->bswap ? byteswap4(ztrailer.block_size) : ztrailer.block_size;\n    ztrailer.n_blocks = ctx->bswap ? byteswap4(ztrailer.n_blocks) : ztrailer.n_blocks;\n\n    if (n_blocks != ztrailer.n_blocks) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    if (n_blocks && (ztrailer_entries = readstat_malloc(n_blocks * sizeof(struct ztrailer_entry))) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (io->read(ztrailer_entries, n_blocks * sizeof(struct ztrailer_entry), io->io_ctx) < \n            n_blocks * sizeof(struct ztrailer_entry)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    for (i=0; i<n_blocks; i++) {\n        struct ztrailer_entry *entry = &ztrailer_entries[i];\n\n        entry->uncompressed_ofs = ctx->bswap ? byteswap8(entry->uncompressed_ofs) : entry->uncompressed_ofs;\n        entry->compressed_ofs = ctx->bswap ? byteswap8(entry->compressed_ofs) : entry->compressed_ofs;\n        entry->uncompressed_size = ctx->bswap ? byteswap4(entry->uncompressed_size) : entry->uncompressed_size;\n        entry->compressed_size = ctx->bswap ? byteswap4(entry->compressed_size) : entry->compressed_size;\n    }\n\n    if (uncompressed_row_len && (uncompressed_row = readstat_malloc(uncompressed_row_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    while (1) {\n        if (block_i == n_blocks)\n            goto cleanup;\n\n        struct ztrailer_entry *entry = &ztrailer_entries[block_i];\n        if (io->seek(entry->compressed_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n            retval = READSTAT_ERROR_SEEK;\n            goto cleanup;\n        }\n        if ((compressed_block = readstat_realloc(compressed_block, entry->compressed_size)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if (io->read(compressed_block, entry->compressed_size, io->io_ctx) != entry->compressed_size) {\n            retval = READSTAT_ERROR_READ;\n            goto cleanup;\n        }\n\n        uncompressed_block_len = entry->uncompressed_size;\n        if ((uncompressed_block = readstat_realloc(uncompressed_block, uncompressed_block_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        int status = uncompress(uncompressed_block, &uncompressed_block_len,\n                compressed_block, entry->compressed_size);\n        if (status != Z_OK || uncompressed_block_len != entry->uncompressed_size) {\n            retval = READSTAT_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        block_i++;\n        state.status = SAV_ROW_STREAM_HAVE_DATA;\n        data_offset = 0;\n\n        while (state.status != SAV_ROW_STREAM_NEED_DATA) {\n            state.next_in = &uncompressed_block[data_offset];\n            state.avail_in = uncompressed_block_len - data_offset;\n\n            state.next_out = &uncompressed_row[uncompressed_offset];\n            state.avail_out = uncompressed_row_len - uncompressed_offset;\n\n            sav_decompress_row(&state);\n\n            uncompressed_offset = uncompressed_row_len - state.avail_out;\n            data_offset = uncompressed_block_len - state.avail_in;\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ROW) {\n                retval = row_handler(uncompressed_row, uncompressed_row_len, ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                uncompressed_offset = 0;\n            }\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ALL)\n                goto cleanup;\n            if (ctx->row_limit > 0 && ctx->current_row == ctx->row_limit)\n                goto cleanup;\n        }\n    }\n\ncleanup:\n    if (uncompressed_row)\n        free(uncompressed_row);\n    if (ztrailer_entries)\n        free(ztrailer_entries);\n    if (compressed_block)\n        free(compressed_block);\n    if (uncompressed_block)\n        free(uncompressed_block);\n\n    return retval;\n}\n",
        "function_base": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined1 auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined1 auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "function_pr": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(){\n    \n    goto label\n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  for(;;){\n    \n    (? call(): )\n    (? call(): )\n    (? call(): )\n    (? call(): )\n  }\n  if(call()){\n    \n    goto label\n  }\n  while(){\n    if()goto label\n    \n    if(call(, , )){\n      \n      goto label\n    }\n    if(call(, )){\n      \n      goto label\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    \n    if(call(, )){\n      \n      goto label\n    }\n    call(, , , )\n    if(){\n      \n      goto label\n    }\n    \n    \n    \n    while(){\n      \n      \n      \n      \n      call()\n      \n      \n      if(){\n        call(, , )\n        if()goto label\n        \n      }\n      if()goto label\n      if()goto label\n    }\n  }\n  if()call()\n  if()call()\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.4375,
          "base_ppl": 2.46875,
          "pr_ppl": 2.46875,
          "source_ast_ppl": 5.625,
          "base_ast_ppl": 6.5625,
          "pr_ast_ppl": 6.5625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 3.4375,
          "pr_ppl": 3.4375,
          "source_ast_ppl": 5.15625,
          "base_ast_ppl": 9.3125,
          "pr_ast_ppl": 9.3125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable because it closely follows the original source code's structure and style, making it easier to understand for someone familiar with the code. The code is semantically identical, and the only differences are minor comments and variable name changes that do not affect functionality.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    do{\n      \n      \n      switch(){\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          \n          \n          \n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          goto label\n        case :\n          \n        case :\n          \n          \n          \n          if(){\n            return\n          }\n      }\n      if(){\n        return\n      }\n      \n      \n      \n      \n      \n    }while()\n    if(){\n      \n      \n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 3.390625,
          "pr_ppl": 3.390625,
          "source_ast_ppl": 70.0,
          "base_ast_ppl": 9.1875,
          "pr_ast_ppl": 7.21875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is chosen because it faithfully replicates the original code's functionality and structure, making it both semantically equivalent and highly readable.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    do{\n      \n      \n      switch(){\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          \n          \n          \n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          goto label\n        case :\n          \n        case :\n          \n          \n          \n          if(){\n            return\n          }\n      }\n      if(){\n        return\n      }\n      \n      \n      \n      \n      \n    }while()\n    if(){\n      \n      \n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 3.390625,
          "pr_ppl": 3.390625,
          "source_ast_ppl": 70.0,
          "base_ast_ppl": 9.1875,
          "pr_ast_ppl": 7.21875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable and maintains the original's structure with standard loops and clean logic, even though it uses more verbose syntax compared to the original source code.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate B uses if statements instead of goto labels, making the control flow clearer, despite both candidates having incorrect loop types.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 3.828125,
          "pr_ppl": 3.828125,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 9.625,
          "pr_ast_ppl": 9.625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O0.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined1 local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined1 local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined1 local_208 [60];\n  undefined1 auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined local_208 [60];\n  undefined auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            \n                            \n                            goto label\n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            \n                            \n                            goto label\n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 5.28125,
          "base_ppl": 3.75,
          "pr_ppl": 3.75,
          "source_ast_ppl": 4.78125,
          "base_ast_ppl": 5.375,
          "pr_ast_ppl": 5.375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable and accurate because it closely mirrors the original SPHIRE code's structure, variable names, and pointer usage patterns. It maintains the same semantic equivalence and control flow as the original, making it easier to understand for someone familiar with the SPHIRE codebase. Candidate B, while correct, introduces more C-specific features and a different variable structure that could make it less familiar and harder to debug for developers who are more accustomed to the SPHIRE style.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_ctx_init-O0.so",
        "function": "dta_ctx_init",
        "source_code": "readstat_error_t dta_ctx_init(dta_ctx_t *ctx, uint32_t nvar, uint64_t nobs,\n        unsigned char byteorder, unsigned char ds_format,\n        const char *input_encoding, const char *output_encoding) {\n    readstat_error_t retval = READSTAT_OK;\n    int machine_byteorder = DTA_HILO;\n    if (ds_format < DTA_MIN_VERSION || ds_format > DTA_MAX_VERSION)\n        return READSTAT_ERROR_UNSUPPORTED_FILE_FORMAT_VERSION;\n\n    if (machine_is_little_endian()) {\n        machine_byteorder = DTA_LOHI;\n    }\n\n    ctx->bswap = (byteorder != machine_byteorder);\n    ctx->ds_format = ds_format;\n    ctx->endianness = byteorder == DTA_LOHI ? READSTAT_ENDIAN_LITTLE : READSTAT_ENDIAN_BIG;\n\n    ctx->nvar = nvar;\n    ctx->nobs = nobs;\n\n    if (ctx->nvar) {\n        if ((ctx->variables = readstat_calloc(ctx->nvar, sizeof(readstat_variable_t *))) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->machine_is_twos_complement = READSTAT_MACHINE_IS_TWOS_COMPLEMENT;\n\n    if (ds_format < 105) {\n        ctx->fmtlist_entry_len = 7;\n    } else if (ds_format < 114) {\n        ctx->fmtlist_entry_len = 12;\n    } else if (ds_format < 118) {\n        ctx->fmtlist_entry_len = 49;\n    } else {\n        ctx->fmtlist_entry_len = 57;\n    }\n    \n    if (ds_format >= 117) {\n        ctx->typlist_version = 117;\n    } else if (ds_format >= 111) {\n        ctx->typlist_version = 111;\n    } else {\n        ctx->typlist_version = 0;\n    }\n\n    if (ds_format >= 118) {\n        ctx->data_label_len_len = 2;\n        ctx->strl_v_len = 2;\n        ctx->strl_o_len = 6;\n    } else if (ds_format >= 117) {\n        ctx->data_label_len_len = 1;\n        ctx->strl_v_len = 4;\n        ctx->strl_o_len = 4;\n    }\n\n    if (ds_format < 105) {\n        ctx->expansion_len_len = 0;\n    } else if (ds_format < 110) {\n        ctx->expansion_len_len = 2;\n    } else {\n        ctx->expansion_len_len = 4;\n    }\n    \n    if (ds_format < 110) {\n        ctx->lbllist_entry_len = 9;\n        ctx->variable_name_len = 9;\n        ctx->ch_metadata_len = 9;\n    } else if (ds_format < 118) {\n        ctx->lbllist_entry_len = 33;\n        ctx->variable_name_len = 33;\n        ctx->ch_metadata_len = 33;\n    } else {\n        ctx->lbllist_entry_len = 129;\n        ctx->variable_name_len = 129;\n        ctx->ch_metadata_len = 129;\n    }\n\n    if (ds_format < 108) {\n        ctx->variable_labels_entry_len = 32;\n        ctx->data_label_len = 32;\n    } else if (ds_format < 118) {\n        ctx->variable_labels_entry_len = 81;\n        ctx->data_label_len = 81;\n    } else {\n        ctx->variable_labels_entry_len = 321;\n        ctx->data_label_len = 321;\n    }\n\n    if (ds_format < 105) {\n        ctx->timestamp_len = 0;\n        ctx->value_label_table_len_len = 2;\n        ctx->value_label_table_labname_len = 12;\n        ctx->value_label_table_padding_len = 2;\n    } else {\n        ctx->timestamp_len = 18;\n        ctx->value_label_table_len_len = 4;\n        if (ds_format < 118) {\n            ctx->value_label_table_labname_len = 33;\n        } else {\n            ctx->value_label_table_labname_len = 129;\n        }\n        ctx->value_label_table_padding_len = 3;\n    }\n\n    if (ds_format < 117) {\n        ctx->typlist_entry_len = 1;\n        ctx->file_is_xmlish = 0;\n    } else {\n        ctx->typlist_entry_len = 2;\n        ctx->file_is_xmlish = 1;\n    }\n\n    if (ds_format < 113) {\n        ctx->max_int8 = DTA_OLD_MAX_INT8;\n        ctx->max_int16 = DTA_OLD_MAX_INT16;\n        ctx->max_int32 = DTA_OLD_MAX_INT32;\n        ctx->max_float = DTA_OLD_MAX_FLOAT;\n        ctx->max_double = DTA_OLD_MAX_DOUBLE;\n    } else {\n        ctx->max_int8 = DTA_113_MAX_INT8;\n        ctx->max_int16 = DTA_113_MAX_INT16;\n        ctx->max_int32 = DTA_113_MAX_INT32;\n        ctx->max_float = DTA_113_MAX_FLOAT;\n        ctx->max_double = DTA_113_MAX_DOUBLE;\n\n        ctx->supports_tagged_missing = 1;\n    }\n\n    if (output_encoding) {\n        if (input_encoding) {\n            ctx->converter = iconv_open(output_encoding, input_encoding);\n        } else if (ds_format < 118) {\n            ctx->converter = iconv_open(output_encoding, \"WINDOWS-1252\");\n        } else if (strcmp(output_encoding, \"UTF-8\") != 0) {\n            ctx->converter = iconv_open(output_encoding, \"UTF-8\");\n        }\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n\n    if (ds_format < 119) {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int16_t);\n    } else {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int32_t);\n    }\n\n    if ((ctx->srtlist = readstat_malloc(ctx->srtlist_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->nvar > 0) {\n        ctx->typlist_len = ctx->nvar * sizeof(uint16_t);\n        ctx->varlist_len = ctx->variable_name_len * ctx->nvar * sizeof(char);\n        ctx->fmtlist_len = ctx->fmtlist_entry_len * ctx->nvar * sizeof(char);\n        ctx->lbllist_len = ctx->lbllist_entry_len * ctx->nvar * sizeof(char);\n        ctx->variable_labels_len = ctx->variable_labels_entry_len * ctx->nvar * sizeof(char);\n\n        if ((ctx->typlist = readstat_malloc(ctx->typlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->varlist = readstat_malloc(ctx->varlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->fmtlist = readstat_malloc(ctx->fmtlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->lbllist = readstat_malloc(ctx->lbllist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->variable_labels = readstat_malloc(ctx->variable_labels_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->initialized = 1;\n\ncleanup:\n    return retval;\n}\n",
        "function_base": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined1 *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined1 *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined1 *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "function_pr": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "source_ast": "{\n  \n  \n  if()return\n  if(call()){\n    \n  }\n  \n  \n  (? : )\n  \n  \n  if(){\n    if(call(, )){\n      \n      goto label\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      call(, )\n    }elseif(){\n      call(, )\n    }elseif(call(, )){\n      call(, )\n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(){\n    \n    \n    \n    \n    \n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "metrics": {
          "source_ppl": 2.71875,
          "base_ppl": 2.0625,
          "pr_ppl": 2.078125,
          "source_ast_ppl": 8.125,
          "base_ast_ppl": 5.65625,
          "pr_ast_ppl": 5.65625,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "The original code has potential reliability issues with the Iconv library and lacks proper error handling. Candidate B is simpler and more standard, prioritizing readability and maintainability over direct replication of the original code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O2.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined1 auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined1 local_608 [60];\n  undefined1 local_5cc [148];\n  undefined1 local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined local_608 [60];\n  undefined local_5cc [148];\n  undefined local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 5.28125,
          "base_ppl": 5.28125,
          "pr_ppl": 5.3125,
          "source_ast_ppl": 4.78125,
          "base_ast_ppl": 7.15625,
          "pr_ast_ppl": 7.15625,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is a direct and exact port of the original C code, preserving all semantic equivalence, variable recovery, and maintaining the same control flow and structure. It is more idiomatic C and cleaner in execution without unnecessary object-oriented features.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O3.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined1 auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined1 local_608 [60];\n  undefined1 local_5cc [148];\n  undefined1 local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined local_608 [60];\n  undefined local_5cc [148];\n  undefined local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 5.28125,
          "base_ppl": 5.28125,
          "pr_ppl": 5.3125,
          "source_ast_ppl": 4.78125,
          "base_ast_ppl": 7.15625,
          "pr_ast_ppl": 7.15625,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O0.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  uint uVar3;\n  int iVar4;\n  long lVar5;\n  int *local_60;\n  int local_3c;\n  \n  if (param_4 <= *param_3) {\n    return 10;\n  }\n  uVar1 = *param_3;\n  do {\n    local_3c = 0;\n    if (param_4 <= *param_3) goto LAB_001016a7;\n    switch(*param_1) {\n    case 0:\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      *param_1 = 1;\n      break;\n    case 1:\n      local_3c = lzma_vli_decode(param_1 + 0x46,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) goto LAB_001016a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      iVar4 = 2;\n      if (*(long *)(param_1 + 0x46) == 0) {\n        iVar4 = 4;\n      }\n      *param_1 = iVar4;\n      break;\n    case 2:\n    case 3:\n      if (*param_1 == 2) {\n        local_60 = param_1 + 0x48;\n      }\n      else {\n        local_60 = param_1 + 0x4a;\n      }\n      local_3c = lzma_vli_decode(local_60,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) {\nLAB_001016a7:\n        if (*param_3 - uVar1 != 0) {\n          iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n          param_1[0x4e] = iVar4;\n        }\n        return local_3c;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        if ((*(ulong *)(param_1 + 0x48) < 5) || (0x7ffffffffffffffc < *(ulong *)(param_1 + 0x48))) {\n          return 9;\n        }\n        *param_1 = 3;\n      }\n      else {\n        hash_append(param_1 + 0x24,*(undefined8 *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (((*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) ||\n            (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26))) ||\n           (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lVar5 = *(long *)(param_1 + 0x46);\n        *(long *)(param_1 + 0x46) = lVar5 + -1;\n        iVar4 = 2;\n        if (lVar5 + -1 == 0) {\n          iVar4 = 4;\n        }\n        *param_1 = iVar4;\n      }\n      break;\n    case 4:\n      lVar5 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      *(ulong *)(param_1 + 0x4c) = 4U - lVar5 & 3;\n      *param_1 = 5;\n    case 5:\n      if (*(long *)(param_1 + 0x4c) == 0) {\n        if (((*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) ||\n            (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26))) ||\n           (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar3 = lzma_check_size(10);\n        iVar4 = memcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar3);\n        if (iVar4 != 0) {\n          return 9;\n        }\n        iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n        param_1[0x4e] = iVar4;\n        *param_1 = 6;\nswitchD_001011ee_caseD_6:\n        while( true ) {\n          if (*param_3 == param_4) {\n            return 0;\n          }\n          uVar3 = param_1[0x4e];\n          lVar5 = *(long *)(param_1 + 0x4c);\n          uVar1 = *param_3;\n          *param_3 = uVar1 + 1;\n          if ((uVar3 >> ((byte)(lVar5 << 3) & 0x1f) & 0xff) != (uint)*(byte *)(param_2 + uVar1))\n          break;\n          lVar5 = *(long *)(param_1 + 0x4c);\n          *(ulong *)(param_1 + 0x4c) = lVar5 + 1U;\n          if (3 < lVar5 + 1U) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *(long *)(param_1 + 0x4c) = *(long *)(param_1 + 0x4c) + -1;\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      break;\n    case 6:\n      goto switchD_001011ee_caseD_6;\n    default:\n      return 0xb;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  uint uVar3;\n  int iVar4;\n  long lVar5;\n  int *local_60;\n  int local_3c;\n  \n  if (param_4 <= *param_3) {\n    return 10;\n  }\n  uVar1 = *param_3;\n  do {\n    local_3c = 0;\n    if (param_4 <= *param_3) goto LAB_001016a7;\n    switch(*param_1) {\n    case 0:\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      *param_1 = 1;\n      break;\n    case 1:\n      local_3c = lzma_vli_decode(param_1 + 0x46,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) goto LAB_001016a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      iVar4 = 2;\n      if (*(long *)(param_1 + 0x46) == 0) {\n        iVar4 = 4;\n      }\n      *param_1 = iVar4;\n      break;\n    case 2:\n    case 3:\n      if (*param_1 == 2) {\n        local_60 = param_1 + 0x48;\n      }\n      else {\n        local_60 = param_1 + 0x4a;\n      }\n      local_3c = lzma_vli_decode(local_60,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) {\nLAB_001016a7:\n        if (*param_3 - uVar1 != 0) {\n          iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n          param_1[0x4e] = iVar4;\n        }\n        return local_3c;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        if ((*(ulong *)(param_1 + 0x48) < 5) || (0x7ffffffffffffffc < *(ulong *)(param_1 + 0x48))) {\n          return 9;\n        }\n        *param_1 = 3;\n      }\n      else {\n        hash_append(param_1 + 0x24,*(undefined8 *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (((*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) ||\n            (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26))) ||\n           (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lVar5 = *(long *)(param_1 + 0x46);\n        *(long *)(param_1 + 0x46) = lVar5 + -1;\n        iVar4 = 2;\n        if (lVar5 + -1 == 0) {\n          iVar4 = 4;\n        }\n        *param_1 = iVar4;\n      }\n      break;\n    case 4:\n      lVar5 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      *(ulong *)(param_1 + 0x4c) = 4U - lVar5 & 3;\n      *param_1 = 5;\n    case 5:\n      if (*(long *)(param_1 + 0x4c) == 0) {\n        if (((*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) ||\n            (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26))) ||\n           (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar3 = lzma_check_size(10);\n        iVar4 = memcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar3);\n        if (iVar4 != 0) {\n          return 9;\n        }\n        iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n        param_1[0x4e] = iVar4;\n        *param_1 = 6;\nLAB_001015f6:\n        while( true ) {\n          if (*param_3 == param_4) {\n            return 0;\n          }\n          uVar3 = param_1[0x4e];\n          lVar5 = *(long *)(param_1 + 0x4c);\n          uVar1 = *param_3;\n          *param_3 = uVar1 + 1;\n          if ((uVar3 >> ((byte)(lVar5 << 3) & 0x1f) & 0xff) != (uint)*(byte *)(param_2 + uVar1))\n          break;\n          lVar5 = *(long *)(param_1 + 0x4c);\n          *(ulong *)(param_1 + 0x4c) = lVar5 + 1U;\n          if (3 < lVar5 + 1U) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *(long *)(param_1 + 0x4c) = *(long *)(param_1 + 0x4c) + -1;\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      break;\n    case 6:\n      goto LAB_001015f6;\n    default:\n      return 0xb;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  if()return\n  \n  \n  \n  \n  \n  while()switch(){\n    case :\n      \n      if()return\n      \n      \n    case :\n      {\n        call(, , , , )\n        if()goto label\n        \n        if()return\n        \n        \n        \n        (? : )\n        \n      }\n    case :\n    case :\n      {\n        (? : )\n        call(, , , , )\n        if()goto label\n        \n        \n        if(){\n          if()return\n          \n        }else{\n          \n          call(, , )\n          \n          \n          \n          \n          \n          \n          if()return\n          \n          (? : )\n        }\n        \n      }\n    case :\n      call()call(, )\n      \n      \n    case :\n      if(){\n        \n        if()return\n        \n      }\n      \n      if()return\n      \n      call(, )\n      call(, )\n      if(call(, , call()))return\n      \n      call(, , )\n      \n      \n    case :\n      do{\n        if()return\n        if(){\n          return\n        }\n      }while()\n      return\n    case :\n      \n      call()\n      return\n  }\n  {\n    \n    if()call(, , )\n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  \n  do{\n    \n    if()goto label\n    switch(){\n      case :\n        \n        \n        if(){\n          return\n        }\n        \n        \n      case :\n        call(, , , , )\n        if()goto label\n        if(){\n          return\n        }\n        \n        \n        \n        if(){\n          \n        }\n        \n        \n      case :\n      case :\n        if(){\n          \n        }else{\n          \n        }\n        call(, , , , )\n        if(){\n          if(){\n            call(, , )\n            \n          }\n          return\n        }\n        \n        \n        if(){\n          if(){\n            return\n          }\n          \n        }else{\n          call(, , )\n          if(){\n            return\n          }\n          \n          \n          \n          if(){\n            \n          }\n          \n        }\n        \n      case :\n        call(, )\n        \n        \n      case :\n        if(){\n          if(){\n            return\n          }\n          call(, )\n          call(, )\n          call()\n          call(, , )\n          if(){\n            return\n          }\n          call(, , )\n          \n          \n          while(){\n            if(){\n              return\n            }\n            \n            \n            \n            \n            if(call())\n            \n            \n            if(){\n              return\n            }\n          }\n          return\n        }\n        \n        \n        \n        if(){\n          return\n        }\n        \n      case :\n        goto label\n      case :\n        \n        return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  \n  do{\n    \n    if()goto label\n    switch(){\n      case :\n        \n        \n        if(){\n          return\n        }\n        \n        \n      case :\n        call(, , , , )\n        if()goto label\n        if(){\n          return\n        }\n        \n        \n        \n        if(){\n          \n        }\n        \n        \n      case :\n      case :\n        if(){\n          \n        }else{\n          \n        }\n        call(, , , , )\n        if(){\n          if(){\n            call(, , )\n            \n          }\n          return\n        }\n        \n        \n        if(){\n          if(){\n            return\n          }\n          \n        }else{\n          call(, , )\n          if(){\n            return\n          }\n          \n          \n          \n          if(){\n            \n          }\n          \n        }\n        \n      case :\n        call(, )\n        \n        \n      case :\n        if(){\n          if(){\n            return\n          }\n          call(, )\n          call(, )\n          call()\n          call(, , )\n          if(){\n            return\n          }\n          call(, , )\n          \n          \n          while(){\n            if(){\n              return\n            }\n            \n            \n            \n            \n            if(call())\n            \n            \n            if(){\n              return\n            }\n          }\n          return\n        }\n        \n        \n        \n        if(){\n          return\n        }\n        \n      case :\n        goto label\n      case :\n        \n        return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 6.28125,
          "base_ppl": 4.0625,
          "pr_ppl": 3.984375,
          "source_ast_ppl": 12.375,
          "base_ast_ppl": 9.0625,
          "pr_ast_ppl": 9.0625,
          "delta_ppl": -0.078125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable and follows standard C conventions, making it a better approximation of the original source code.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_dta-O2.so",
        "function": "readstat_parse_dta",
        "source_code": "readstat_error_t readstat_parse_dta(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    int i;\n    dta_ctx_t    *ctx;\n    size_t file_size = 0;\n\n    ctx = dta_ctx_alloc(io);\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    char magic[4];\n    if (io->read(magic, 4, io->io_ctx) != 4) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx);\n    if (file_size == -1) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"Failed to seek to start of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (strncmp(magic, \"<sta\", 4) == 0) {\n        dta_header64_t header;\n        if ((retval = dta_read_xmlish_header(ctx, &header)) != READSTAT_OK) {\n            goto cleanup;\n        }\n        retval = dta_ctx_init(ctx, header.nvar, header.nobs, header.byteorder, header.ds_format,\n                parser->input_encoding, parser->output_encoding);\n    } else {\n        dta_header_t header;\n        if ((retval = dta_read_header(ctx, &header)) != READSTAT_OK) {\n            goto cleanup;\n        }\n        retval = dta_ctx_init(ctx, header.nvar, header.nobs, header.byteorder, header.ds_format,\n                parser->input_encoding, parser->output_encoding);\n    }\n    if (retval != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->user_ctx = user_ctx;\n    ctx->file_size = file_size;\n    ctx->handle = parser->handlers;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n    int64_t nobs_after_skipping = ctx->nobs - ctx->row_offset;\n    if (nobs_after_skipping < 0) {\n        nobs_after_skipping = 0;\n        ctx->row_offset = ctx->nobs;\n    }\n    ctx->row_limit = nobs_after_skipping;\n    if (parser->row_limit > 0 && parser->row_limit < nobs_after_skipping)\n        ctx->row_limit = parser->row_limit;\n\n    retval = dta_update_progress(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if ((retval = dta_read_label_and_timestamp(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_read_tag(ctx, \"</header>\")) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.metadata) {\n        readstat_metadata_t metadata = {\n            .row_count = ctx->row_limit,\n            .var_count = ctx->nvar,\n            .file_label = ctx->data_label,\n            .creation_time = ctx->timestamp,\n            .modified_time = ctx->timestamp,\n            .file_format_version = ctx->ds_format,\n            .is64bit = ctx->ds_format >= 118,\n            .endianness = ctx->endianness\n        };\n        if (ctx->handle.metadata(&metadata, user_ctx) != READSTAT_HANDLER_OK) {\n            retval = READSTAT_ERROR_USER_ABORT;\n            goto cleanup;\n        }\n    }\n\n    if ((retval = dta_read_map(ctx)) != READSTAT_OK) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    if ((retval = dta_read_descriptors(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    for (i=0; i<ctx->nvar; i++) {\n        size_t      max_len;\n        if ((retval = dta_type_info(ctx->typlist[i], ctx, &max_len, NULL)) != READSTAT_OK)\n            goto cleanup;\n\n        ctx->record_len += max_len;\n    }\n\n    if ((ctx->nvar > 0 || ctx->nobs > 0) && ctx->record_len == 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    if ((retval = dta_handle_variables(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_read_expansion_fields(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if (!ctx->file_is_xmlish) {\n        ctx->data_offset = io->seek(0, READSTAT_SEEK_CUR, io->io_ctx);\n        if (ctx->data_offset == -1) {\n            retval = READSTAT_ERROR_SEEK;\n            goto cleanup;\n        }\n        ctx->value_labels_offset = ctx->data_offset + ctx->record_len * ctx->nobs;\n    }\n\n    if ((retval = dta_read_strls(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_read_data(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_handle_value_labels(ctx)) != READSTAT_OK)\n        goto cleanup;\n\ncleanup:\n    io->close(io->io_ctx);\n    if (ctx)\n        dta_ctx_free(ctx);\n\n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_dta(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long lVar6;\n  code *pcVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  long lVar10;\n  uint uVar11;\n  int local_94;\n  undefined8 local_90;\n  ulong local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  long local_70;\n  undefined4 local_68;\n  undefined4 local_64;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined1 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar4 = (undefined8 *)dta_ctx_alloc(puVar1);\n  iVar2 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar2 == -1) {\n    iVar2 = 1;\n    goto LAB_0010154b;\n  }\n  lVar5 = (*(code *)puVar1[3])(&local_94,4,puVar1[5]);\n  iVar2 = 2;\n  if (lVar5 != 4) goto LAB_0010154b;\n  lVar5 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n  if (lVar5 == -1) {\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 0x1f2) = 0x656c696620666f;\n    uVar8 = 0x666f20646e65206f;\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    if (lVar6 != -1) {\n      if (local_94 == 0x6174733c) {\n        iVar2 = dta_read_xmlish_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88;\n        uVar11 = local_90._4_4_;\n      }\n      else {\n        iVar2 = dta_read_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88 & 0xffffffff;\n        uVar11 = (uint)local_90._4_2_;\n      }\n      iVar2 = dta_ctx_init(puVar4,uVar11,uVar9,local_90._1_1_,local_90 & 0xff,param_1[9],param_1[10]\n                          );\n      if (iVar2 != 0) goto LAB_0010154b;\n      puVar4[0x39] = param_3;\n      puVar4[0x38] = lVar5;\n      puVar4[0x37] = param_1[7];\n      puVar4[0x36] = param_1[6];\n      puVar4[0x35] = param_1[5];\n      puVar4[0x34] = param_1[4];\n      puVar4[0x33] = param_1[3];\n      puVar4[0x32] = param_1[2];\n      uVar8 = *param_1;\n      puVar4[0x31] = param_1[1];\n      puVar4[0x30] = uVar8;\n      lVar5 = param_1[0xc];\n      if (lVar5 < 1) {\n        lVar5 = puVar4[0x25];\n      }\n      else {\n        puVar4[0x25] = lVar5;\n      }\n      lVar5 = puVar4[0x22] - lVar5;\n      if (lVar5 < 0) {\n        puVar4[0x25] = puVar4[0x22];\n        lVar5 = 0;\n      }\n      lVar6 = param_1[0xb];\n      lVar10 = lVar5;\n      if (lVar6 < lVar5) {\n        lVar10 = lVar6;\n      }\n      if (lVar6 < 1) {\n        lVar10 = lVar5;\n      }\n      puVar4[0x24] = lVar10;\n      iVar2 = dta_update_progress(puVar4);\n      if (((iVar2 != 0) || (iVar2 = dta_read_label_and_timestamp(puVar4), iVar2 != 0)) ||\n         (iVar2 = dta_read_tag(puVar4,\"</header>\"), iVar2 != 0)) goto LAB_0010154b;\n      if ((code *)puVar4[0x30] != (code *)0x0) {\n        local_90 = puVar4[0x24];\n        local_88 = (ulong)*(int *)((long)puVar4 + 0x10c);\n        local_80 = puVar4[3];\n        local_70 = (long)*(int *)(puVar4 + 0x21);\n        local_68 = 0;\n        local_64 = *(undefined4 *)(puVar4 + 0x2e);\n        local_60 = 0;\n        local_58 = *puVar4;\n        local_50 = 0;\n        local_48 = 0x75 < local_70;\n        local_40 = 0;\n        local_38 = 0;\n        local_78 = local_80;\n        iVar3 = (*(code *)puVar4[0x30])(&local_90,param_3);\n        iVar2 = 4;\n        if (iVar3 != 0) goto LAB_0010154b;\n      }\n      iVar3 = dta_read_map(puVar4);\n      iVar2 = 2;\n      if ((iVar3 != 0) || (iVar2 = dta_read_descriptors(puVar4), iVar2 != 0)) goto LAB_0010154b;\n      if (*(int *)((long)puVar4 + 0x10c) < 1) {\nLAB_00101689:\n        if (0 < (long)puVar4[0x22]) goto LAB_00101693;\n      }\n      else {\n        lVar5 = 0;\n        do {\n          iVar2 = dta_type_info(*(undefined2 *)(puVar4[7] + lVar5 * 2),puVar4,&local_90,0);\n          if (iVar2 != 0) goto LAB_0010154b;\n          puVar4[0x23] = puVar4[0x23] + local_90;\n          lVar5 = lVar5 + 1;\n        } while (lVar5 < *(int *)((long)puVar4 + 0x10c));\n        if (*(int *)((long)puVar4 + 0x10c) < 1) goto LAB_00101689;\nLAB_00101693:\n        if (puVar4[0x23] == 0) {\n          iVar2 = 5;\n          goto LAB_0010154b;\n        }\n      }\n      iVar2 = dta_handle_variables(puVar4);\n      if ((iVar2 == 0) && (iVar2 = dta_read_expansion_fields(puVar4), iVar2 == 0)) {\n        if ((*(byte *)(puVar4 + 0x27) & 4) == 0) {\n          lVar5 = (*(code *)puVar1[2])(0,1,puVar1[5]);\n          puVar4[0x1e] = lVar5;\n          if (lVar5 == -1) {\n            iVar2 = 0xf;\n            goto LAB_0010154b;\n          }\n          puVar4[0x20] = puVar4[0x22] * puVar4[0x23] + lVar5;\n        }\n        iVar2 = dta_read_strls(puVar4);\n        if ((iVar2 == 0) && (iVar2 = dta_read_data(puVar4), iVar2 == 0)) {\n          iVar2 = dta_handle_value_labels(puVar4);\n        }\n      }\n      goto LAB_0010154b;\n    }\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 500) = 0x656c696620666f;\n    uVar8 = 0x207472617473206f;\n  }\n  iVar2 = 0xf;\n  *(undefined8 *)((long)puVar4 + 0x1ec) = uVar8;\n  *(undefined8 *)((long)puVar4 + 0x1e4) = 0x74206b656573206f;\n  *(undefined8 *)((long)puVar4 + 0x1dc) = 0x742064656c696146;\n  (*pcVar7)((long)puVar4 + 0x1dc,puVar4[0x39]);\nLAB_0010154b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if (puVar4 != (undefined8 *)0x0) {\n    dta_ctx_free(puVar4);\n  }\n  return iVar2;\n}\n\n",
        "function_pr": "\nint readstat_parse_dta(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long lVar6;\n  code *pcVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  long lVar10;\n  uint uVar11;\n  int local_94;\n  undefined8 local_90;\n  ulong local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  long local_70;\n  undefined4 local_68;\n  undefined4 local_64;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar4 = (undefined8 *)dta_ctx_alloc(puVar1);\n  iVar2 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar2 == -1) {\n    iVar2 = 1;\n    goto LAB_0010154b;\n  }\n  lVar5 = (*(code *)puVar1[3])(&local_94,4,puVar1[5]);\n  iVar2 = 2;\n  if (lVar5 != 4) goto LAB_0010154b;\n  lVar5 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n  if (lVar5 == -1) {\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 0x1f2) = 0x656c696620666f;\n    uVar8 = 0x666f20646e65206f;\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    if (lVar6 != -1) {\n      if (local_94 == 0x6174733c) {\n        iVar2 = dta_read_xmlish_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88;\n        uVar11 = local_90._4_4_;\n      }\n      else {\n        iVar2 = dta_read_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88 & 0xffffffff;\n        uVar11 = (uint)local_90._4_2_;\n      }\n      iVar2 = dta_ctx_init(puVar4,uVar11,uVar9,local_90._1_1_,local_90 & 0xff,param_1[9],param_1[10]\n                          );\n      if (iVar2 != 0) goto LAB_0010154b;\n      puVar4[0x39] = param_3;\n      puVar4[0x38] = lVar5;\n      puVar4[0x37] = param_1[7];\n      puVar4[0x36] = param_1[6];\n      puVar4[0x35] = param_1[5];\n      puVar4[0x34] = param_1[4];\n      puVar4[0x33] = param_1[3];\n      puVar4[0x32] = param_1[2];\n      uVar8 = *param_1;\n      puVar4[0x31] = param_1[1];\n      puVar4[0x30] = uVar8;\n      lVar5 = param_1[0xc];\n      if (lVar5 < 1) {\n        lVar5 = puVar4[0x25];\n      }\n      else {\n        puVar4[0x25] = lVar5;\n      }\n      lVar5 = puVar4[0x22] - lVar5;\n      if (lVar5 < 0) {\n        puVar4[0x25] = puVar4[0x22];\n        lVar5 = 0;\n      }\n      lVar6 = param_1[0xb];\n      lVar10 = lVar5;\n      if (lVar6 < lVar5) {\n        lVar10 = lVar6;\n      }\n      if (lVar6 < 1) {\n        lVar10 = lVar5;\n      }\n      puVar4[0x24] = lVar10;\n      iVar2 = dta_update_progress(puVar4);\n      if (((iVar2 != 0) || (iVar2 = dta_read_label_and_timestamp(puVar4), iVar2 != 0)) ||\n         (iVar2 = dta_read_tag(puVar4,\"</header>\"), iVar2 != 0)) goto LAB_0010154b;\n      if ((code *)puVar4[0x30] != (code *)0x0) {\n        local_90 = puVar4[0x24];\n        local_88 = (ulong)*(int *)((long)puVar4 + 0x10c);\n        local_80 = puVar4[3];\n        local_70 = (long)*(int *)(puVar4 + 0x21);\n        local_68 = 0;\n        local_64 = *(undefined4 *)(puVar4 + 0x2e);\n        local_60 = 0;\n        local_58 = *puVar4;\n        local_50 = 0;\n        local_48 = 0x75 < local_70;\n        local_40 = 0;\n        local_38 = 0;\n        local_78 = local_80;\n        iVar3 = (*(code *)puVar4[0x30])(&local_90,param_3);\n        iVar2 = 4;\n        if (iVar3 != 0) goto LAB_0010154b;\n      }\n      iVar3 = dta_read_map(puVar4);\n      iVar2 = 2;\n      if ((iVar3 != 0) || (iVar2 = dta_read_descriptors(puVar4), iVar2 != 0)) goto LAB_0010154b;\n      if (*(int *)((long)puVar4 + 0x10c) < 1) {\nLAB_00101689:\n        if (0 < (long)puVar4[0x22]) goto LAB_00101693;\n      }\n      else {\n        lVar5 = 0;\n        do {\n          iVar2 = dta_type_info(*(undefined2 *)(puVar4[7] + lVar5 * 2),puVar4,&local_90,0);\n          if (iVar2 != 0) goto LAB_0010154b;\n          puVar4[0x23] = puVar4[0x23] + local_90;\n          lVar5 = lVar5 + 1;\n        } while (lVar5 < *(int *)((long)puVar4 + 0x10c));\n        if (*(int *)((long)puVar4 + 0x10c) < 1) goto LAB_00101689;\nLAB_00101693:\n        if (puVar4[0x23] == 0) {\n          iVar2 = 5;\n          goto LAB_0010154b;\n        }\n      }\n      iVar2 = dta_handle_variables(puVar4);\n      if ((iVar2 == 0) && (iVar2 = dta_read_expansion_fields(puVar4), iVar2 == 0)) {\n        if ((*(byte *)(puVar4 + 0x27) & 4) == 0) {\n          lVar5 = (*(code *)puVar1[2])(0,1,puVar1[5]);\n          puVar4[0x1e] = lVar5;\n          if (lVar5 == -1) {\n            iVar2 = 0xf;\n            goto LAB_0010154b;\n          }\n          puVar4[0x20] = puVar4[0x22] * puVar4[0x23] + lVar5;\n        }\n        iVar2 = dta_read_strls(puVar4);\n        if ((iVar2 == 0) && (iVar2 = dta_read_data(puVar4), iVar2 == 0)) {\n          iVar2 = dta_handle_value_labels(puVar4);\n        }\n      }\n      goto LAB_0010154b;\n    }\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 500) = 0x656c696620666f;\n    uVar8 = 0x207472617473206f;\n  }\n  iVar2 = 0xf;\n  *(undefined8 *)((long)puVar4 + 0x1ec) = uVar8;\n  *(undefined8 *)((long)puVar4 + 0x1e4) = 0x74206b656573206f;\n  *(undefined8 *)((long)puVar4 + 0x1dc) = 0x742064656c696146;\n  (*pcVar7)((long)puVar4 + 0x1dc,puVar4[0x39]);\nLAB_0010154b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if (puVar4 != (undefined8 *)0x0) {\n    dta_ctx_free(puVar4);\n  }\n  return iVar2;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  if(call(, )){\n    \n    goto label\n  }\n  \n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , )\n  if(){\n    if(){\n      call(, , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    if(){\n      call(, , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(call(, )){\n      goto label\n    }\n    call(, , , , , , )\n  }else{\n    \n    if(call(, )){\n      goto label\n    }\n    call(, , , , , , )\n  }\n  if(){\n    goto label\n  }\n  \n  \n  \n  if()\n  \n  if(){\n    \n    \n  }\n  \n  if()\n  call()\n  if()goto label\n  if(call())goto label\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(call(, )){\n      \n      goto label\n    }\n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  for(;;){\n    \n    if(call(, , , ))goto label\n    \n  }\n  if(){\n    \n    goto label\n  }\n  if(call())goto label\n  if(call())goto label\n  if(){\n    call(, , )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call())goto label\n  if(call())goto label\n  if(call())goto label\n  call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  if(){\n    \n    goto label\n  }\n  call(, , )\n  \n  if()goto label\n  call(, , )\n  if(){\n    \n    \n    if()goto label\n    \n    \n  }else{\n    call(, , )\n    if(){\n      if(){\n        call(, )\n        if()goto label\n        \n        \n      }else{\n        call(, )\n        if()goto label\n        \n        \n      }\n      call(, , , , , , )\n      if()goto label\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      if(){\n        \n      }else{\n        \n      }\n      \n      if(){\n        \n        \n      }\n      \n      \n      if(){\n        \n      }\n      if(){\n        \n      }\n      \n      call()\n      if(call()call(, ))goto label\n      if(){\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        call(, )\n        \n        if()goto label\n      }\n      call()\n      \n      if(call())goto label\n      if(){\n        if()goto label\n      }else{\n        \n        do{\n          call(, , , )\n          if()goto label\n          \n          \n        }while()\n        if()goto label\n        if(){\n          \n          goto label\n        }\n      }\n      call()\n      if(call()){\n        if(){\n          call(, , )\n          \n          if(){\n            \n            goto label\n          }\n          \n        }\n        call()\n        if(call()){\n          call()\n        }\n      }\n      goto label\n    }\n    \n    \n    if()goto label\n    \n    \n  }\n  \n  \n  \n  \n  call(, )\n  call()\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  if(){\n    \n    goto label\n  }\n  call(, , )\n  \n  if()goto label\n  call(, , )\n  if(){\n    \n    \n    if()goto label\n    \n    \n  }else{\n    call(, , )\n    if(){\n      if(){\n        call(, )\n        if()goto label\n        \n        \n      }else{\n        call(, )\n        if()goto label\n        \n        \n      }\n      call(, , , , , , )\n      if()goto label\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      if(){\n        \n      }else{\n        \n      }\n      \n      if(){\n        \n        \n      }\n      \n      \n      if(){\n        \n      }\n      if(){\n        \n      }\n      \n      call()\n      if(call()call(, ))goto label\n      if(){\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        call(, )\n        \n        if()goto label\n      }\n      call()\n      \n      if(call())goto label\n      if(){\n        if()goto label\n      }else{\n        \n        do{\n          call(, , , )\n          if()goto label\n          \n          \n        }while()\n        if()goto label\n        if(){\n          \n          goto label\n        }\n      }\n      call()\n      if(call()){\n        if(){\n          call(, , )\n          \n          if(){\n            \n            goto label\n          }\n          \n        }\n        call()\n        if(call()){\n          call()\n        }\n      }\n      goto label\n    }\n    \n    \n    if()goto label\n    \n    \n  }\n  \n  \n  \n  \n  call(, )\n  call()\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.6875,
          "base_ppl": 4.0625,
          "pr_ppl": 4.0625,
          "source_ast_ppl": 5.28125,
          "base_ast_ppl": 10.9375,
          "pr_ast_ppl": 10.9375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more readable and follows standard C conventions while maintaining semantic equivalence. It organizes the code into logical sections, uses standard variable names, and avoids non-standard constructs like 'undefined8 *'. While Candidate A is a direct port, B's structure and variable choices make it cleaner and more maintainable.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      }
    ],
    "llama3.1": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.34375,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.359375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its clear and structured control flow, use of standard C idioms, and correct variable and type recovery.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "### Comparison of Control Flow Skeletons\n\nAfter analyzing the two control flow skeletons, we can conclude that Candidate A is the winner.\n\n### Motivation\n\nCandidate A is the winner because it correctly identifies the `ForLoop` in the source code, whereas Candidate B incorrectly uses `goto` statements to simulate the loop. Additionally, Candidate A has less unnecessary nesting levels and does not use `goto` statements unnecessarily.\n\n### Winner\n\n*   **winner**: A"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.34375,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.359375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its well-structured control flow, clear variable naming, and idiomatic C usage, despite minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch(*(undefined *)(param_2 + 3)) {\n    case 1:\n      local_28 = (long)(char)param_3;\n      break;\n    case 2:\n    case 7:\n    case 10:\n      local_28 = (long)(short)param_3;\n      break;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x29:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      local_28 = (long)(int)param_3;\n      break;\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",*(undefined *)(param_2 + 3));\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.390625,
          "base_ppl": 2.40625,
          "pr_ppl": 1.921875,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 2.078125,
          "pr_ast_ppl": 2.078125,
          "delta_ppl": -0.484375
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses standard switch-case logic and clean variable naming, making it more idiomatic C and easier to understand, despite having a minor bug, whereas Candidate A uses undefined types and magic numbers, making it harder to comprehend.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar3 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(local_18 + 1));\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = *(byte *)local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(local_28 + 5));\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(local_28 + 6));\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar3) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)*(byte *)local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              bVar1 = *(byte *)local_28;\n              bVar2 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)bVar1 + (uint)bVar2 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)*(byte *)local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)*(byte *)(local_78 + 1));\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(local_28 + 1));\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)*(byte *)local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 !=\n                       0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)*(byte *)(local_28 + 1) +\n                       (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar3 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            \n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), , , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  \n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.5625,
          "pr_ast_ppl": 2.609375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its clear and structured control flow, proper use of standard C constructs, and consistent variable naming conventions, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop structure while B used while-goto.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B's use of a more structured approach with a clear separation of concerns and a consistent use of labels and variables makes it more human-readable and easier to understand, even though it has minor inaccuracies. In contrast, Candidate A's code is a direct translation of the original assembly code and is harder to follow.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 3.78125,
          "pr_ast_ppl": 3.78125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B's clean structure and use of standard loops (e.g., while) make it more human-readable and easier to understand than Candidate A's spaghetti code with multiple gotos.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.359375,
          "pr_ppl": 2.34375,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 3.78125,
          "pr_ast_ppl": 3.78125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and structurally sound due to its use of standard loops and clean logic, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.03125,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.84375,
          "pr_ast_ppl": 2.84375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.046875,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 3.40625,
          "pr_ast_ppl": 3.40625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a more idiomatic and structured approach, using standard loops and conditional statements, making it easier to understand and maintain, whereas Candidate A uses goto statements extensively, resulting in a more complex and harder-to-follow code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.765625,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 3.796875,
          "pr_ast_ppl": 3.796875,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a more linear and structured control flow, with clear and standard loop constructs, making it more human-readable and easier to understand.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.765625,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 3.796875,
          "pr_ast_ppl": 3.796875,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its clear and structured use of control flow, loops, and logic, even though it has minor inaccuracies, whereas Candidate A is a more direct translation of the original code with many gotos.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 4.28125,
          "pr_ast_ppl": 4.28125,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and has a cleaner logic structure, even though it has minor inaccuracies in the switch-case statement, which is preferred over the spaghetti code in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 4.28125,
          "pr_ast_ppl": 4.28125,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate as it uses standard loops and clean logic, making it easier to understand and maintain, even if it has minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_zsav_read_compressed_data-O0.so",
        "function": "zsav_read_compressed_data",
        "source_code": "readstat_error_t zsav_read_compressed_data(sav_ctx_t *ctx,\n        readstat_error_t (*row_handler)(unsigned char *, size_t, sav_ctx_t *)) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = ctx->io;\n    readstat_off_t data_offset = 0;\n\n    size_t uncompressed_row_len = ctx->var_offset * 8;\n    readstat_off_t uncompressed_offset = 0;\n    unsigned char *uncompressed_row = NULL;\n\n    uLongf uncompressed_block_len = 0;\n    unsigned char *compressed_block = NULL, *uncompressed_block = NULL;\n\n    struct sav_row_stream_s state = { \n        .missing_value = ctx->missing_double,\n        .bias = ctx->bias,\n        .bswap = ctx->bswap };\n\n    struct zheader zheader;\n    struct ztrailer ztrailer;\n    struct ztrailer_entry *ztrailer_entries = NULL;\n\n    int n_blocks = 0;\n    int block_i = 0;\n    int i;\n\n    if (io->read(&zheader, sizeof(struct zheader), io->io_ctx) < sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    zheader.zheader_ofs = ctx->bswap ? byteswap8(zheader.zheader_ofs) : zheader.zheader_ofs;\n    zheader.ztrailer_ofs = ctx->bswap ? byteswap8(zheader.ztrailer_ofs) : zheader.ztrailer_ofs;\n    zheader.ztrailer_len = ctx->bswap ? byteswap8(zheader.ztrailer_len) : zheader.ztrailer_len;\n\n    if (zheader.zheader_ofs != io->seek(0, READSTAT_SEEK_CUR, io->io_ctx) - sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    n_blocks = (zheader.ztrailer_len - 24) / 24;\n\n    if (io->seek(zheader.ztrailer_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->read(&ztrailer, sizeof(struct ztrailer), io->io_ctx) < sizeof(struct ztrailer)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ztrailer.bias = ctx->bswap ? byteswap8(ztrailer.bias) : ztrailer.bias;\n    ztrailer.zero = ctx->bswap ? byteswap8(ztrailer.zero) : ztrailer.zero;\n    ztrailer.block_size = ctx->bswap ? byteswap4(ztrailer.block_size) : ztrailer.block_size;\n    ztrailer.n_blocks = ctx->bswap ? byteswap4(ztrailer.n_blocks) : ztrailer.n_blocks;\n\n    if (n_blocks != ztrailer.n_blocks) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    if (n_blocks && (ztrailer_entries = readstat_malloc(n_blocks * sizeof(struct ztrailer_entry))) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (io->read(ztrailer_entries, n_blocks * sizeof(struct ztrailer_entry), io->io_ctx) < \n            n_blocks * sizeof(struct ztrailer_entry)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    for (i=0; i<n_blocks; i++) {\n        struct ztrailer_entry *entry = &ztrailer_entries[i];\n\n        entry->uncompressed_ofs = ctx->bswap ? byteswap8(entry->uncompressed_ofs) : entry->uncompressed_ofs;\n        entry->compressed_ofs = ctx->bswap ? byteswap8(entry->compressed_ofs) : entry->compressed_ofs;\n        entry->uncompressed_size = ctx->bswap ? byteswap4(entry->uncompressed_size) : entry->uncompressed_size;\n        entry->compressed_size = ctx->bswap ? byteswap4(entry->compressed_size) : entry->compressed_size;\n    }\n\n    if (uncompressed_row_len && (uncompressed_row = readstat_malloc(uncompressed_row_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    while (1) {\n        if (block_i == n_blocks)\n            goto cleanup;\n\n        struct ztrailer_entry *entry = &ztrailer_entries[block_i];\n        if (io->seek(entry->compressed_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n            retval = READSTAT_ERROR_SEEK;\n            goto cleanup;\n        }\n        if ((compressed_block = readstat_realloc(compressed_block, entry->compressed_size)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if (io->read(compressed_block, entry->compressed_size, io->io_ctx) != entry->compressed_size) {\n            retval = READSTAT_ERROR_READ;\n            goto cleanup;\n        }\n\n        uncompressed_block_len = entry->uncompressed_size;\n        if ((uncompressed_block = readstat_realloc(uncompressed_block, uncompressed_block_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        int status = uncompress(uncompressed_block, &uncompressed_block_len,\n                compressed_block, entry->compressed_size);\n        if (status != Z_OK || uncompressed_block_len != entry->uncompressed_size) {\n            retval = READSTAT_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        block_i++;\n        state.status = SAV_ROW_STREAM_HAVE_DATA;\n        data_offset = 0;\n\n        while (state.status != SAV_ROW_STREAM_NEED_DATA) {\n            state.next_in = &uncompressed_block[data_offset];\n            state.avail_in = uncompressed_block_len - data_offset;\n\n            state.next_out = &uncompressed_row[uncompressed_offset];\n            state.avail_out = uncompressed_row_len - uncompressed_offset;\n\n            sav_decompress_row(&state);\n\n            uncompressed_offset = uncompressed_row_len - state.avail_out;\n            data_offset = uncompressed_block_len - state.avail_in;\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ROW) {\n                retval = row_handler(uncompressed_row, uncompressed_row_len, ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                uncompressed_offset = 0;\n            }\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ALL)\n                goto cleanup;\n            if (ctx->row_limit > 0 && ctx->current_row == ctx->row_limit)\n                goto cleanup;\n        }\n    }\n\ncleanup:\n    if (uncompressed_row)\n        free(uncompressed_row);\n    if (ztrailer_entries)\n        free(ztrailer_entries);\n    if (compressed_block)\n        free(compressed_block);\n    if (uncompressed_block)\n        free(uncompressed_block);\n\n    return retval;\n}\n",
        "function_base": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined1 auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined1 auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "function_pr": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(){\n    \n    goto label\n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  for(;;){\n    \n    (? call(): )\n    (? call(): )\n    (? call(): )\n    (? call(): )\n  }\n  if(call()){\n    \n    goto label\n  }\n  while(){\n    if()goto label\n    \n    if(call(, , )){\n      \n      goto label\n    }\n    if(call(, )){\n      \n      goto label\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    \n    if(call(, )){\n      \n      goto label\n    }\n    call(, , , )\n    if(){\n      \n      goto label\n    }\n    \n    \n    \n    while(){\n      \n      \n      \n      \n      call()\n      \n      \n      if(){\n        call(, , )\n        if()goto label\n        \n      }\n      if()goto label\n      if()goto label\n    }\n  }\n  if()call()\n  if()call()\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.9609375,
          "base_ppl": 1.7265625,
          "pr_ppl": 1.71875,
          "source_ast_ppl": 2.84375,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.46875,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.25,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 3.78125,
          "pr_ast_ppl": 3.78125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    do{\n      \n      \n      switch(){\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          \n          \n          \n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          goto label\n        case :\n          \n        case :\n          \n          \n          \n          if(){\n            return\n          }\n      }\n      if(){\n        return\n      }\n      \n      \n      \n      \n      \n    }while()\n    if(){\n      \n      \n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.09375,
          "pr_ppl": 1.9921875,
          "source_ast_ppl": 13.8125,
          "base_ast_ppl": 3.890625,
          "pr_ast_ppl": 3.46875,
          "delta_ppl": -0.1015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    do{\n      \n      \n      switch(){\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          \n          \n          \n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          goto label\n        case :\n          \n        case :\n          \n          \n          \n          if(){\n            return\n          }\n      }\n      if(){\n        return\n      }\n      \n      \n      \n      \n      \n    }while()\n    if(){\n      \n      \n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.09375,
          "pr_ppl": 1.9921875,
          "source_ast_ppl": 13.8125,
          "base_ast_ppl": 3.890625,
          "pr_ast_ppl": 3.46875,
          "delta_ppl": -0.1015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its clean and idiomatic use of loops and conditionals, despite minor inaccuracies, whereas Candidate A and the Ground Truth are convoluted with multiple gotos and complex logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto and had deeper nesting",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.359375,
          "pr_ppl": 2.34375,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 3.625,
          "pr_ast_ppl": 3.625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more idiomatic C and standard control structures, making it easier to understand and maintain, despite having minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O0.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined1 local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined1 local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined1 local_208 [60];\n  undefined1 auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined local_208 [60];\n  undefined auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            \n                            \n                            goto label\n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            \n                            \n                            goto label\n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.296875,
          "pr_ppl": 2.296875,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate because it uses a more standard and structured approach to handle different error conditions and file operations, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_ctx_init-O0.so",
        "function": "dta_ctx_init",
        "source_code": "readstat_error_t dta_ctx_init(dta_ctx_t *ctx, uint32_t nvar, uint64_t nobs,\n        unsigned char byteorder, unsigned char ds_format,\n        const char *input_encoding, const char *output_encoding) {\n    readstat_error_t retval = READSTAT_OK;\n    int machine_byteorder = DTA_HILO;\n    if (ds_format < DTA_MIN_VERSION || ds_format > DTA_MAX_VERSION)\n        return READSTAT_ERROR_UNSUPPORTED_FILE_FORMAT_VERSION;\n\n    if (machine_is_little_endian()) {\n        machine_byteorder = DTA_LOHI;\n    }\n\n    ctx->bswap = (byteorder != machine_byteorder);\n    ctx->ds_format = ds_format;\n    ctx->endianness = byteorder == DTA_LOHI ? READSTAT_ENDIAN_LITTLE : READSTAT_ENDIAN_BIG;\n\n    ctx->nvar = nvar;\n    ctx->nobs = nobs;\n\n    if (ctx->nvar) {\n        if ((ctx->variables = readstat_calloc(ctx->nvar, sizeof(readstat_variable_t *))) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->machine_is_twos_complement = READSTAT_MACHINE_IS_TWOS_COMPLEMENT;\n\n    if (ds_format < 105) {\n        ctx->fmtlist_entry_len = 7;\n    } else if (ds_format < 114) {\n        ctx->fmtlist_entry_len = 12;\n    } else if (ds_format < 118) {\n        ctx->fmtlist_entry_len = 49;\n    } else {\n        ctx->fmtlist_entry_len = 57;\n    }\n    \n    if (ds_format >= 117) {\n        ctx->typlist_version = 117;\n    } else if (ds_format >= 111) {\n        ctx->typlist_version = 111;\n    } else {\n        ctx->typlist_version = 0;\n    }\n\n    if (ds_format >= 118) {\n        ctx->data_label_len_len = 2;\n        ctx->strl_v_len = 2;\n        ctx->strl_o_len = 6;\n    } else if (ds_format >= 117) {\n        ctx->data_label_len_len = 1;\n        ctx->strl_v_len = 4;\n        ctx->strl_o_len = 4;\n    }\n\n    if (ds_format < 105) {\n        ctx->expansion_len_len = 0;\n    } else if (ds_format < 110) {\n        ctx->expansion_len_len = 2;\n    } else {\n        ctx->expansion_len_len = 4;\n    }\n    \n    if (ds_format < 110) {\n        ctx->lbllist_entry_len = 9;\n        ctx->variable_name_len = 9;\n        ctx->ch_metadata_len = 9;\n    } else if (ds_format < 118) {\n        ctx->lbllist_entry_len = 33;\n        ctx->variable_name_len = 33;\n        ctx->ch_metadata_len = 33;\n    } else {\n        ctx->lbllist_entry_len = 129;\n        ctx->variable_name_len = 129;\n        ctx->ch_metadata_len = 129;\n    }\n\n    if (ds_format < 108) {\n        ctx->variable_labels_entry_len = 32;\n        ctx->data_label_len = 32;\n    } else if (ds_format < 118) {\n        ctx->variable_labels_entry_len = 81;\n        ctx->data_label_len = 81;\n    } else {\n        ctx->variable_labels_entry_len = 321;\n        ctx->data_label_len = 321;\n    }\n\n    if (ds_format < 105) {\n        ctx->timestamp_len = 0;\n        ctx->value_label_table_len_len = 2;\n        ctx->value_label_table_labname_len = 12;\n        ctx->value_label_table_padding_len = 2;\n    } else {\n        ctx->timestamp_len = 18;\n        ctx->value_label_table_len_len = 4;\n        if (ds_format < 118) {\n            ctx->value_label_table_labname_len = 33;\n        } else {\n            ctx->value_label_table_labname_len = 129;\n        }\n        ctx->value_label_table_padding_len = 3;\n    }\n\n    if (ds_format < 117) {\n        ctx->typlist_entry_len = 1;\n        ctx->file_is_xmlish = 0;\n    } else {\n        ctx->typlist_entry_len = 2;\n        ctx->file_is_xmlish = 1;\n    }\n\n    if (ds_format < 113) {\n        ctx->max_int8 = DTA_OLD_MAX_INT8;\n        ctx->max_int16 = DTA_OLD_MAX_INT16;\n        ctx->max_int32 = DTA_OLD_MAX_INT32;\n        ctx->max_float = DTA_OLD_MAX_FLOAT;\n        ctx->max_double = DTA_OLD_MAX_DOUBLE;\n    } else {\n        ctx->max_int8 = DTA_113_MAX_INT8;\n        ctx->max_int16 = DTA_113_MAX_INT16;\n        ctx->max_int32 = DTA_113_MAX_INT32;\n        ctx->max_float = DTA_113_MAX_FLOAT;\n        ctx->max_double = DTA_113_MAX_DOUBLE;\n\n        ctx->supports_tagged_missing = 1;\n    }\n\n    if (output_encoding) {\n        if (input_encoding) {\n            ctx->converter = iconv_open(output_encoding, input_encoding);\n        } else if (ds_format < 118) {\n            ctx->converter = iconv_open(output_encoding, \"WINDOWS-1252\");\n        } else if (strcmp(output_encoding, \"UTF-8\") != 0) {\n            ctx->converter = iconv_open(output_encoding, \"UTF-8\");\n        }\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n\n    if (ds_format < 119) {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int16_t);\n    } else {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int32_t);\n    }\n\n    if ((ctx->srtlist = readstat_malloc(ctx->srtlist_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->nvar > 0) {\n        ctx->typlist_len = ctx->nvar * sizeof(uint16_t);\n        ctx->varlist_len = ctx->variable_name_len * ctx->nvar * sizeof(char);\n        ctx->fmtlist_len = ctx->fmtlist_entry_len * ctx->nvar * sizeof(char);\n        ctx->lbllist_len = ctx->lbllist_entry_len * ctx->nvar * sizeof(char);\n        ctx->variable_labels_len = ctx->variable_labels_entry_len * ctx->nvar * sizeof(char);\n\n        if ((ctx->typlist = readstat_malloc(ctx->typlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->varlist = readstat_malloc(ctx->varlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->fmtlist = readstat_malloc(ctx->fmtlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->lbllist = readstat_malloc(ctx->lbllist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->variable_labels = readstat_malloc(ctx->variable_labels_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->initialized = 1;\n\ncleanup:\n    return retval;\n}\n",
        "function_base": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined1 *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined1 *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined1 *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "function_pr": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "source_ast": "{\n  \n  \n  if()return\n  if(call()){\n    \n  }\n  \n  \n  (? : )\n  \n  \n  if(){\n    if(call(, )){\n      \n      goto label\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      call(, )\n    }elseif(){\n      call(, )\n    }elseif(call(, )){\n      call(, )\n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(){\n    \n    \n    \n    \n    \n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "metrics": {
          "source_ppl": 2.0,
          "base_ppl": 1.5625,
          "pr_ppl": 1.5625,
          "source_ast_ppl": 3.109375,
          "base_ast_ppl": 2.625,
          "pr_ast_ppl": 2.625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a more linear and structured control flow, using standard loop constructs and conditional statements, making it more human-readable and easier to understand.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O2.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined1 auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined1 local_608 [60];\n  undefined1 local_5cc [148];\n  undefined1 local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined local_608 [60];\n  undefined local_5cc [148];\n  undefined local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.609375,
          "pr_ppl": 2.609375,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its clean structure, clear variable names, and proper use of standard control flow, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O3.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined1 auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined1 local_608 [60];\n  undefined1 local_5cc [148];\n  undefined1 local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined local_608 [60];\n  undefined local_5cc [148];\n  undefined local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.609375,
          "pr_ppl": 2.609375,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its use of standard control flow structures and clean logic, outweighing minor inaccuracies compared to Candidate A's complex and hard-to-follow code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O0.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  uint uVar3;\n  int iVar4;\n  long lVar5;\n  int *local_60;\n  int local_3c;\n  \n  if (param_4 <= *param_3) {\n    return 10;\n  }\n  uVar1 = *param_3;\n  do {\n    local_3c = 0;\n    if (param_4 <= *param_3) goto LAB_001016a7;\n    switch(*param_1) {\n    case 0:\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      *param_1 = 1;\n      break;\n    case 1:\n      local_3c = lzma_vli_decode(param_1 + 0x46,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) goto LAB_001016a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      iVar4 = 2;\n      if (*(long *)(param_1 + 0x46) == 0) {\n        iVar4 = 4;\n      }\n      *param_1 = iVar4;\n      break;\n    case 2:\n    case 3:\n      if (*param_1 == 2) {\n        local_60 = param_1 + 0x48;\n      }\n      else {\n        local_60 = param_1 + 0x4a;\n      }\n      local_3c = lzma_vli_decode(local_60,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) {\nLAB_001016a7:\n        if (*param_3 - uVar1 != 0) {\n          iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n          param_1[0x4e] = iVar4;\n        }\n        return local_3c;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        if ((*(ulong *)(param_1 + 0x48) < 5) || (0x7ffffffffffffffc < *(ulong *)(param_1 + 0x48))) {\n          return 9;\n        }\n        *param_1 = 3;\n      }\n      else {\n        hash_append(param_1 + 0x24,*(undefined8 *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (((*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) ||\n            (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26))) ||\n           (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lVar5 = *(long *)(param_1 + 0x46);\n        *(long *)(param_1 + 0x46) = lVar5 + -1;\n        iVar4 = 2;\n        if (lVar5 + -1 == 0) {\n          iVar4 = 4;\n        }\n        *param_1 = iVar4;\n      }\n      break;\n    case 4:\n      lVar5 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      *(ulong *)(param_1 + 0x4c) = 4U - lVar5 & 3;\n      *param_1 = 5;\n    case 5:\n      if (*(long *)(param_1 + 0x4c) == 0) {\n        if (((*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) ||\n            (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26))) ||\n           (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar3 = lzma_check_size(10);\n        iVar4 = memcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar3);\n        if (iVar4 != 0) {\n          return 9;\n        }\n        iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n        param_1[0x4e] = iVar4;\n        *param_1 = 6;\nswitchD_001011ee_caseD_6:\n        while( true ) {\n          if (*param_3 == param_4) {\n            return 0;\n          }\n          uVar3 = param_1[0x4e];\n          lVar5 = *(long *)(param_1 + 0x4c);\n          uVar1 = *param_3;\n          *param_3 = uVar1 + 1;\n          if ((uVar3 >> ((byte)(lVar5 << 3) & 0x1f) & 0xff) != (uint)*(byte *)(param_2 + uVar1))\n          break;\n          lVar5 = *(long *)(param_1 + 0x4c);\n          *(ulong *)(param_1 + 0x4c) = lVar5 + 1U;\n          if (3 < lVar5 + 1U) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *(long *)(param_1 + 0x4c) = *(long *)(param_1 + 0x4c) + -1;\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      break;\n    case 6:\n      goto switchD_001011ee_caseD_6;\n    default:\n      return 0xb;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  uint uVar3;\n  int iVar4;\n  long lVar5;\n  int *local_60;\n  int local_3c;\n  \n  if (param_4 <= *param_3) {\n    return 10;\n  }\n  uVar1 = *param_3;\n  do {\n    local_3c = 0;\n    if (param_4 <= *param_3) goto LAB_001016a7;\n    switch(*param_1) {\n    case 0:\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      *param_1 = 1;\n      break;\n    case 1:\n      local_3c = lzma_vli_decode(param_1 + 0x46,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) goto LAB_001016a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      iVar4 = 2;\n      if (*(long *)(param_1 + 0x46) == 0) {\n        iVar4 = 4;\n      }\n      *param_1 = iVar4;\n      break;\n    case 2:\n    case 3:\n      if (*param_1 == 2) {\n        local_60 = param_1 + 0x48;\n      }\n      else {\n        local_60 = param_1 + 0x4a;\n      }\n      local_3c = lzma_vli_decode(local_60,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) {\nLAB_001016a7:\n        if (*param_3 - uVar1 != 0) {\n          iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n          param_1[0x4e] = iVar4;\n        }\n        return local_3c;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        if ((*(ulong *)(param_1 + 0x48) < 5) || (0x7ffffffffffffffc < *(ulong *)(param_1 + 0x48))) {\n          return 9;\n        }\n        *param_1 = 3;\n      }\n      else {\n        hash_append(param_1 + 0x24,*(undefined8 *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (((*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) ||\n            (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26))) ||\n           (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lVar5 = *(long *)(param_1 + 0x46);\n        *(long *)(param_1 + 0x46) = lVar5 + -1;\n        iVar4 = 2;\n        if (lVar5 + -1 == 0) {\n          iVar4 = 4;\n        }\n        *param_1 = iVar4;\n      }\n      break;\n    case 4:\n      lVar5 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      *(ulong *)(param_1 + 0x4c) = 4U - lVar5 & 3;\n      *param_1 = 5;\n    case 5:\n      if (*(long *)(param_1 + 0x4c) == 0) {\n        if (((*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) ||\n            (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26))) ||\n           (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar3 = lzma_check_size(10);\n        iVar4 = memcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar3);\n        if (iVar4 != 0) {\n          return 9;\n        }\n        iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n        param_1[0x4e] = iVar4;\n        *param_1 = 6;\nLAB_001015f6:\n        while( true ) {\n          if (*param_3 == param_4) {\n            return 0;\n          }\n          uVar3 = param_1[0x4e];\n          lVar5 = *(long *)(param_1 + 0x4c);\n          uVar1 = *param_3;\n          *param_3 = uVar1 + 1;\n          if ((uVar3 >> ((byte)(lVar5 << 3) & 0x1f) & 0xff) != (uint)*(byte *)(param_2 + uVar1))\n          break;\n          lVar5 = *(long *)(param_1 + 0x4c);\n          *(ulong *)(param_1 + 0x4c) = lVar5 + 1U;\n          if (3 < lVar5 + 1U) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *(long *)(param_1 + 0x4c) = *(long *)(param_1 + 0x4c) + -1;\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      break;\n    case 6:\n      goto LAB_001015f6;\n    default:\n      return 0xb;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  if()return\n  \n  \n  \n  \n  \n  while()switch(){\n    case :\n      \n      if()return\n      \n      \n    case :\n      {\n        call(, , , , )\n        if()goto label\n        \n        if()return\n        \n        \n        \n        (? : )\n        \n      }\n    case :\n    case :\n      {\n        (? : )\n        call(, , , , )\n        if()goto label\n        \n        \n        if(){\n          if()return\n          \n        }else{\n          \n          call(, , )\n          \n          \n          \n          \n          \n          \n          if()return\n          \n          (? : )\n        }\n        \n      }\n    case :\n      call()call(, )\n      \n      \n    case :\n      if(){\n        \n        if()return\n        \n      }\n      \n      if()return\n      \n      call(, )\n      call(, )\n      if(call(, , call()))return\n      \n      call(, , )\n      \n      \n    case :\n      do{\n        if()return\n        if(){\n          return\n        }\n      }while()\n      return\n    case :\n      \n      call()\n      return\n  }\n  {\n    \n    if()call(, , )\n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  \n  do{\n    \n    if()goto label\n    switch(){\n      case :\n        \n        \n        if(){\n          return\n        }\n        \n        \n      case :\n        call(, , , , )\n        if()goto label\n        if(){\n          return\n        }\n        \n        \n        \n        if(){\n          \n        }\n        \n        \n      case :\n      case :\n        if(){\n          \n        }else{\n          \n        }\n        call(, , , , )\n        if(){\n          if(){\n            call(, , )\n            \n          }\n          return\n        }\n        \n        \n        if(){\n          if(){\n            return\n          }\n          \n        }else{\n          call(, , )\n          if(){\n            return\n          }\n          \n          \n          \n          if(){\n            \n          }\n          \n        }\n        \n      case :\n        call(, )\n        \n        \n      case :\n        if(){\n          if(){\n            return\n          }\n          call(, )\n          call(, )\n          call()\n          call(, , )\n          if(){\n            return\n          }\n          call(, , )\n          \n          \n          while(){\n            if(){\n              return\n            }\n            \n            \n            \n            \n            if(call())\n            \n            \n            if(){\n              return\n            }\n          }\n          return\n        }\n        \n        \n        \n        if(){\n          return\n        }\n        \n      case :\n        goto label\n      case :\n        \n        return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  \n  do{\n    \n    if()goto label\n    switch(){\n      case :\n        \n        \n        if(){\n          return\n        }\n        \n        \n      case :\n        call(, , , , )\n        if()goto label\n        if(){\n          return\n        }\n        \n        \n        \n        if(){\n          \n        }\n        \n        \n      case :\n      case :\n        if(){\n          \n        }else{\n          \n        }\n        call(, , , , )\n        if(){\n          if(){\n            call(, , )\n            \n          }\n          return\n        }\n        \n        \n        if(){\n          if(){\n            return\n          }\n          \n        }else{\n          call(, , )\n          if(){\n            return\n          }\n          \n          \n          \n          if(){\n            \n          }\n          \n        }\n        \n      case :\n        call(, )\n        \n        \n      case :\n        if(){\n          if(){\n            return\n          }\n          call(, )\n          call(, )\n          call()\n          call(, , )\n          if(){\n            return\n          }\n          call(, , )\n          \n          \n          while(){\n            if(){\n              return\n            }\n            \n            \n            \n            \n            if(call())\n            \n            \n            if(){\n              return\n            }\n          }\n          return\n        }\n        \n        \n        \n        if(){\n          return\n        }\n        \n      case :\n        goto label\n      case :\n        \n        return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.15625,
          "base_ppl": 2.09375,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 5.4375,
          "base_ast_ppl": 3.859375,
          "pr_ast_ppl": 3.859375,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a more structured control flow and cleaner logic, making it easier to understand and maintain, despite minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_dta-O2.so",
        "function": "readstat_parse_dta",
        "source_code": "readstat_error_t readstat_parse_dta(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    int i;\n    dta_ctx_t    *ctx;\n    size_t file_size = 0;\n\n    ctx = dta_ctx_alloc(io);\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    char magic[4];\n    if (io->read(magic, 4, io->io_ctx) != 4) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx);\n    if (file_size == -1) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"Failed to seek to start of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (strncmp(magic, \"<sta\", 4) == 0) {\n        dta_header64_t header;\n        if ((retval = dta_read_xmlish_header(ctx, &header)) != READSTAT_OK) {\n            goto cleanup;\n        }\n        retval = dta_ctx_init(ctx, header.nvar, header.nobs, header.byteorder, header.ds_format,\n                parser->input_encoding, parser->output_encoding);\n    } else {\n        dta_header_t header;\n        if ((retval = dta_read_header(ctx, &header)) != READSTAT_OK) {\n            goto cleanup;\n        }\n        retval = dta_ctx_init(ctx, header.nvar, header.nobs, header.byteorder, header.ds_format,\n                parser->input_encoding, parser->output_encoding);\n    }\n    if (retval != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->user_ctx = user_ctx;\n    ctx->file_size = file_size;\n    ctx->handle = parser->handlers;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n    int64_t nobs_after_skipping = ctx->nobs - ctx->row_offset;\n    if (nobs_after_skipping < 0) {\n        nobs_after_skipping = 0;\n        ctx->row_offset = ctx->nobs;\n    }\n    ctx->row_limit = nobs_after_skipping;\n    if (parser->row_limit > 0 && parser->row_limit < nobs_after_skipping)\n        ctx->row_limit = parser->row_limit;\n\n    retval = dta_update_progress(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if ((retval = dta_read_label_and_timestamp(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_read_tag(ctx, \"</header>\")) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.metadata) {\n        readstat_metadata_t metadata = {\n            .row_count = ctx->row_limit,\n            .var_count = ctx->nvar,\n            .file_label = ctx->data_label,\n            .creation_time = ctx->timestamp,\n            .modified_time = ctx->timestamp,\n            .file_format_version = ctx->ds_format,\n            .is64bit = ctx->ds_format >= 118,\n            .endianness = ctx->endianness\n        };\n        if (ctx->handle.metadata(&metadata, user_ctx) != READSTAT_HANDLER_OK) {\n            retval = READSTAT_ERROR_USER_ABORT;\n            goto cleanup;\n        }\n    }\n\n    if ((retval = dta_read_map(ctx)) != READSTAT_OK) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    if ((retval = dta_read_descriptors(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    for (i=0; i<ctx->nvar; i++) {\n        size_t      max_len;\n        if ((retval = dta_type_info(ctx->typlist[i], ctx, &max_len, NULL)) != READSTAT_OK)\n            goto cleanup;\n\n        ctx->record_len += max_len;\n    }\n\n    if ((ctx->nvar > 0 || ctx->nobs > 0) && ctx->record_len == 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    if ((retval = dta_handle_variables(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_read_expansion_fields(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if (!ctx->file_is_xmlish) {\n        ctx->data_offset = io->seek(0, READSTAT_SEEK_CUR, io->io_ctx);\n        if (ctx->data_offset == -1) {\n            retval = READSTAT_ERROR_SEEK;\n            goto cleanup;\n        }\n        ctx->value_labels_offset = ctx->data_offset + ctx->record_len * ctx->nobs;\n    }\n\n    if ((retval = dta_read_strls(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_read_data(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_handle_value_labels(ctx)) != READSTAT_OK)\n        goto cleanup;\n\ncleanup:\n    io->close(io->io_ctx);\n    if (ctx)\n        dta_ctx_free(ctx);\n\n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_dta(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long lVar6;\n  code *pcVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  long lVar10;\n  uint uVar11;\n  int local_94;\n  undefined8 local_90;\n  ulong local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  long local_70;\n  undefined4 local_68;\n  undefined4 local_64;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined1 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar4 = (undefined8 *)dta_ctx_alloc(puVar1);\n  iVar2 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar2 == -1) {\n    iVar2 = 1;\n    goto LAB_0010154b;\n  }\n  lVar5 = (*(code *)puVar1[3])(&local_94,4,puVar1[5]);\n  iVar2 = 2;\n  if (lVar5 != 4) goto LAB_0010154b;\n  lVar5 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n  if (lVar5 == -1) {\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 0x1f2) = 0x656c696620666f;\n    uVar8 = 0x666f20646e65206f;\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    if (lVar6 != -1) {\n      if (local_94 == 0x6174733c) {\n        iVar2 = dta_read_xmlish_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88;\n        uVar11 = local_90._4_4_;\n      }\n      else {\n        iVar2 = dta_read_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88 & 0xffffffff;\n        uVar11 = (uint)local_90._4_2_;\n      }\n      iVar2 = dta_ctx_init(puVar4,uVar11,uVar9,local_90._1_1_,local_90 & 0xff,param_1[9],param_1[10]\n                          );\n      if (iVar2 != 0) goto LAB_0010154b;\n      puVar4[0x39] = param_3;\n      puVar4[0x38] = lVar5;\n      puVar4[0x37] = param_1[7];\n      puVar4[0x36] = param_1[6];\n      puVar4[0x35] = param_1[5];\n      puVar4[0x34] = param_1[4];\n      puVar4[0x33] = param_1[3];\n      puVar4[0x32] = param_1[2];\n      uVar8 = *param_1;\n      puVar4[0x31] = param_1[1];\n      puVar4[0x30] = uVar8;\n      lVar5 = param_1[0xc];\n      if (lVar5 < 1) {\n        lVar5 = puVar4[0x25];\n      }\n      else {\n        puVar4[0x25] = lVar5;\n      }\n      lVar5 = puVar4[0x22] - lVar5;\n      if (lVar5 < 0) {\n        puVar4[0x25] = puVar4[0x22];\n        lVar5 = 0;\n      }\n      lVar6 = param_1[0xb];\n      lVar10 = lVar5;\n      if (lVar6 < lVar5) {\n        lVar10 = lVar6;\n      }\n      if (lVar6 < 1) {\n        lVar10 = lVar5;\n      }\n      puVar4[0x24] = lVar10;\n      iVar2 = dta_update_progress(puVar4);\n      if (((iVar2 != 0) || (iVar2 = dta_read_label_and_timestamp(puVar4), iVar2 != 0)) ||\n         (iVar2 = dta_read_tag(puVar4,\"</header>\"), iVar2 != 0)) goto LAB_0010154b;\n      if ((code *)puVar4[0x30] != (code *)0x0) {\n        local_90 = puVar4[0x24];\n        local_88 = (ulong)*(int *)((long)puVar4 + 0x10c);\n        local_80 = puVar4[3];\n        local_70 = (long)*(int *)(puVar4 + 0x21);\n        local_68 = 0;\n        local_64 = *(undefined4 *)(puVar4 + 0x2e);\n        local_60 = 0;\n        local_58 = *puVar4;\n        local_50 = 0;\n        local_48 = 0x75 < local_70;\n        local_40 = 0;\n        local_38 = 0;\n        local_78 = local_80;\n        iVar3 = (*(code *)puVar4[0x30])(&local_90,param_3);\n        iVar2 = 4;\n        if (iVar3 != 0) goto LAB_0010154b;\n      }\n      iVar3 = dta_read_map(puVar4);\n      iVar2 = 2;\n      if ((iVar3 != 0) || (iVar2 = dta_read_descriptors(puVar4), iVar2 != 0)) goto LAB_0010154b;\n      if (*(int *)((long)puVar4 + 0x10c) < 1) {\nLAB_00101689:\n        if (0 < (long)puVar4[0x22]) goto LAB_00101693;\n      }\n      else {\n        lVar5 = 0;\n        do {\n          iVar2 = dta_type_info(*(undefined2 *)(puVar4[7] + lVar5 * 2),puVar4,&local_90,0);\n          if (iVar2 != 0) goto LAB_0010154b;\n          puVar4[0x23] = puVar4[0x23] + local_90;\n          lVar5 = lVar5 + 1;\n        } while (lVar5 < *(int *)((long)puVar4 + 0x10c));\n        if (*(int *)((long)puVar4 + 0x10c) < 1) goto LAB_00101689;\nLAB_00101693:\n        if (puVar4[0x23] == 0) {\n          iVar2 = 5;\n          goto LAB_0010154b;\n        }\n      }\n      iVar2 = dta_handle_variables(puVar4);\n      if ((iVar2 == 0) && (iVar2 = dta_read_expansion_fields(puVar4), iVar2 == 0)) {\n        if ((*(byte *)(puVar4 + 0x27) & 4) == 0) {\n          lVar5 = (*(code *)puVar1[2])(0,1,puVar1[5]);\n          puVar4[0x1e] = lVar5;\n          if (lVar5 == -1) {\n            iVar2 = 0xf;\n            goto LAB_0010154b;\n          }\n          puVar4[0x20] = puVar4[0x22] * puVar4[0x23] + lVar5;\n        }\n        iVar2 = dta_read_strls(puVar4);\n        if ((iVar2 == 0) && (iVar2 = dta_read_data(puVar4), iVar2 == 0)) {\n          iVar2 = dta_handle_value_labels(puVar4);\n        }\n      }\n      goto LAB_0010154b;\n    }\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 500) = 0x656c696620666f;\n    uVar8 = 0x207472617473206f;\n  }\n  iVar2 = 0xf;\n  *(undefined8 *)((long)puVar4 + 0x1ec) = uVar8;\n  *(undefined8 *)((long)puVar4 + 0x1e4) = 0x74206b656573206f;\n  *(undefined8 *)((long)puVar4 + 0x1dc) = 0x742064656c696146;\n  (*pcVar7)((long)puVar4 + 0x1dc,puVar4[0x39]);\nLAB_0010154b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if (puVar4 != (undefined8 *)0x0) {\n    dta_ctx_free(puVar4);\n  }\n  return iVar2;\n}\n\n",
        "function_pr": "\nint readstat_parse_dta(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long lVar6;\n  code *pcVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  long lVar10;\n  uint uVar11;\n  int local_94;\n  undefined8 local_90;\n  ulong local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  long local_70;\n  undefined4 local_68;\n  undefined4 local_64;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar4 = (undefined8 *)dta_ctx_alloc(puVar1);\n  iVar2 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar2 == -1) {\n    iVar2 = 1;\n    goto LAB_0010154b;\n  }\n  lVar5 = (*(code *)puVar1[3])(&local_94,4,puVar1[5]);\n  iVar2 = 2;\n  if (lVar5 != 4) goto LAB_0010154b;\n  lVar5 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n  if (lVar5 == -1) {\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 0x1f2) = 0x656c696620666f;\n    uVar8 = 0x666f20646e65206f;\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    if (lVar6 != -1) {\n      if (local_94 == 0x6174733c) {\n        iVar2 = dta_read_xmlish_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88;\n        uVar11 = local_90._4_4_;\n      }\n      else {\n        iVar2 = dta_read_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88 & 0xffffffff;\n        uVar11 = (uint)local_90._4_2_;\n      }\n      iVar2 = dta_ctx_init(puVar4,uVar11,uVar9,local_90._1_1_,local_90 & 0xff,param_1[9],param_1[10]\n                          );\n      if (iVar2 != 0) goto LAB_0010154b;\n      puVar4[0x39] = param_3;\n      puVar4[0x38] = lVar5;\n      puVar4[0x37] = param_1[7];\n      puVar4[0x36] = param_1[6];\n      puVar4[0x35] = param_1[5];\n      puVar4[0x34] = param_1[4];\n      puVar4[0x33] = param_1[3];\n      puVar4[0x32] = param_1[2];\n      uVar8 = *param_1;\n      puVar4[0x31] = param_1[1];\n      puVar4[0x30] = uVar8;\n      lVar5 = param_1[0xc];\n      if (lVar5 < 1) {\n        lVar5 = puVar4[0x25];\n      }\n      else {\n        puVar4[0x25] = lVar5;\n      }\n      lVar5 = puVar4[0x22] - lVar5;\n      if (lVar5 < 0) {\n        puVar4[0x25] = puVar4[0x22];\n        lVar5 = 0;\n      }\n      lVar6 = param_1[0xb];\n      lVar10 = lVar5;\n      if (lVar6 < lVar5) {\n        lVar10 = lVar6;\n      }\n      if (lVar6 < 1) {\n        lVar10 = lVar5;\n      }\n      puVar4[0x24] = lVar10;\n      iVar2 = dta_update_progress(puVar4);\n      if (((iVar2 != 0) || (iVar2 = dta_read_label_and_timestamp(puVar4), iVar2 != 0)) ||\n         (iVar2 = dta_read_tag(puVar4,\"</header>\"), iVar2 != 0)) goto LAB_0010154b;\n      if ((code *)puVar4[0x30] != (code *)0x0) {\n        local_90 = puVar4[0x24];\n        local_88 = (ulong)*(int *)((long)puVar4 + 0x10c);\n        local_80 = puVar4[3];\n        local_70 = (long)*(int *)(puVar4 + 0x21);\n        local_68 = 0;\n        local_64 = *(undefined4 *)(puVar4 + 0x2e);\n        local_60 = 0;\n        local_58 = *puVar4;\n        local_50 = 0;\n        local_48 = 0x75 < local_70;\n        local_40 = 0;\n        local_38 = 0;\n        local_78 = local_80;\n        iVar3 = (*(code *)puVar4[0x30])(&local_90,param_3);\n        iVar2 = 4;\n        if (iVar3 != 0) goto LAB_0010154b;\n      }\n      iVar3 = dta_read_map(puVar4);\n      iVar2 = 2;\n      if ((iVar3 != 0) || (iVar2 = dta_read_descriptors(puVar4), iVar2 != 0)) goto LAB_0010154b;\n      if (*(int *)((long)puVar4 + 0x10c) < 1) {\nLAB_00101689:\n        if (0 < (long)puVar4[0x22]) goto LAB_00101693;\n      }\n      else {\n        lVar5 = 0;\n        do {\n          iVar2 = dta_type_info(*(undefined2 *)(puVar4[7] + lVar5 * 2),puVar4,&local_90,0);\n          if (iVar2 != 0) goto LAB_0010154b;\n          puVar4[0x23] = puVar4[0x23] + local_90;\n          lVar5 = lVar5 + 1;\n        } while (lVar5 < *(int *)((long)puVar4 + 0x10c));\n        if (*(int *)((long)puVar4 + 0x10c) < 1) goto LAB_00101689;\nLAB_00101693:\n        if (puVar4[0x23] == 0) {\n          iVar2 = 5;\n          goto LAB_0010154b;\n        }\n      }\n      iVar2 = dta_handle_variables(puVar4);\n      if ((iVar2 == 0) && (iVar2 = dta_read_expansion_fields(puVar4), iVar2 == 0)) {\n        if ((*(byte *)(puVar4 + 0x27) & 4) == 0) {\n          lVar5 = (*(code *)puVar1[2])(0,1,puVar1[5]);\n          puVar4[0x1e] = lVar5;\n          if (lVar5 == -1) {\n            iVar2 = 0xf;\n            goto LAB_0010154b;\n          }\n          puVar4[0x20] = puVar4[0x22] * puVar4[0x23] + lVar5;\n        }\n        iVar2 = dta_read_strls(puVar4);\n        if ((iVar2 == 0) && (iVar2 = dta_read_data(puVar4), iVar2 == 0)) {\n          iVar2 = dta_handle_value_labels(puVar4);\n        }\n      }\n      goto LAB_0010154b;\n    }\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 500) = 0x656c696620666f;\n    uVar8 = 0x207472617473206f;\n  }\n  iVar2 = 0xf;\n  *(undefined8 *)((long)puVar4 + 0x1ec) = uVar8;\n  *(undefined8 *)((long)puVar4 + 0x1e4) = 0x74206b656573206f;\n  *(undefined8 *)((long)puVar4 + 0x1dc) = 0x742064656c696146;\n  (*pcVar7)((long)puVar4 + 0x1dc,puVar4[0x39]);\nLAB_0010154b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if (puVar4 != (undefined8 *)0x0) {\n    dta_ctx_free(puVar4);\n  }\n  return iVar2;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  if(call(, )){\n    \n    goto label\n  }\n  \n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , )\n  if(){\n    if(){\n      call(, , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    if(){\n      call(, , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(call(, )){\n      goto label\n    }\n    call(, , , , , , )\n  }else{\n    \n    if(call(, )){\n      goto label\n    }\n    call(, , , , , , )\n  }\n  if(){\n    goto label\n  }\n  \n  \n  \n  if()\n  \n  if(){\n    \n    \n  }\n  \n  if()\n  call()\n  if()goto label\n  if(call())goto label\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(call(, )){\n      \n      goto label\n    }\n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  for(;;){\n    \n    if(call(, , , ))goto label\n    \n  }\n  if(){\n    \n    goto label\n  }\n  if(call())goto label\n  if(call())goto label\n  if(){\n    call(, , )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call())goto label\n  if(call())goto label\n  if(call())goto label\n  call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  if(){\n    \n    goto label\n  }\n  call(, , )\n  \n  if()goto label\n  call(, , )\n  if(){\n    \n    \n    if()goto label\n    \n    \n  }else{\n    call(, , )\n    if(){\n      if(){\n        call(, )\n        if()goto label\n        \n        \n      }else{\n        call(, )\n        if()goto label\n        \n        \n      }\n      call(, , , , , , )\n      if()goto label\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      if(){\n        \n      }else{\n        \n      }\n      \n      if(){\n        \n        \n      }\n      \n      \n      if(){\n        \n      }\n      if(){\n        \n      }\n      \n      call()\n      if(call()call(, ))goto label\n      if(){\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        call(, )\n        \n        if()goto label\n      }\n      call()\n      \n      if(call())goto label\n      if(){\n        if()goto label\n      }else{\n        \n        do{\n          call(, , , )\n          if()goto label\n          \n          \n        }while()\n        if()goto label\n        if(){\n          \n          goto label\n        }\n      }\n      call()\n      if(call()){\n        if(){\n          call(, , )\n          \n          if(){\n            \n            goto label\n          }\n          \n        }\n        call()\n        if(call()){\n          call()\n        }\n      }\n      goto label\n    }\n    \n    \n    if()goto label\n    \n    \n  }\n  \n  \n  \n  \n  call(, )\n  call()\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  if(){\n    \n    goto label\n  }\n  call(, , )\n  \n  if()goto label\n  call(, , )\n  if(){\n    \n    \n    if()goto label\n    \n    \n  }else{\n    call(, , )\n    if(){\n      if(){\n        call(, )\n        if()goto label\n        \n        \n      }else{\n        call(, )\n        if()goto label\n        \n        \n      }\n      call(, , , , , , )\n      if()goto label\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      if(){\n        \n      }else{\n        \n      }\n      \n      if(){\n        \n        \n      }\n      \n      \n      if(){\n        \n      }\n      if(){\n        \n      }\n      \n      call()\n      if(call()call(, ))goto label\n      if(){\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        call(, )\n        \n        if()goto label\n      }\n      call()\n      \n      if(call())goto label\n      if(){\n        if()goto label\n      }else{\n        \n        do{\n          call(, , , )\n          if()goto label\n          \n          \n        }while()\n        if()goto label\n        if(){\n          \n          goto label\n        }\n      }\n      call()\n      if(call()){\n        if(){\n          call(, , )\n          \n          if(){\n            \n            goto label\n          }\n          \n        }\n        call()\n        if(call()){\n          call()\n        }\n      }\n      goto label\n    }\n    \n    \n    if()goto label\n    \n    \n  }\n  \n  \n  \n  \n  call(, )\n  call()\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.296875,
          "pr_ppl": 2.296875,
          "source_ast_ppl": 2.84375,
          "base_ast_ppl": 3.859375,
          "pr_ast_ppl": 3.859375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its use of standard loops and clean logic, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      }
    ],
    "gemma2": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.015625,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.03125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "```\n\n **The code above is a block of 100\n\n\n;\nbreak;\n}\n\n\n//\n```\n  return;\ngoto 0x3;\n\n\nif(u);\n\n\n\nreturn;\n\n\n```\n```\n\n**3**\n *43.210323\n *3*\n```\n\ngoto 0;\n*3*\ngoto 0;\nif(u)\n\nif(u)\n\n\n * 13.\nif (u)\n * 13.\n\nif(u)\n\n* 33\n* 13.\n\n; 123;\nif (u)\n * 123\n * 123\n* 123;\n\nif(u) * 123 * 123 * 123 * 123 * 123.\n\nif (u)\n\n\n\nif (u) * 123\n\nreturn;\nif (u) * 123;\n\n\nif (u)\nreturn;\n\nif (u)\nif (u)\n\n\n\nif (u)\nif (u)\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\nreturn;\n\nif (u)\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nif (u)\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\nif (u)\n\nreturn;\n\nreturn;\n\n\n\nreturn; return; return;\n\nreturn; return;\n\nif (u)\n\nreturn;\n\nreturn; return;\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\n\nif (u)\n\n\nreturn;\n\n\n\nif (u)\n\n\nreturn;\n\n\n\nif (u)\n\n\n\nif (u)\n\n)\nif (u)\n\n\nif (u)\n\n\nif (u)\n\nif (u)\n\n\nif (u)\n\n\n\n)\n\n\n\nif (u)\n\nif (u)\n\n\n\nif (u)\n\n\nif (u)\n\n\n\nif (u)\n\nreturn;\n\n\nif (u)\n\n\n)\n)\n\nreturn;\n\n\nif (u)\n\n)\n\n\nif (u)\n\n\nif (u)\n\n\n)\nif (u)\n\nreturn;\n\nif (u)\n\nreturn;\n\nif (u)\n\nreturn;\n\nif (u)\n\nif (u)\n\n\n\nif (u)\n\n\nif (u)\n\nif (u)\n\n)\n\n\n(u)\n\n\nif (u)\n\n)\n\n\nif (u)\n\nif (u)\n\n)\n\n\nif (u)\n\n\nif (u)\nif (u)\n\n)\n\nif (u)\n\n)\n\nreturn;\n\n\n)\nif (u)\n\nif (u)\n\n)\n\nreturn;\n\nif (u)\n\nif (u)\n\nif (u)\n\n)\n\nreturn;\n\n)\n\nreturn;\n\n)\n\nreturn;\n\n)\n\nreturn;\n\nif (u)\n\nreturn;\n\n)\n\nreturn;\n\n)\n\nreturn;\n\nreturn;\n\n)\n\nreturn;\n\nif (u)\n\n)\n\nreturn;\n\nif (u)\n\n)\n\nif (u)\n\n)\n\nif (u)\n\n)\n\nreturn;\n\nif (u)\n\n)\n\nreturn;\n\n)\n\nif (u)\n\n)\n\nreturn;\n\nif (u)\n\n)\n\nreturn;\n\nif (u)\n\n)\n\nif (u)\n\n)\n\nif (u)\n\n)\n\nif (u)\n\nif (u)\n\nif (u)\n\n)\n\nif (u)\n\nif (u)\n\nif (u)\n\n)\n\nif (u)\n\nif (u)\n\n)\n\nif (u)\n\nif (u)\n\n)\n\nreturn;\n\n)\n\nif (u)\n\nif (u)\n\nif (u)\n\n)\n\nreturn;\n\nif (u)\n\nif (u)\n\n)\n\nreturn;\n\nif (u)\n\n)\n\nreturn;\n\nif (u)\n\n)\n\nreturn;\n\nif (u)\n\n)\n\nif (u)\n\n)\n\nreturn;\n\nif (u)\n\n)\n\nif (u)\n\n)\n\nif (u)\n\n)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\n)\n\nif (u)\n\nif (u)\n\nif (u)\n\n)\n\nreturn;\n\nif (u)\n\nif (u)\n\n)\n\nreturn;\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\n)\n\nif (u)\n\n)\n\nif (u)\n\nif (u)\n\nif (u)\n\n)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\n)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\n)\n\nif (u)\n\n)\n\nif (u)\n\n)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\n10;\n\nif (u)\n\n10)\n\n53\n\n333\n\n333\n\n)\n\nif (u)\n\n10)\n\nif (u)\n\nif (u)\n\nif (u)\n\nif (u)\n\n10\n\n)\n\nif (u)\n\nif (u)\n\n)\n\n10\n\n10\n\n\nend;\n\n53.\n\n)\n\nif (u)\n\n10)\n\n)\n\nif (u)\n\n53\n\n333\n\n3\n\n)\n\n10\n\n)\n\nif (u)\n\nif (u)\n\nif (u)\n\n)\n\n101\n\n100\n\nif (u)\n\n101\n\n10\n\n10)\n\nif (u)\n\nif (u)\n\nif (u)\n\n101\n\n)\n\n\n*20\n\n)\n\nreturn;\n\n\n```\n\n```\n```\n\nif (u)\n\n*10\n\n)\n\n)\n\nif (u)\n\n10)\n\n)\n\nif (u)\n\n1\n\n```\nreturn;1)\n\n63);\n\n```\n\n\n\nreturn;\n\n1.16.\n\n\n3.\n\n\n);\n\nreturn;\n\n1)\n\n1)\n\nreturn;\n\n5.\n\n)\n\n*5\n\n))\n\n\n\nif(u)\n\n** ** **)\n\n\n\nif(u)\n\n\n3,\n\n\n * \n*\n\n\n**\n\n\n)\n\n\n)**\n)\n\n\n**5**,\n10,\n**30,\n5,53,10\n)\n\n**\n\n53,\n\n0)\n\n**10**\n\n\n * 103\n),0\n);\n\nif (u)\n\n)\n)\n\n10\n\n)\n\n10\n\n\n10)\n\n0\n5),\n\nif (u)\n\n1),\n\nif (u)\n\nreturn;\n\n5,\n\n),\n\n),\n\n1)\n\n\n)\n\nreturn;\n\nif (u)\n\n),\n\n0,\n\n0)\n\nreturn;\n\n)\n\nreturn;\n\n101\n\n)\n\n1)\n\nreturn;\n\n)\n\nreturn;\n\nreturn;\n\n101\n\nreturn);\n\nreturn\n\n)\n\n\nif (u)\n\nreturn;\n\n10),\n\n63,\n\n*0,\n\n),\n\n55\n\n10),\n\nreturn,\n\n10),\n\n**\n\n\n**\n**1055555\n1)\n\n105\n\n101)\n\n10100\n\n555555,10,\n\nc),\n\n1\n\n),\n\n)\n\n5,\n\n)\n\n**10**\n\nreturn;\n\n10\n\n),\n\n0\n\n100\n\n55555555\n\n),\n\n105\n\n)\n\n)\n\n\n"
        },
        "llm_ast": {
          "motivation": "Both candidates struggle to accurately represent the nested structure of the Source AST, but Candidate A more closely resembles the Source's nesting depth and sequence of blocks, particularly within the numerous conditional statements and loops.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.015625,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.03125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "\t\t\tgoto;\n\n\n  \n\treturn;\n}\n\n * *2;\n * *2;\n  goto\n  return;\n\n\n   if(u)\n\n    if(u)\n\n\n\n  break;\n}\n\n\n\nreturn;\n    if(u)\n    goto;\n    if(u)\n    return;\n\n    if(u)\n  return;\n\n  return;\n  \n  return;\n\n\nif(u)\nreturn;\n\nreturn;\n\n\n\nif(u)\n\nif(u)\n\n\nif(u)\n\n\n\n}\n\n}\nreturn;\n\n\n\nif(u)\n\n\n\nreturn;\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nreturn;\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\n\n\nreturn;\n\n\n32)\nif(u)\n\n\n\nreturn;\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\n\nreturn;\n\n\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\n\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\n\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\n110)\n\n13\n\n13.\n\nif(u)\n\n13.\n\nif(u)\n\nif(u)\n\n13\n\nif(u)\n\n13.\n\nif(u)\n\nif(u)\n\n13\n\n0,\n\n13\n\nif(u)\n\n13.\n\n13\n\n5);\n\n*153;\n\n13\n\n33\n\n33;\n\n)\nif(u)\n\n1\n\n*155\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\nif(u)\n\n1.005\n\n32\n\n\nif(u)\n\n\n320)\n\n5.33\n\n3.3\n\n\n00.1\n\n32)\n\n33\n\n50\n\n3.32\n\n33.1\n\n**0**\n\n53.3\n\n)\n\n\n\nreturn;\n\n)\n1;\n53.\n\n1.53\n\n\n)(u)\n\n\n\n)\n\n\n**5**\n\n*20\n\n000)\n\n\n3.\n\n32,\n\n0\n\n9),\n\n*5\n\n).\n\n* **\n\n* *\n\n\n\n*\n0\n\n5)\n\n32.\n\n63),\n\n38,\n\n2.\n\n61\n\n64.\n\n)\n\nreturn;\n\n15,\n\n)\n\nreturn;\n\n53\n\n3),\n\n).\n\nreturn;\n\n11\n\n,0\n\n63\n\n32,\n\n**\n\n)\n\n11),\n\n1.\n\n**\n\nreturn;\n\n53.\n\n1005\n\n53\n\n)\n0\n\n53.\n\n\n\n)\n\n\n)\n\n\n*\n\n\n\n*5555,5\n\n)\n\n*1\n\n600),\n(u,\n\n),\n\n*1\n\n14),\n\n(u)\n\n),\n\n(u)\n\n10\n\n1,150,116,510,\n\n),\n\n(u)\n\n1),\n\n(u)\n\n(u)\n\n),\n\n)\n\n55.1\n\n(u),\n\n555),\n\n20.\n\n10,\n\n000),\n\n11,\n\n((u)\n\n63)\n\n(u),\n\n1),\n\n*55\n\n),\n\n10,\n\n(u),\n\n**101** (u55),\n\n10,\n\n(u),\n\n0),\n\n(u),\n\n(u),\n\n10\n\n5),\n\n(u)\n\n**10554),\n\n**1012634),"
        },
        "llm_ast": {
          "motivation": "Both candidates struggled to accurately represent the nesting and loop structure of the source. However, Candidate A correctly identifies the nested `if` statements within the `switch` block, while Candidate B adds unnecessary nesting and uses `goto` statements excessively.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch(*(undefined *)(param_2 + 3)) {\n    case 1:\n      local_28 = (long)(char)param_3;\n      break;\n    case 2:\n    case 7:\n    case 10:\n      local_28 = (long)(short)param_3;\n      break;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x29:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      local_28 = (long)(int)param_3;\n      break;\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",*(undefined *)(param_2 + 3));\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "{\n  if(){\n    switch(){\n      \n      case :\n        call(, , )\n        \n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        call(, )\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if()call(, , )\n        return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  if(){\n    switch(){\n      case :\n        \n        \n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n        \n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n      case :\n        \n      case :\n        \n        if(){\n          call(, , )\n        }\n        return\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.875,
          "base_ppl": 2.046875,
          "pr_ppl": 1.7265625,
          "source_ast_ppl": 1.9609375,
          "base_ast_ppl": 1.921875,
          "pr_ast_ppl": 1.921875,
          "delta_ppl": -0.3203125
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while not perfectly semantically equivalent, is more readable and uses standard C constructs like `switch` and explicit type casting.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar3 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(local_18 + 1));\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = *(byte *)local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(local_28 + 5));\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(local_28 + 6));\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar3) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)*(byte *)local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              bVar1 = *(byte *)local_28;\n              bVar2 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)bVar1 + (uint)bVar2 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)*(byte *)local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)*(byte *)(local_78 + 1));\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(local_28 + 1));\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)*(byte *)local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 !=\n                       0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)*(byte *)(local_28 + 1) +\n                       (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar3 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            \n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), , , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  \n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.96875,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.140625,
          "pr_ast_ppl": 2.140625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "```\n\n**The winner is B**\n\n\n\n**Please note:**\n\n* **Candidate B** is a human-friendly code.\n\n**The code is good because it's not perfect, but it is not the best candidate.\n\n```\n\n**Reasoning:**\n\n* Candidate A is a good choice for a better solution.\n\n\nLet's break down why.\n\n## Analysis:\n\n* The first thing to note is that Candidate B is a better candidate.\n\n* The second candidate is better than the third candidate.\n\n\n* The third candidate is the best candidate.\n\n\n\n**Candidate B**\n\n\n\n```\n* It's important to know why Candidate B is better.\n\n\n\n**Candidate A**\n\n\n* The main loop is in Candidate B.\n\n\n\n**Candidate A**\n\n**Conclusion:**\n\n\n\n**Candidate B** is a better candidate than Candidate A.\n\n\n* The code should be cleaned up.\n\n\n\n**Candidate A**\n\n\n\n**Candidate B**\n\n\n\n```\n\n```\n\nLet's evaluate the code.\n\nLet's look at the code.\n\nLet's look at the code.\n\n\nLet's analyze the code.\n\n\nLet's analyze the code.\n\n\n\nLet's try to fix it.\n\n\n\nLet's fix the code.\n\n\n\nLet's analyze the code.\n\n\n```\n\n```\nLet's analyze the code.\n\n```\n\nThe code is not a good candidate.\n\n\n\nLet's analyze the code.\n\n\n\nThe code is good.\n\n\n\nThe code is good.\n\n\n\nLet's see if the code is good.\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\nLet's see the code.\n\nLet's see the code.\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n```\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\n\n\nLet's see the code.\n\nlet's see the code.\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\n\n\nlet's see the code.\n\nif (10)\nif (1)\n\nif (0)\nif (0)\nif (0)\nif (0)\nif (0)\nif (0)\nif (0)\nif (0)\nif (0)\n\n\n\nreturn 0;\n\n\n\nif (0)\nif (0)\nif (0)\nif (0)\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nif (0)\nif (0)\nif (0)\n\nreturn 0;\n\n\n\nreturn 0;\nif (0)\nreturn 0;\n\nreturn 0;\n\n\n\nif (0)\n\n\n\nreturn 0;\n\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nreturn 0;\n\n\n\nif (0)\nif (0)\nif (0)\n\n\n\nif (0)\n\n\n\nif (0)\nif (0)\nif (0)\nif (0)\nif (0)\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nif (0)\nif (0)\n\n\n\nreturn 0;\n\n\n\nif (0)\nif (0)\n\n\n\nif (0)\nif (0)\nif (0)\n\nreturn 0;\nreturn 0;\nreturn 0;\n\nreturn 0;\nreturn 0;\nreturn 0;\nreturn 0;\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\nreturn 0;\nreturn 0;\n\nif (0)\n\nif (0)\nif (0)\nif (0)\n\n\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\n\n\nif (0)\n\nreturn 0;\nif (0)\n\nreturn 0;\n\n\n\nif (0)\n\n\n\nif (0)\n\nif (0)\n\n\n\nif (0)\nreturn 0;\n\nreturn 0;\n\nreturn 0;\nreturn 0;\nreturn 0;\n\nreturn 0;\n\n\n\nreturn 0;\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nif (0)\n\n\n\nif (0)\n\nif (0)\nif (0)\n\n\n\nif (0)\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\n\n\n\nreturn 0;\nreturn 0;\n\n\n\nreturn 0;\n\nreturn 0;\n\n\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\n\n\nreturn 0;\n\nreturn 0;\n\n\n\nif (0)\n\nif (0)\n\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nif (0)\n\nif (0)\n\nreturn 0;\n\n\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\nreturn 0;\n\n\n\nif (0)\n\nif (0)\n\nreturn "
        },
        "llm_ast": {
          "motivation": "Both candidates introduce unnecessary complexity with `goto` statements and extra nesting. However, Candidate A maintains the correct nesting depth of the `do-while` loop and its inner blocks, while Candidate B creates an overly complex structure with nested `if` statements.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.75,
          "pr_ppl": 1.7578125,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.0625,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "The code is the winner!\n\n  if (p != pe)\n  return;\n  \n  return;\n\n\n\nreturn READSTAT_OK;\n\n}\n\n\n#line 11\n{\n    if (cs)\n    if (cs) {\n    if (p) {\n    return;\n}\n\n\n\n#include \"common.\n\n`\nreturn;\n\n    return;\n\n\n\n```\n\nThe code will return the value of `p`\n\n  return;\n\n\n\nreturn;\n\n\n\n```\n\n**The code will return the value of `p`\n\n```\n\nThe code will return the value of `p`\n\n```\n```\n\n\n`\nreturn;\n\n\n\n__p;\nreturn;\n\n```\n\n__p;\n\n```\n\n`\n\nreturn;\n\n```\n__p;\n\n\n__p;\n\n```\n\n\n\n**The code is a 1.\n\n\n\n`\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\nreturn;\n\n```\nreturn;\n\n\n\nreturn;\n\n\n`\nreturn;\n\n\n\n\nreturn;\n\n```\n\n\n\nreturn;\n\n\nreturn;\n\n\n```\n\nreturn;\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n```\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\np;return;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\nreturn p;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\nreturn p;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\nreturn p;\n\n\n\np;\n\n\n\np;\n\nreturn p;\n\n\n\nreturn 0;\n\n\n\nreturn p;\n\n\n\nreturn p;\n\nreturn p;\n\n\n\nreturn p;\n\nreturn p;\n\n\n\nreturn p;\n\nreturn p; return p;\n\nreturn p;\n\nreturn p;\n\n\n\nreturn p;\n\n\n\nreturn p;\n\nreturn p; return; return p;\n\nreturn p; return p; return p; return p; return p;\n\nreturn p; return p; return p; return p;\n\nreturn p; return p; return p; return p;\n\nreturn p; return p; return p;\n\nreturn p; return p; return p;\n\nreturn p; return p; return p;\n\nreturn p; return p;\n\nreturn p; return p; return p; return p; return p;\n\nreturn p; return p; return p; return p; return p; return p;\n\nreturn p; return p; return p; return p;\n\nreturn p; return p;\n\nreturn p; return p;\n\nreturn p; return p;\n\nreturn p; return p; return p;\n\nreturn p; return p;\n\nreturn p; return p; return p;\n\nreturn p; return p;\n\nreturn p; return p;\n\nreturn p; return p;\n\nreturn p; return p; return p;\n\nreturn p; return p;\n\nreturn p; return p; return p; return p; return p; return p;\n\nreturn p; return p; return p; return p; return p; return p"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.75,
          "pr_ppl": 1.7578125,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.0625,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "  __p;\n  return;\n  `if (p = pe;`\n\n\n\n#line 10000\n#line 10000\n\nif (p == pe)\n\nif (p)\n\n\n\n\nThe following is the variable,\n  {\n    if (p, p;\n    return;\n  }\n\n\n\n`\n    if (p)\n    return;\n    return\n\n```\n\nThe code you can\n\nThe following is the\n\n\n\nreturn;\n\n```\n  }\n  return;\n\nreturn\n  if (p)\n  return\n\n;\n  if (p\n\n\n\nreturn;\n  if (p)\n\nreturn;\n\n\n\nreturn;\n\n\n\nif (p)\n\n\n\nreturn;\n\n\n#include \"src/spss_parse_parse_t;\nreturn\nreturn;\nreturn\n\n\n\nreturn;\n\n```\n\n**The code is not a \nreturn\n\n```\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\n```\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\nreturn;\n\n\nif (p)\n\nreturn;\n\n\n\nif (p\n\n\n\nreturn;\n\nif (p\n\n\n\nreturn;\n\nif (p\n\n\n\nreturn;\n\nif (p\n\n\n\nreturn;\n\nif (p\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nif (p\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nif (p\n\nreturn;\n\n\n\nif (p\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\nreturn;\n\nif (p\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nreturn;\n\nif (p\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn;\n\n\n\nif (p\n\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nif (p;\n\n\n\nreturn;\n\n\n\np;\n\n\n\nreturn;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\np;\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\nreturn;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\nreturn;\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\nreturn;\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\n\n\np;\n\nreturn;\n\np;\n\n\n\np;\n\nreturn;\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\np;\n\np;\n\np;\n\np;\n\n\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\n\n\nreturn;\n\np;\n\np;\n\np;\n\np;\n\n\n\nreturn;\n\np;\n\np;\n\np;\n\np;\n\n\n\nreturn;\n\np;\n\np;\n\np;\n\nreturn;\n\np;\n\n\n\nreturn;\n\n\n\np;\n\n\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\nreturn;\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\np;\n\np;\n\n\n\np;\n\np;\n\np;\n\np;\n\nreturn;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\np;\n\nreturn;\n\np;\n\n\n\nreturn;\n\np;\n\np;\n\n\n\nreturn;\n\np;\n\n\n\np;\n\n\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\nreturn;\n\np;\n\n\n\np;\n\np;\n\n\n\np;\n\nreturn;\n\nreturn;\n\np;\n\n\n\np;\n\n\n\np;\n\np;"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.875,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.28125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable and accurate because it avoids goto statements and uses more standard C constructs, making it easier to understand and maintain.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.8828125,
          "pr_ppl": 1.875,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.28125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.734375,
          "pr_ppl": 1.7265625,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 1.953125,
          "pr_ast_ppl": 1.953125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is better because it is more readable and accurate.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.71875,
          "pr_ppl": 1.7109375,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B correctly handles variable lookup and parsing logic, ensuring accurate variable information.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 1.6484375,
          "base_ast_ppl": 2.25,
          "pr_ast_ppl": 2.25,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a more standard parsing approach with clear control flow, making it more understandable and less prone to errors.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 1.6484375,
          "base_ast_ppl": 2.25,
          "pr_ast_ppl": 2.25,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while more complex, correctly handles parsing logic and error conditions, making it more robust and accurate.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 1.71875,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is preferred because it uses clear control structures, avoids goto statements, and handles parsing in a more natural way, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 1.71875,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while more complex, uses a standard parsing loop structure and clear variable names, making it easier to understand the logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_zsav_read_compressed_data-O0.so",
        "function": "zsav_read_compressed_data",
        "source_code": "readstat_error_t zsav_read_compressed_data(sav_ctx_t *ctx,\n        readstat_error_t (*row_handler)(unsigned char *, size_t, sav_ctx_t *)) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = ctx->io;\n    readstat_off_t data_offset = 0;\n\n    size_t uncompressed_row_len = ctx->var_offset * 8;\n    readstat_off_t uncompressed_offset = 0;\n    unsigned char *uncompressed_row = NULL;\n\n    uLongf uncompressed_block_len = 0;\n    unsigned char *compressed_block = NULL, *uncompressed_block = NULL;\n\n    struct sav_row_stream_s state = { \n        .missing_value = ctx->missing_double,\n        .bias = ctx->bias,\n        .bswap = ctx->bswap };\n\n    struct zheader zheader;\n    struct ztrailer ztrailer;\n    struct ztrailer_entry *ztrailer_entries = NULL;\n\n    int n_blocks = 0;\n    int block_i = 0;\n    int i;\n\n    if (io->read(&zheader, sizeof(struct zheader), io->io_ctx) < sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    zheader.zheader_ofs = ctx->bswap ? byteswap8(zheader.zheader_ofs) : zheader.zheader_ofs;\n    zheader.ztrailer_ofs = ctx->bswap ? byteswap8(zheader.ztrailer_ofs) : zheader.ztrailer_ofs;\n    zheader.ztrailer_len = ctx->bswap ? byteswap8(zheader.ztrailer_len) : zheader.ztrailer_len;\n\n    if (zheader.zheader_ofs != io->seek(0, READSTAT_SEEK_CUR, io->io_ctx) - sizeof(struct zheader)) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    n_blocks = (zheader.ztrailer_len - 24) / 24;\n\n    if (io->seek(zheader.ztrailer_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->read(&ztrailer, sizeof(struct ztrailer), io->io_ctx) < sizeof(struct ztrailer)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ztrailer.bias = ctx->bswap ? byteswap8(ztrailer.bias) : ztrailer.bias;\n    ztrailer.zero = ctx->bswap ? byteswap8(ztrailer.zero) : ztrailer.zero;\n    ztrailer.block_size = ctx->bswap ? byteswap4(ztrailer.block_size) : ztrailer.block_size;\n    ztrailer.n_blocks = ctx->bswap ? byteswap4(ztrailer.n_blocks) : ztrailer.n_blocks;\n\n    if (n_blocks != ztrailer.n_blocks) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    if (n_blocks && (ztrailer_entries = readstat_malloc(n_blocks * sizeof(struct ztrailer_entry))) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (io->read(ztrailer_entries, n_blocks * sizeof(struct ztrailer_entry), io->io_ctx) < \n            n_blocks * sizeof(struct ztrailer_entry)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    for (i=0; i<n_blocks; i++) {\n        struct ztrailer_entry *entry = &ztrailer_entries[i];\n\n        entry->uncompressed_ofs = ctx->bswap ? byteswap8(entry->uncompressed_ofs) : entry->uncompressed_ofs;\n        entry->compressed_ofs = ctx->bswap ? byteswap8(entry->compressed_ofs) : entry->compressed_ofs;\n        entry->uncompressed_size = ctx->bswap ? byteswap4(entry->uncompressed_size) : entry->uncompressed_size;\n        entry->compressed_size = ctx->bswap ? byteswap4(entry->compressed_size) : entry->compressed_size;\n    }\n\n    if (uncompressed_row_len && (uncompressed_row = readstat_malloc(uncompressed_row_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    while (1) {\n        if (block_i == n_blocks)\n            goto cleanup;\n\n        struct ztrailer_entry *entry = &ztrailer_entries[block_i];\n        if (io->seek(entry->compressed_ofs, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n            retval = READSTAT_ERROR_SEEK;\n            goto cleanup;\n        }\n        if ((compressed_block = readstat_realloc(compressed_block, entry->compressed_size)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if (io->read(compressed_block, entry->compressed_size, io->io_ctx) != entry->compressed_size) {\n            retval = READSTAT_ERROR_READ;\n            goto cleanup;\n        }\n\n        uncompressed_block_len = entry->uncompressed_size;\n        if ((uncompressed_block = readstat_realloc(uncompressed_block, uncompressed_block_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        int status = uncompress(uncompressed_block, &uncompressed_block_len,\n                compressed_block, entry->compressed_size);\n        if (status != Z_OK || uncompressed_block_len != entry->uncompressed_size) {\n            retval = READSTAT_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        block_i++;\n        state.status = SAV_ROW_STREAM_HAVE_DATA;\n        data_offset = 0;\n\n        while (state.status != SAV_ROW_STREAM_NEED_DATA) {\n            state.next_in = &uncompressed_block[data_offset];\n            state.avail_in = uncompressed_block_len - data_offset;\n\n            state.next_out = &uncompressed_row[uncompressed_offset];\n            state.avail_out = uncompressed_row_len - uncompressed_offset;\n\n            sav_decompress_row(&state);\n\n            uncompressed_offset = uncompressed_row_len - state.avail_out;\n            data_offset = uncompressed_block_len - state.avail_in;\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ROW) {\n                retval = row_handler(uncompressed_row, uncompressed_row_len, ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                uncompressed_offset = 0;\n            }\n\n            if (state.status == SAV_ROW_STREAM_FINISHED_ALL)\n                goto cleanup;\n            if (ctx->row_limit > 0 && ctx->current_row == ctx->row_limit)\n                goto cleanup;\n        }\n    }\n\ncleanup:\n    if (uncompressed_row)\n        free(uncompressed_row);\n    if (ztrailer_entries)\n        free(ztrailer_entries);\n    if (compressed_block)\n        free(compressed_block);\n    if (uncompressed_block)\n        free(uncompressed_block);\n\n    return retval;\n}\n",
        "function_base": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined1 auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined1 auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "function_pr": "\nint zsav_read_compressed_data(long param_1,code *param_2)\n\n{\n  undefined auVar1 [16];\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined4 local_158;\n  undefined4 local_154;\n  undefined8 local_150;\n  undefined8 local_148;\n  int local_140;\n  undefined4 local_13c;\n  undefined8 local_138;\n  undefined8 local_130;\n  long local_120;\n  undefined8 local_118;\n  long local_110;\n  int local_ec;\n  int local_e8;\n  void *local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  undefined8 local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined auStack_78 [8];\n  undefined4 local_70;\n  uint local_6c;\n  int local_68;\n  void *local_60;\n  void *local_58;\n  long local_50;\n  void *local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  int local_1c;\n  code *local_18;\n  long local_10;\n  \n  local_1c = 0;\n  local_28 = *(long *)(param_1 + 0x48);\n  local_30 = 0;\n  local_38 = (long)(*(int *)(param_1 + 0x1ac) << 3);\n  local_40 = 0;\n  local_48 = (void *)0x0;\n  local_50 = 0;\n  local_58 = (void *)0x0;\n  local_60 = (void *)0x0;\n  local_a8 = 0;\n  local_a0 = 0;\n  local_98 = 0;\n  local_90 = 0;\n  local_88 = *(undefined8 *)(param_1 + 0x1f0);\n  local_80 = *(undefined8 *)(param_1 + 0x218);\n  local_18 = param_2;\n  local_10 = param_1;\n  memset(auStack_78,0,8);\n  local_70 = 0;\n  local_6c = (uint)(*(byte *)(local_10 + 0x22c) & 1);\n  local_68 = 0;\n  local_e0 = (void *)0x0;\n  local_e8 = 0;\n  uVar4 = (**(code **)(local_28 + 0x18))(&local_c0,0x18,*(undefined8 *)(local_28 + 0x28));\n  if (uVar4 < 0x18) {\n    local_1c = 2;\n  }\n  else {\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_110 = local_c0;\n    }\n    else {\n      local_110 = byteswap8(local_c0);\n    }\n    local_c0 = local_110;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_118 = local_b8;\n    }\n    else {\n      local_118 = byteswap8(local_b8);\n    }\n    local_b8 = local_118;\n    if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n      local_120 = local_b0;\n    }\n    else {\n      local_120 = byteswap8(local_b0);\n    }\n    lVar6 = local_c0;\n    local_b0 = local_120;\n    lVar5 = (**(code **)(local_28 + 0x10))(0,1,*(undefined8 *)(local_28 + 0x28));\n    if (lVar6 == lVar5 + -0x18) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = local_b0 - 0x18;\n      iVar2 = SUB164(auVar1 / ZEXT816(0x18),0);\n      lVar6 = (**(code **)(local_28 + 0x10))(local_b8,0,*(undefined8 *)(local_28 + 0x28));\n      if (lVar6 == -1) {\n        local_1c = 0xf;\n      }\n      else {\n        uVar4 = (**(code **)(local_28 + 0x18))(&local_d8,0x18,*(undefined8 *)(local_28 + 0x28));\n        if (uVar4 < 0x18) {\n          local_1c = 2;\n        }\n        else {\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_130 = local_d8;\n          }\n          else {\n            local_130 = byteswap8(local_d8);\n          }\n          local_d8 = local_130;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_138 = local_d0;\n          }\n          else {\n            local_138 = byteswap8(local_d0);\n          }\n          local_d0 = local_138;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_13c = local_c8;\n          }\n          else {\n            local_13c = byteswap4(local_c8);\n          }\n          local_c8 = local_13c;\n          if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n            local_140 = local_c4;\n          }\n          else {\n            local_140 = byteswap4(local_c4);\n          }\n          local_c4 = local_140;\n          if (iVar2 == local_140) {\n            if ((iVar2 == 0) ||\n               (local_e0 = (void *)readstat_malloc((long)iVar2 * 0x18), local_e0 != (void *)0x0)) {\n              uVar4 = (**(code **)(local_28 + 0x18))\n                                (local_e0,(long)iVar2 * 0x18,*(undefined8 *)(local_28 + 0x28));\n              if (uVar4 < (ulong)((long)iVar2 * 0x18)) {\n                local_1c = 2;\n              }\n              else {\n                for (local_ec = 0; local_ec < iVar2; local_ec = local_ec + 1) {\n                  puVar7 = (undefined8 *)((long)local_e0 + (long)local_ec * 0x18);\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_148 = *puVar7;\n                  }\n                  else {\n                    local_148 = byteswap8(*puVar7);\n                  }\n                  *puVar7 = local_148;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_150 = puVar7[1];\n                  }\n                  else {\n                    local_150 = byteswap8(puVar7[1]);\n                  }\n                  puVar7[1] = local_150;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_154 = *(undefined4 *)(puVar7 + 2);\n                  }\n                  else {\n                    local_154 = byteswap4(*(undefined4 *)(puVar7 + 2));\n                  }\n                  *(undefined4 *)(puVar7 + 2) = local_154;\n                  if ((*(byte *)(local_10 + 0x22c) & 1) == 0) {\n                    local_158 = *(undefined4 *)((long)puVar7 + 0x14);\n                  }\n                  else {\n                    local_158 = byteswap4(*(undefined4 *)((long)puVar7 + 0x14));\n                  }\n                  *(undefined4 *)((long)puVar7 + 0x14) = local_158;\n                }\n                if ((local_38 == 0) ||\n                   (local_48 = (void *)readstat_malloc(local_38), local_48 != (void *)0x0)) {\n                  while (local_e8 != iVar2) {\n                    lVar6 = (**(code **)(local_28 + 0x10))\n                                      (*(undefined8 *)((long)local_e0 + (long)local_e8 * 0x18 + 8),0\n                                       ,*(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 == -1) {\n                      local_1c = 0xf;\n                      break;\n                    }\n                    local_58 = (void *)readstat_realloc(local_58,(long)*(int *)((long)local_e0 +\n                                                                               (long)local_e8 * 0x18\n                                                                               + 0x14));\n                    if (local_58 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    lVar6 = (**(code **)(local_28 + 0x18))\n                                      (local_58,(long)*(int *)((long)local_e0 +\n                                                              (long)local_e8 * 0x18 + 0x14),\n                                       *(undefined8 *)(local_28 + 0x28));\n                    if (lVar6 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)) {\n                      local_1c = 2;\n                      break;\n                    }\n                    local_50 = (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10);\n                    local_60 = (void *)readstat_realloc(local_60,local_50);\n                    if (local_60 == (void *)0x0) {\n                      local_1c = 3;\n                      break;\n                    }\n                    iVar3 = uncompress(local_60,&local_50,local_58,\n                                       (long)*(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x14)\n                                      );\n                    if ((iVar3 != 0) ||\n                       (local_50 != *(int *)((long)local_e0 + (long)local_e8 * 0x18 + 0x10))) {\n                      local_1c = 5;\n                      break;\n                    }\n                    local_e8 = local_e8 + 1;\n                    local_68 = 1;\n                    local_30 = 0;\n                    while (local_68 != 0) {\n                      local_a8 = (long)local_60 + local_30;\n                      local_a0 = local_50 - local_30;\n                      local_98 = (long)local_48 + local_40;\n                      local_90 = local_38 - local_40;\n                      sav_decompress_row(&local_a8);\n                      local_40 = local_38 - local_90;\n                      local_30 = local_50 - local_a0;\n                      if (local_68 == 2) {\n                        local_1c = (*local_18)(local_48,local_38,local_10);\n                        if (local_1c != 0) goto LAB_00101a68;\n                        local_40 = 0;\n                      }\n                      if ((local_68 == 3) ||\n                         ((0 < *(int *)(local_10 + 0x1b8) &&\n                          (*(int *)(local_10 + 0x1c0) == *(int *)(local_10 + 0x1b8)))))\n                      goto LAB_00101a68;\n                    }\n                  }\n                }\n                else {\n                  local_1c = 3;\n                }\n              }\n            }\n            else {\n              local_1c = 3;\n            }\n          }\n          else {\n            local_1c = 5;\n          }\n        }\n      }\n    }\n    else {\n      local_1c = 5;\n    }\n  }\nLAB_00101a68:\n  if (local_48 != (void *)0x0) {\n    free(local_48);\n  }\n  if (local_e0 != (void *)0x0) {\n    free(local_e0);\n  }\n  if (local_58 != (void *)0x0) {\n    free(local_58);\n  }\n  if (local_60 != (void *)0x0) {\n    free(local_60);\n  }\n  return local_1c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  (? call(): )\n  if(){\n    \n    goto label\n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  for(;;){\n    \n    (? call(): )\n    (? call(): )\n    (? call(): )\n    (? call(): )\n  }\n  if(call()){\n    \n    goto label\n  }\n  while(){\n    if()goto label\n    \n    if(call(, , )){\n      \n      goto label\n    }\n    if(call(, )){\n      \n      goto label\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    \n    if(call(, )){\n      \n      goto label\n    }\n    call(, , , )\n    if(){\n      \n      goto label\n    }\n    \n    \n    \n    while(){\n      \n      \n      \n      \n      call()\n      \n      \n      if(){\n        call(, , )\n        if()goto label\n        \n      }\n      if()goto label\n      if()goto label\n    }\n  }\n  if()call()\n  if()call()\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, , )\n  \n  call()\n  \n  \n  \n  call(, , )\n  if(){\n    \n  }else{\n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    if(){\n      \n    }else{\n      call()\n    }\n    \n    \n    call(, , )\n    if(){\n      \n      \n      call(call(), )\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          \n        }else{\n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            \n          }else{\n            call()\n          }\n          \n          if(){\n            if(call()){\n              call(, , )\n              if(call()){\n                \n              }else{\n                for(;;){\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                  if(){\n                    \n                  }else{\n                    call()\n                  }\n                  \n                }\n                if(call()){\n                  while(){\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    call(, )\n                    if(){\n                      \n                      \n                    }\n                    call(, , , )\n                    if(){\n                      \n                      \n                    }\n                    \n                    \n                    \n                    while(){\n                      \n                      \n                      \n                      \n                      call()\n                      \n                      \n                      if(){\n                        call(, , )\n                        if()goto label\n                        \n                      }\n                      if()goto label\n                    }\n                  }\n                }else{\n                  \n                }\n              }\n            }else{\n              \n            }\n          }else{\n            \n          }\n        }\n      }\n    }else{\n      \n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.7578125,
          "base_ppl": 1.5,
          "pr_ppl": 1.4921875,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 1.75,
          "pr_ast_ppl": 1.75,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its clear structure and adherence to common practices.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O0.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined1 *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *local_20a0;\n  char *local_2098;\n  char *local_2088;\n  char *local_2080;\n  int local_2074;\n  undefined *local_2070;\n  char *local_2068;\n  uint local_2060;\n  int local_2058;\n  int local_2054;\n  char *local_2040;\n  char local_2038 [8196];\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  pcVar3 = param_1 + param_2;\n  local_2058 = 0;\n  local_2054 = 1;\n  local_2060 = 0;\n  for (local_2040 = param_1; (local_2040 != pcVar3 || (local_2040 == pcVar3));\n      local_2040 = local_2040 + 1) {\n    if (local_2040 == pcVar3) {\n      if (0 < *(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2)) {\n        local_2060 = (int)*(short *)(_sav_date_parse_eof_trans + (long)local_2054 * 2) - 1;\n      }\n    }\n    else {\n      local_2068 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                   + (int)(char)_sav_date_parse_key_offsets[local_2054];\n      local_2060 = (uint)*(short *)(_sav_date_parse_index_offsets + (long)local_2054 * 2);\n      iVar2 = (int)(char)_sav_date_parse_single_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2088 = local_2068 + (long)iVar2 + -1;\n        local_2080 = local_2068;\n        while (local_2080 <= local_2088) {\n          pcVar4 = local_2080 + ((long)local_2088 - (long)local_2080 >> 1);\n          if (*local_2040 < *pcVar4) {\n            local_2088 = pcVar4 + -1;\n          }\n          else {\n            if (*local_2040 <= *pcVar4) {\n              local_2060 = ((int)pcVar4 - (int)local_2068) + local_2060;\n              goto LAB_001014d5;\n            }\n            local_2080 = pcVar4 + 1;\n          }\n        }\n        local_2068 = local_2068 + iVar2;\n        local_2060 = iVar2 + local_2060;\n      }\n      iVar2 = (int)(char)_sav_date_parse_range_lengths[local_2054];\n      if (0 < iVar2) {\n        local_2098 = local_2068;\n        local_20a0 = local_2068 + (long)(iVar2 << 1) + -2;\n        while (local_2098 <= local_20a0) {\n          pcVar4 = local_2098 + ((long)local_20a0 - (long)local_2098 >> 1 & 0xfffffffffffffffe);\n          if (*local_2040 < *pcVar4) {\n            local_20a0 = pcVar4 + -2;\n          }\n          else {\n            if (*local_2040 <= pcVar4[1]) {\n              iVar2 = (int)((long)pcVar4 - (long)local_2068 >> 1);\n              break;\n            }\n            local_2098 = pcVar4 + 2;\n          }\n        }\n        local_2060 = iVar2 + local_2060;\n      }\n    }\nLAB_001014d5:\n    local_2054 = (int)(char)_sav_date_parse_cond_targs[local_2060];\n    if (_sav_date_parse_cond_actions[local_2060] != '\\0') {\n      local_2070 = _sav_date_parse_actions +\n                   (long)(int)(char)_sav_date_parse_cond_actions[local_2060] + 1;\n      for (local_2074 = (int)(char)_sav_date_parse_actions\n                                   [(int)(char)_sav_date_parse_cond_actions[local_2060]];\n          local_2074 != 0; local_2074 = local_2074 + -1) {\n        switch(*local_2070) {\n        case 0:\n          cVar1 = *local_2040 + -0x30;\n          if ((-1 < cVar1) && (cVar1 < '\\n')) {\n            local_2058 = local_2058 * 10 + (int)cVar1;\n          }\n          break;\n        case 1:\n          if (local_2058 < 0x46) {\n            *(int *)(param_3 + 0x14) = local_2058 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = local_2058;\n          }\n          break;\n        case 2:\n          local_2058 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = local_2058;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        local_2070 = local_2070 + 1;\n      }\n    }\n    if ((local_2040 == pcVar3) || (local_2054 == 0)) break;\n  }\n  if ((local_2054 < 0x2f) || (local_2040 != pcVar3)) {\n    if (param_4 != (code *)0x0) {\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_2038,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            if(){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 1.8671875,
          "pr_ppl": 1.8671875,
          "source_ast_ppl": 1.71875,
          "base_ast_ppl": 2.1875,
          "pr_ast_ppl": 2.1875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while more complex, uses a clear and structured approach to parse the date string, making it more readable and less prone to errors.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    do{\n      \n      \n      switch(){\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          \n          \n          \n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          goto label\n        case :\n          \n        case :\n          \n          \n          \n          if(){\n            return\n          }\n      }\n      if(){\n        return\n      }\n      \n      \n      \n      \n      \n    }while()\n    if(){\n      \n      \n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.890625,
          "source_ast_ppl": 3.953125,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.390625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more accurate and semantically correct, closely matching the original function's purpose and logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates incorrectly translate the source's nesting and loop structure. Candidate B is penalized for the extra `if()` block inside the `do` loop.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    do{\n      \n      \n      switch(){\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          \n          \n          \n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n        case :\n          goto label\n        case :\n          \n        case :\n          \n          \n          \n          if(){\n            return\n          }\n      }\n      if(){\n        return\n      }\n      \n      \n      \n      \n      \n    }while()\n    if(){\n      \n      \n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.890625,
          "source_ast_ppl": 3.953125,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.390625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is semantically incorrect but presents a more structured and readable approach, aligning better with typical C programming practices.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates incorrectly handle the nested loops. Candidate A preserves the overall nesting depth better, even with the use of switch statements and goto.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O0.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined1 *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "function_pr": "\nundefined4\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  char local_4a8 [1024];\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  char *local_80;\n  int local_74;\n  undefined *local_70;\n  char *local_68;\n  uint local_60;\n  int local_5c;\n  int local_58;\n  int local_54;\n  char *local_50;\n  char *local_48;\n  char *local_40;\n  undefined4 local_34;\n  undefined8 local_30;\n  code *local_28;\n  long local_20;\n  ulong local_18;\n  char *local_10;\n  \n  local_34 = 0;\n  local_50 = param_1 + param_2;\n  local_58 = 0;\n  local_54 = 1;\n  local_60 = 0;\n  for (local_40 = param_1; (local_40 != local_50 || (local_40 == local_50)); local_40 = local_40 + 1\n      ) {\n    if (local_40 == local_50) {\n      if (0 < *(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2)) {\n        local_60 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)local_54 * 2) - 1;\n      }\n    }\n    else {\n      local_68 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n                 + (int)(char)_dta_timestamp_parse_key_offsets[local_54];\n      local_60 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + (long)local_54 * 2);\n      local_5c = (int)(char)_dta_timestamp_parse_single_lengths[local_54];\n      if (0 < local_5c) {\n        local_88 = local_68 + (long)local_5c + -1;\n        local_80 = local_68;\n        while (local_80 <= local_88) {\n          local_90 = local_80 + ((long)local_88 - (long)local_80 >> 1);\n          if (*local_40 < *local_90) {\n            local_88 = local_90 + -1;\n          }\n          else {\n            if (*local_40 <= *local_90) {\n              local_60 = ((int)local_90 - (int)local_68) + local_60;\n              goto LAB_0010141e;\n            }\n            local_80 = local_90 + 1;\n          }\n        }\n        local_68 = local_68 + local_5c;\n        local_60 = local_5c + local_60;\n      }\n      local_5c = (int)(char)_dta_timestamp_parse_range_lengths[local_54];\n      if (0 < local_5c) {\n        local_98 = local_68;\n        local_a0 = local_68 + (long)(local_5c << 1) + -2;\n        while (iVar1 = local_5c, local_98 <= local_a0) {\n          local_a8 = local_98 + ((long)local_a0 - (long)local_98 >> 1 & 0xfffffffffffffffe);\n          if (*local_40 < *local_a8) {\n            local_a0 = local_a8 + -2;\n          }\n          else {\n            if (*local_40 <= local_a8[1]) {\n              iVar1 = (int)((long)local_a8 - (long)local_68 >> 1);\n              break;\n            }\n            local_98 = local_a8 + 2;\n          }\n        }\n        local_60 = iVar1 + local_60;\n      }\n    }\nLAB_0010141e:\n    local_54 = (int)(char)_dta_timestamp_parse_cond_targs[local_60];\n    if (_dta_timestamp_parse_cond_actions[local_60] != '\\0') {\n      local_70 = _dta_timestamp_parse_actions +\n                 (long)(int)(char)_dta_timestamp_parse_cond_actions[local_60] + 1;\n      for (local_74 = (int)(char)_dta_timestamp_parse_actions\n                                 [(int)(char)_dta_timestamp_parse_cond_actions[local_60]];\n          local_74 != 0; local_74 = local_74 + -1) {\n        switch(*local_70) {\n        case 0:\n          local_58 = local_58 * 10 + *local_40 + -0x30;\n          break;\n        case 1:\n          local_58 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = local_58;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = local_58 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = local_58;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = local_58;\n        }\n        local_70 = local_70 + 1;\n      }\n    }\n    if ((local_40 == local_50) || (local_54 == 0)) break;\n  }\n  if ((local_54 < 0x2c) || (local_40 != local_50)) {\n    if (param_4 != (code *)0x0) {\n      local_48 = local_50;\n      local_30 = param_5;\n      local_28 = param_4;\n      local_20 = param_3;\n      local_18 = param_2;\n      local_10 = param_1;\n      snprintf(local_4a8,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff,\n               param_2 & 0xffffffff,param_1);\n      (*local_28)(local_4a8,local_30);\n    }\n    local_34 = 0x1d;\n  }\n  return local_34;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  for(;;){\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              goto label\n            }\n            \n          }\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        while(){\n          \n          if(){\n            \n          }else{\n            if(){\n              \n              \n            }\n            \n          }\n        }\n        \n      }\n    }\n    \n    if(){\n      \n      for(;;){\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }\n    }\n    if()\n  }\n  if(){\n    if(){\n      \n      \n      \n      \n      \n      \n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 1.984375,
          "pr_ppl": 1.9765625,
          "source_ast_ppl": 1.6484375,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a state machine approach common in parsing, making it more accurate and robust in handling different timestamp formats.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O0.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined1 local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined1 local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined1 local_208 [60];\n  undefined1 auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  iconv_t pvVar3;\n  long lVar4;\n  undefined local_738 [264];\n  size_t local_630;\n  char local_624 [8];\n  undefined local_61c [8];\n  int local_614;\n  void *local_610;\n  char local_608 [1024];\n  undefined local_208 [60];\n  undefined auStack_1cc [148];\n  byte local_138 [264];\n  undefined8 *local_30;\n  int local_24;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_24 = 0;\n  local_30 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  local_610 = (void *)por_ctx_init();\n  memcpy(local_610,local_10,0x40);\n  *(undefined8 *)((long)local_610 + 0x48) = local_20;\n  *(undefined8 **)((long)local_610 + 0x58) = local_30;\n  *(int *)((long)local_610 + 0x2d0) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)local_610 + 0x2d4) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  if (*(long *)((long)local_10 + 0x50) != 0) {\n    iVar2 = strcmp(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n    if (iVar2 != 0) {\n      pvVar3 = iconv_open(*(char **)((long)local_10 + 0x50),\"UTF-8\");\n      *(iconv_t *)((long)local_610 + 0x2a8) = pvVar3;\n    }\n    if (*(long *)((long)local_610 + 0x2a8) == -1) {\n      *(undefined8 *)((long)local_610 + 0x2a8) = 0;\n      local_24 = 7;\n      goto LAB_00101f5b;\n    }\n  }\n  iVar2 = (*(code *)*local_30)(local_18,local_30[5]);\n  if (iVar2 == -1) {\n    local_24 = 1;\n  }\n  else {\n    lVar4 = (*(code *)local_30[2])(0,2,local_30[5]);\n    *(long *)((long)local_610 + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_24 = 0xf;\n    }\n    else {\n      lVar4 = (*(code *)local_30[2])(0,0,local_30[5]);\n      if (lVar4 == -1) {\n        local_24 = 0xf;\n      }\n      else {\n        lVar4 = read_bytes(local_610,local_208,200);\n        if (lVar4 == 200) {\n          local_24 = readstat_convert((long)local_610 + 0x89,0x15,auStack_1cc,0x14,0);\n          if (local_24 == 0) {\n            lVar4 = read_bytes(local_610,local_138,0x100);\n            if (lVar4 == 0x100) {\n              *(byte *)((long)local_610 + 0x60) = local_138[0x7e];\n              for (local_614 = 0; local_614 < 0x100; local_614 = local_614 + 1) {\n                if (PTR_por_ascii_lookup_00105fe8[local_614] == '\\0') {\n                  if (*(short *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2) != 0) {\n                    *(undefined2 *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                         *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + (long)local_614 * 2);\n                  }\n                }\n                else {\n                  *(short *)((long)local_610 + (ulong)local_138[local_614] * 2 + 0x9e) =\n                       (short)(char)PTR_por_ascii_lookup_00105fe8[local_614];\n                }\n              }\n              *(undefined2 *)((long)local_610 + (ulong)local_138[0x40] * 2 + 0x9e) =\n                   *(undefined2 *)(PTR_por_unicode_lookup_00105fe0 + 0x80);\n              lVar4 = read_bytes(local_610,local_61c,8);\n              if (lVar4 == 8) {\n                local_630 = por_utf8_encode(local_61c,8,local_624,8,(long)local_610 + 0x9e);\n                if (local_630 == 0xffffffffffffffff) {\n                  if (*(long *)((long)local_610 + 0x30) != 0) {\n                    snprintf(local_608,0x400,\"Error converting check string: %.*s\",8,local_61c);\n                    (**(code **)((long)local_610 + 0x30))\n                              (local_608,*(undefined8 *)((long)local_610 + 0x48));\n                  }\n                  local_24 = 0x10;\n                }\n                else {\n                  iVar2 = strncmp(\"SPSSPORT\",local_624,local_630);\n                  if (iVar2 == 0) {\n                    *(undefined4 *)((long)local_610 + 0x2cc) = 0xffffffff;\n                    local_24 = read_version_and_timestamp(local_610);\n                    if (local_24 == 0) {\n                      local_24 = 0;\n                      do {\n                        uVar1 = read_tag(local_610);\n                        switch(uVar1) {\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                          local_24 = read_string(local_610,local_738,0x100);\n                          break;\n                        case 0x34:\n                          local_24 = read_variable_count_record(local_610);\n                          break;\n                        case 0x35:\n                          local_24 = read_precision_record(local_610);\n                          break;\n                        case 0x36:\n                          local_24 = read_case_weight_record(local_610);\n                          break;\n                        case 0x37:\n                          local_24 = read_variable_record(local_610);\n                          break;\n                        case 0x38:\n                          local_24 = read_missing_value_record(local_610);\n                          break;\n                        case 0x39:\n                          local_24 = read_missing_value_lo_range_record(local_610);\n                          break;\n                        default:\n                          local_24 = 5;\n                          goto LAB_00101f5b;\n                        case 0x41:\n                          local_24 = read_missing_value_hi_range_record(local_610);\n                          break;\n                        case 0x42:\n                          local_24 = read_missing_value_range_record(local_610);\n                          break;\n                        case 0x43:\n                          local_24 = read_variable_label_record(local_610);\n                          break;\n                        case 0x44:\n                          local_24 = read_value_label_record(local_610);\n                          break;\n                        case 0x45:\n                          local_24 = read_document_record(local_610);\n                          break;\n                        case 0x46:\n                          if (*(int *)((long)local_610 + 0x2cc) ==\n                              *(int *)((long)local_610 + 0x2c8) + -1) {\n                            local_24 = handle_variables(local_610);\n                            if ((local_24 == 0) && (*(long *)((long)local_610 + 0x20) != 0)) {\n                              local_24 = read_por_file_data(local_610);\n                            }\n                          }\n                          else {\n                            local_24 = 8;\n                          }\n                          goto LAB_00101f5b;\n                        }\n                      } while (local_24 == 0);\n                    }\n                  }\n                  else {\n                    local_24 = 5;\n                  }\n                }\n              }\n              else {\n                local_24 = 2;\n              }\n            }\n            else {\n              local_24 = 2;\n            }\n          }\n        }\n        else {\n          local_24 = 2;\n        }\n      }\n    }\n  }\nLAB_00101f5b:\n  (*(code *)local_30[1])(local_30[5]);\n  por_ctx_free(local_610);\n  return local_24;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            \n                            \n                            goto label\n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, , )\n  \n  \n  \n  if(){\n    \n  }\n  if(){\n    call(, )\n    if(){\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n    }else{\n      call(, , )\n      if(){\n        \n      }else{\n        call(, , )\n        if(){\n          call(, , , , )\n          if(){\n            call(, , )\n            if(){\n              \n              for(;;){\n                if(){\n                  if(){\n                    \n                  }\n                }else{\n                  \n                }\n              }\n              \n              call(, , )\n              if(){\n                call(, , , , )\n                if(){\n                  if(){\n                    call(, , , , )\n                    call(, )\n                  }\n                  \n                }else{\n                  call(, , )\n                  if(){\n                    \n                    call()\n                    if(){\n                      \n                      do{\n                        call()\n                        switch(){\n                          case :\n                          case :\n                          case :\n                            call(, , )\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            \n                            \n                            goto label\n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            call()\n                            \n                          case :\n                            if(){\n                              call()\n                              if(){\n                                call()\n                              }\n                            }else{\n                              \n                            }\n                            goto label\n                        }\n                      }while()\n                    }\n                  }else{\n                    \n                  }\n                }\n              }else{\n                \n              }\n            }else{\n              \n            }\n          }\n        }else{\n          \n        }\n      }\n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.265625,
          "base_ppl": 1.828125,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.140625,
          "pr_ast_ppl": 2.140625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a more idiomatic structure with clear loops and error handling, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_ctx_init-O0.so",
        "function": "dta_ctx_init",
        "source_code": "readstat_error_t dta_ctx_init(dta_ctx_t *ctx, uint32_t nvar, uint64_t nobs,\n        unsigned char byteorder, unsigned char ds_format,\n        const char *input_encoding, const char *output_encoding) {\n    readstat_error_t retval = READSTAT_OK;\n    int machine_byteorder = DTA_HILO;\n    if (ds_format < DTA_MIN_VERSION || ds_format > DTA_MAX_VERSION)\n        return READSTAT_ERROR_UNSUPPORTED_FILE_FORMAT_VERSION;\n\n    if (machine_is_little_endian()) {\n        machine_byteorder = DTA_LOHI;\n    }\n\n    ctx->bswap = (byteorder != machine_byteorder);\n    ctx->ds_format = ds_format;\n    ctx->endianness = byteorder == DTA_LOHI ? READSTAT_ENDIAN_LITTLE : READSTAT_ENDIAN_BIG;\n\n    ctx->nvar = nvar;\n    ctx->nobs = nobs;\n\n    if (ctx->nvar) {\n        if ((ctx->variables = readstat_calloc(ctx->nvar, sizeof(readstat_variable_t *))) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->machine_is_twos_complement = READSTAT_MACHINE_IS_TWOS_COMPLEMENT;\n\n    if (ds_format < 105) {\n        ctx->fmtlist_entry_len = 7;\n    } else if (ds_format < 114) {\n        ctx->fmtlist_entry_len = 12;\n    } else if (ds_format < 118) {\n        ctx->fmtlist_entry_len = 49;\n    } else {\n        ctx->fmtlist_entry_len = 57;\n    }\n    \n    if (ds_format >= 117) {\n        ctx->typlist_version = 117;\n    } else if (ds_format >= 111) {\n        ctx->typlist_version = 111;\n    } else {\n        ctx->typlist_version = 0;\n    }\n\n    if (ds_format >= 118) {\n        ctx->data_label_len_len = 2;\n        ctx->strl_v_len = 2;\n        ctx->strl_o_len = 6;\n    } else if (ds_format >= 117) {\n        ctx->data_label_len_len = 1;\n        ctx->strl_v_len = 4;\n        ctx->strl_o_len = 4;\n    }\n\n    if (ds_format < 105) {\n        ctx->expansion_len_len = 0;\n    } else if (ds_format < 110) {\n        ctx->expansion_len_len = 2;\n    } else {\n        ctx->expansion_len_len = 4;\n    }\n    \n    if (ds_format < 110) {\n        ctx->lbllist_entry_len = 9;\n        ctx->variable_name_len = 9;\n        ctx->ch_metadata_len = 9;\n    } else if (ds_format < 118) {\n        ctx->lbllist_entry_len = 33;\n        ctx->variable_name_len = 33;\n        ctx->ch_metadata_len = 33;\n    } else {\n        ctx->lbllist_entry_len = 129;\n        ctx->variable_name_len = 129;\n        ctx->ch_metadata_len = 129;\n    }\n\n    if (ds_format < 108) {\n        ctx->variable_labels_entry_len = 32;\n        ctx->data_label_len = 32;\n    } else if (ds_format < 118) {\n        ctx->variable_labels_entry_len = 81;\n        ctx->data_label_len = 81;\n    } else {\n        ctx->variable_labels_entry_len = 321;\n        ctx->data_label_len = 321;\n    }\n\n    if (ds_format < 105) {\n        ctx->timestamp_len = 0;\n        ctx->value_label_table_len_len = 2;\n        ctx->value_label_table_labname_len = 12;\n        ctx->value_label_table_padding_len = 2;\n    } else {\n        ctx->timestamp_len = 18;\n        ctx->value_label_table_len_len = 4;\n        if (ds_format < 118) {\n            ctx->value_label_table_labname_len = 33;\n        } else {\n            ctx->value_label_table_labname_len = 129;\n        }\n        ctx->value_label_table_padding_len = 3;\n    }\n\n    if (ds_format < 117) {\n        ctx->typlist_entry_len = 1;\n        ctx->file_is_xmlish = 0;\n    } else {\n        ctx->typlist_entry_len = 2;\n        ctx->file_is_xmlish = 1;\n    }\n\n    if (ds_format < 113) {\n        ctx->max_int8 = DTA_OLD_MAX_INT8;\n        ctx->max_int16 = DTA_OLD_MAX_INT16;\n        ctx->max_int32 = DTA_OLD_MAX_INT32;\n        ctx->max_float = DTA_OLD_MAX_FLOAT;\n        ctx->max_double = DTA_OLD_MAX_DOUBLE;\n    } else {\n        ctx->max_int8 = DTA_113_MAX_INT8;\n        ctx->max_int16 = DTA_113_MAX_INT16;\n        ctx->max_int32 = DTA_113_MAX_INT32;\n        ctx->max_float = DTA_113_MAX_FLOAT;\n        ctx->max_double = DTA_113_MAX_DOUBLE;\n\n        ctx->supports_tagged_missing = 1;\n    }\n\n    if (output_encoding) {\n        if (input_encoding) {\n            ctx->converter = iconv_open(output_encoding, input_encoding);\n        } else if (ds_format < 118) {\n            ctx->converter = iconv_open(output_encoding, \"WINDOWS-1252\");\n        } else if (strcmp(output_encoding, \"UTF-8\") != 0) {\n            ctx->converter = iconv_open(output_encoding, \"UTF-8\");\n        }\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n\n    if (ds_format < 119) {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int16_t);\n    } else {\n        ctx->srtlist_len = (ctx->nvar + 1) * sizeof(int32_t);\n    }\n\n    if ((ctx->srtlist = readstat_malloc(ctx->srtlist_len)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->nvar > 0) {\n        ctx->typlist_len = ctx->nvar * sizeof(uint16_t);\n        ctx->varlist_len = ctx->variable_name_len * ctx->nvar * sizeof(char);\n        ctx->fmtlist_len = ctx->fmtlist_entry_len * ctx->nvar * sizeof(char);\n        ctx->lbllist_len = ctx->lbllist_entry_len * ctx->nvar * sizeof(char);\n        ctx->variable_labels_len = ctx->variable_labels_entry_len * ctx->nvar * sizeof(char);\n\n        if ((ctx->typlist = readstat_malloc(ctx->typlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->varlist = readstat_malloc(ctx->varlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->fmtlist = readstat_malloc(ctx->fmtlist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->lbllist = readstat_malloc(ctx->lbllist_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n        if ((ctx->variable_labels = readstat_malloc(ctx->variable_labels_len)) == NULL) {\n            retval = READSTAT_ERROR_MALLOC;\n            goto cleanup;\n        }\n    }\n\n    ctx->initialized = 1;\n\ncleanup:\n    return retval;\n}\n",
        "function_base": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined1 *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined1 *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined1 *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined1 *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "function_pr": "\nundefined4\ndta_ctx_init(long param_1,undefined4 param_2,undefined8 param_3,char param_4,byte param_5,\n            char *param_6,char *param_7)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  iconv_t pvVar4;\n  undefined4 uVar5;\n  \n  cVar1 = '\\x01';\n  if ((param_5 < 0x68) || (0x77 < param_5)) {\n    return 0x18;\n  }\n  iVar2 = machine_is_little_endian();\n  if (iVar2 != 0) {\n    cVar1 = '\\x02';\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfe | param_4 != cVar1;\n  *(uint *)(param_1 + 0x108) = (uint)param_5;\n  uVar5 = 2;\n  if (param_4 == '\\x02') {\n    uVar5 = 1;\n  }\n  *(undefined4 *)(param_1 + 0x170) = uVar5;\n  *(undefined4 *)(param_1 + 0x10c) = param_2;\n  *(undefined8 *)(param_1 + 0x110) = param_3;\n  if (*(int *)(param_1 + 0x10c) != 0) {\n    lVar3 = readstat_calloc((long)*(int *)(param_1 + 0x10c),8);\n    *(long *)(param_1 + 0x168) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfd;\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xa0) = 7;\n  }\n  else if (param_5 < 0x72) {\n    *(undefined8 *)(param_1 + 0xa0) = 0xc;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa0) = 0x31;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa0) = 0x39;\n  }\n  if (param_5 < 0x75) {\n    if (param_5 < 0x6f) {\n      *(undefined *)(param_1 + 0x28) = 0;\n    }\n    else {\n      *(undefined *)(param_1 + 0x28) = 0x6f;\n    }\n  }\n  else {\n    *(undefined *)(param_1 + 0x28) = 0x75;\n  }\n  if (param_5 < 0x76) {\n    if (0x74 < param_5) {\n      *(undefined8 *)(param_1 + 0x10) = 1;\n      *(undefined8 *)(param_1 + 0xe0) = 4;\n      *(undefined8 *)(param_1 + 0xe8) = 4;\n    }\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x10) = 2;\n    *(undefined8 *)(param_1 + 0xe0) = 2;\n    *(undefined8 *)(param_1 + 0xe8) = 6;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0xb8) = 0;\n  }\n  else if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xb8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb8) = 4;\n  }\n  if (param_5 < 0x6e) {\n    *(undefined8 *)(param_1 + 0xa8) = 9;\n    *(undefined8 *)(param_1 + 0x98) = 9;\n    *(undefined8 *)(param_1 + 0xc0) = 9;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xa8) = 0x21;\n    *(undefined8 *)(param_1 + 0x98) = 0x21;\n    *(undefined8 *)(param_1 + 0xc0) = 0x21;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xa8) = 0x81;\n    *(undefined8 *)(param_1 + 0x98) = 0x81;\n    *(undefined8 *)(param_1 + 0xc0) = 0x81;\n  }\n  if (param_5 < 0x6c) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x20;\n    *(undefined8 *)(param_1 + 8) = 0x20;\n  }\n  else if (param_5 < 0x76) {\n    *(undefined8 *)(param_1 + 0xb0) = 0x51;\n    *(undefined8 *)(param_1 + 8) = 0x51;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0xb0) = 0x141;\n    *(undefined8 *)(param_1 + 8) = 0x141;\n  }\n  if (param_5 < 0x69) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n    *(undefined8 *)(param_1 + 200) = 2;\n    *(undefined8 *)(param_1 + 0xd0) = 0xc;\n    *(undefined8 *)(param_1 + 0xd8) = 2;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x20) = 0x12;\n    *(undefined8 *)(param_1 + 200) = 4;\n    if (param_5 < 0x76) {\n      *(undefined8 *)(param_1 + 0xd0) = 0x21;\n    }\n    else {\n      *(undefined8 *)(param_1 + 0xd0) = 0x81;\n    }\n    *(undefined8 *)(param_1 + 0xd8) = 3;\n  }\n  if (param_5 < 0x75) {\n    *(undefined8 *)(param_1 + 0x30) = 1;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x30) = 2;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xfb | 4;\n  }\n  if (param_5 < 0x71) {\n    *(undefined *)(param_1 + 0x139) = 0x7e;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7ffe;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7ffffffe;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n  }\n  else {\n    *(undefined *)(param_1 + 0x139) = 100;\n    *(undefined2 *)(param_1 + 0x13a) = 0x7fe4;\n    *(undefined4 *)(param_1 + 0x13c) = 0x7fffffe4;\n    *(undefined4 *)(param_1 + 0x140) = 0x7effffff;\n    *(undefined8 *)(param_1 + 0x148) = 0x7fdfffffffffffff;\n    *(byte *)(param_1 + 0x138) = *(byte *)(param_1 + 0x138) & 0xf7 | 8;\n  }\n  if (param_7 != (char *)0x0) {\n    if (param_6 == (char *)0x0) {\n      if (param_5 < 0x76) {\n        pvVar4 = iconv_open(param_7,\"WINDOWS-1252\");\n        *(iconv_t *)(param_1 + 0x178) = pvVar4;\n      }\n      else {\n        iVar2 = strcmp(param_7,\"UTF-8\");\n        if (iVar2 != 0) {\n          pvVar4 = iconv_open(param_7,\"UTF-8\");\n          *(iconv_t *)(param_1 + 0x178) = pvVar4;\n        }\n      }\n    }\n    else {\n      pvVar4 = iconv_open(param_7,param_6);\n      *(iconv_t *)(param_1 + 0x178) = pvVar4;\n    }\n    if (*(long *)(param_1 + 0x178) == -1) {\n      *(undefined8 *)(param_1 + 0x178) = 0;\n      return 7;\n    }\n  }\n  if (param_5 < 0x77) {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 1;\n  }\n  else {\n    *(long *)(param_1 + 0x60) = (long)(*(int *)(param_1 + 0x10c) + 1) << 2;\n  }\n  lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x60));\n  *(long *)(param_1 + 0x58) = lVar3;\n  if (lVar3 == 0) {\n    return 3;\n  }\n  if (0 < *(int *)(param_1 + 0x10c)) {\n    *(long *)(param_1 + 0x40) = (long)*(int *)(param_1 + 0x10c) << 1;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x98) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x70) = *(long *)(param_1 + 0xa0) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x80) = *(long *)(param_1 + 0xa8) * (long)*(int *)(param_1 + 0x10c);\n    *(long *)(param_1 + 0x90) = *(long *)(param_1 + 0xb0) * (long)*(int *)(param_1 + 0x10c);\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x40));\n    *(long *)(param_1 + 0x38) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x50));\n    *(long *)(param_1 + 0x48) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x70));\n    *(long *)(param_1 + 0x68) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x80));\n    *(long *)(param_1 + 0x78) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n    lVar3 = readstat_malloc(*(undefined8 *)(param_1 + 0x90));\n    *(long *)(param_1 + 0x88) = lVar3;\n    if (lVar3 == 0) {\n      return 3;\n    }\n  }\n  *(undefined4 *)(param_1 + 0x1d8) = 1;\n  return 0;\n}\n\n",
        "source_ast": "{\n  \n  \n  if()return\n  if(call()){\n    \n  }\n  \n  \n  (? : )\n  \n  \n  if(){\n    if(call(, )){\n      \n      goto label\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      call(, )\n    }elseif(){\n      call(, )\n    }elseif(call(, )){\n      call(, )\n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(){\n    \n    \n    \n    \n    \n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n    if(call()){\n      \n      goto label\n    }\n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  call()\n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    \n  }\n  \n  \n  \n  if(){\n    call(, )\n    \n    if(){\n      return\n    }\n  }\n  \n  if(){\n    \n  }elseif(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    if(){\n      \n    }else{\n      \n    }\n  }else{\n    \n  }\n  if(){\n    if(){\n      \n      \n      \n    }\n  }else{\n    \n    \n    \n  }\n  if(){\n    \n  }elseif(){\n    \n  }else{\n    \n  }\n  if(){\n    \n    \n    \n  }elseif(){\n    \n    \n    \n  }else{\n    \n    \n    \n  }\n  if(){\n    \n    \n  }elseif(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n  }else{\n    \n    \n    if(){\n      \n    }else{\n      \n    }\n    \n  }\n  if(){\n    \n    \n  }else{\n    \n    \n  }\n  if(){\n    \n    \n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    \n  }\n  if(){\n    if(){\n      if(){\n        call(, )\n        \n      }else{\n        call(, )\n        if(){\n          call(, )\n          \n        }\n      }\n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      return\n    }\n  }\n  if(){\n    \n  }else{\n    \n  }\n  call()\n  \n  if(){\n    return\n  }\n  if(){\n    \n    \n    \n    \n    \n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n    call()\n    \n    if(){\n      return\n    }\n  }\n  \n  return\n}",
        "metrics": {
          "source_ppl": 1.7734375,
          "base_ppl": 1.4921875,
          "pr_ppl": 1.4921875,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 1.8359375,
          "pr_ast_ppl": 1.8359375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more readable and follows common coding conventions, making it easier to understand.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O2.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined1 auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined1 local_608 [60];\n  undefined1 local_5cc [148];\n  undefined1 local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined local_608 [60];\n  undefined local_5cc [148];\n  undefined local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.265625,
          "base_ppl": 2.078125,
          "pr_ppl": 2.078125,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.3125,
          "pr_ast_ppl": 2.3125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more idiomatic C constructs like for loops and clear variable naming, making it easier to understand.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_por-O3.so",
        "function": "readstat_parse_por",
        "source_code": "readstat_error_t readstat_parse_por(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    unsigned char reverse_lookup[256];\n    char vanity[5][40];\n    char error_buf[1024];\n\n    por_ctx_t *ctx = por_ctx_init();\n    \n    ctx->handle = parser->handlers;\n    ctx->user_ctx = user_ctx;\n    ctx->io = io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (parser->output_encoding) {\n        if (strcmp(parser->output_encoding, \"UTF-8\") != 0)\n            ctx->converter = iconv_open(parser->output_encoding, \"UTF-8\");\n\n        if (ctx->converter == (iconv_t)-1) {\n            ctx->converter = NULL;\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n    }\n    \n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n    \n    if (read_bytes(ctx, vanity, sizeof(vanity)) != sizeof(vanity)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    retval = readstat_convert(ctx->file_label, sizeof(ctx->file_label), vanity[1] + 20, 20, NULL);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if (read_bytes(ctx, reverse_lookup, sizeof(reverse_lookup)) != sizeof(reverse_lookup)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n    \n    ctx->space = reverse_lookup[126];\n\n    int i;\n\n    for (i=0; i<256; i++) {\n        if (por_ascii_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_ascii_lookup[i];\n        } else if (por_unicode_lookup[i]) {\n            ctx->byte2unicode[reverse_lookup[i]] = por_unicode_lookup[i];\n        }\n    }\n\n    ctx->byte2unicode[reverse_lookup[64]] = por_unicode_lookup[64];\n\n    unsigned char check[8];\n    char tr_check[8];\n    \n    if (read_bytes(ctx, check, sizeof(check)) != sizeof(check)) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    ssize_t encoded_len;\n\n    if ((encoded_len = por_utf8_encode(check, sizeof(check), tr_check, sizeof(tr_check), ctx->byte2unicode)) == -1) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error converting check string: %.*s\", (int)sizeof(check), check);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_CONVERT;\n        goto cleanup;\n    }\n\n    if (strncmp(\"SPSSPORT\", tr_check, encoded_len) != 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n    \n    ctx->var_offset = -1;\n    \n    char string[256];\n\n    retval = read_version_and_timestamp(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n\n    while (1) {\n        uint16_t tr_tag = read_tag(ctx);\n        switch (tr_tag) {\n            case '1': /* product ID */\n            case '2': /* author ID */\n            case '3': /* sub-product ID */\n                retval = read_string(ctx, string, sizeof(string));\n                break;\n            case '4': /* variable count */\n                retval = read_variable_count_record(ctx);\n                break;\n            case '5': /* precision */\n                retval = read_precision_record(ctx);\n                break;\n            case '6': /* case weight */\n                retval = read_case_weight_record(ctx);\n                break;\n            case '7': /* variable */\n                retval = read_variable_record(ctx);\n                break;\n            case '8': /* missing value */\n                retval = read_missing_value_record(ctx);\n                break;\n            case 'B': /* missing value range */\n                retval = read_missing_value_range_record(ctx);\n                break;\n            case '9': /* LO THRU x */\n                retval = read_missing_value_lo_range_record(ctx);\n                break;\n            case 'A': /* x THRU HI */\n                retval = read_missing_value_hi_range_record(ctx);\n                break;\n            case 'C': /* variable label */\n                retval = read_variable_label_record(ctx);\n                break;\n            case 'D': /* value label */\n                retval = read_value_label_record(ctx);\n                break;\n            case 'E': /* document record */\n                retval = read_document_record(ctx);\n                break;\n            case 'F': /* file data */\n                if (ctx->var_offset != ctx->var_count - 1) {\n                    retval = READSTAT_ERROR_COLUMN_COUNT_MISMATCH;\n                    goto cleanup;\n                }\n\n                retval = handle_variables(ctx);\n                if (retval != READSTAT_OK)\n                    goto cleanup;\n\n                if (ctx->handle.value) {\n                    retval = read_por_file_data(ctx);\n                }\n                goto cleanup;\n            default:\n                retval = READSTAT_ERROR_PARSE;\n                goto cleanup;\n        }\n        if (retval != READSTAT_OK)\n            break;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n    por_ctx_free(ctx);\n    \n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined1 auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined1 local_608 [60];\n  undefined1 local_5cc [148];\n  undefined1 local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "function_pr": "\nint readstat_parse_por(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  char *__s1;\n  undefined *puVar3;\n  undefined *puVar4;\n  undefined2 uVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  iconv_t pvVar8;\n  long lVar9;\n  size_t __n;\n  short sVar10;\n  undefined auStack_718 [8];\n  char local_710 [8];\n  byte local_708 [256];\n  undefined local_608 [60];\n  undefined local_5cc [148];\n  undefined local_538 [256];\n  char local_438 [1032];\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar7 = (undefined8 *)por_ctx_init();\n  uVar2 = param_1[1];\n  *puVar7 = *param_1;\n  puVar7[1] = uVar2;\n  puVar7[2] = param_1[2];\n  puVar7[3] = param_1[3];\n  puVar7[4] = param_1[4];\n  puVar7[5] = param_1[5];\n  puVar7[6] = param_1[6];\n  puVar7[7] = param_1[7];\n  puVar7[9] = param_3;\n  puVar7[0xb] = puVar1;\n  *(undefined4 *)(puVar7 + 0x5a) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar7 + 0x2d4) = (int)param_1[0xc];\n  }\n  __s1 = (char *)param_1[10];\n  if (__s1 != (char *)0x0) {\n    iVar6 = strcmp(__s1,\"UTF-8\");\n    if (iVar6 == 0) {\n      pvVar8 = (iconv_t)puVar7[0x55];\n    }\n    else {\n      pvVar8 = iconv_open(__s1,\"UTF-8\");\n      puVar7[0x55] = pvVar8;\n    }\n    if (pvVar8 == (iconv_t)0xffffffffffffffff) {\n      puVar7[0x55] = 0;\n      iVar6 = 7;\n      goto LAB_0010183b;\n    }\n  }\n  iVar6 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar6 == -1) {\n    iVar6 = 1;\n  }\n  else {\n    lVar9 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar7[8] = lVar9;\n    iVar6 = 0xf;\n    if ((lVar9 != -1) && (lVar9 = (*(code *)puVar1[2])(0,0,puVar1[5]), lVar9 != -1)) {\n      lVar9 = read_bytes(puVar7,local_608,200);\n      if (lVar9 == 200) {\n        iVar6 = readstat_convert((long)puVar7 + 0x89,0x15,local_5cc,0x14,0);\n        if (iVar6 != 0) goto LAB_0010183b;\n        lVar9 = read_bytes(puVar7,local_708,0x100);\n        if (lVar9 == 0x100) {\n          *(byte *)(puVar7 + 0xc) = local_708[0x7e];\n          puVar4 = PTR_por_ascii_lookup_00104fe8;\n          puVar3 = PTR_por_unicode_lookup_00104fe0;\n          lVar9 = 0;\n          do {\n            sVar10 = (short)(char)puVar4[lVar9];\n            if ((sVar10 != 0) || (sVar10 = *(short *)(puVar3 + lVar9 * 2), sVar10 != 0)) {\n              *(short *)((long)puVar7 + (ulong)local_708[lVar9] * 2 + 0x9e) = sVar10;\n            }\n            lVar9 = lVar9 + 1;\n          } while (lVar9 != 0x100);\n          *(undefined2 *)((long)puVar7 + (ulong)local_708[0x40] * 2 + 0x9e) =\n               *(undefined2 *)(puVar3 + 0x80);\n          lVar9 = read_bytes(puVar7,auStack_718,8);\n          iVar6 = 2;\n          if (lVar9 == 8) {\n            __n = por_utf8_encode(auStack_718,8,local_710,8,(long)puVar7 + 0x9e);\n            if (__n == 0xffffffffffffffff) {\n              iVar6 = 0x10;\n              if (puVar7[6] != 0) {\n                snprintf(local_438,0x400,\"Error converting check string: %.*s\",8,auStack_718);\n                (*(code *)puVar7[6])(local_438,puVar7[9]);\n              }\n            }\n            else {\n              iVar6 = strncmp(\"SPSSPORT\",local_710,__n);\n              if (iVar6 == 0) {\n                *(undefined4 *)((long)puVar7 + 0x2cc) = 0xffffffff;\n                iVar6 = read_version_and_timestamp(puVar7);\n                if (iVar6 == 0) {\n                  do {\n                    uVar5 = read_tag(puVar7);\n                    switch(uVar5) {\n                    case 0x31:\n                    case 0x32:\n                    case 0x33:\n                      iVar6 = read_string(puVar7,local_538,0x100);\n                      break;\n                    case 0x34:\n                      iVar6 = read_variable_count_record(puVar7);\n                      break;\n                    case 0x35:\n                      iVar6 = read_precision_record(puVar7);\n                      break;\n                    case 0x36:\n                      iVar6 = read_case_weight_record(puVar7);\n                      break;\n                    case 0x37:\n                      iVar6 = read_variable_record(puVar7);\n                      break;\n                    case 0x38:\n                      iVar6 = read_missing_value_record(puVar7);\n                      break;\n                    case 0x39:\n                      iVar6 = read_missing_value_lo_range_record(puVar7);\n                      break;\n                    default:\n                      goto switchD_00101979_caseD_3a;\n                    case 0x41:\n                      iVar6 = read_missing_value_hi_range_record(puVar7);\n                      break;\n                    case 0x42:\n                      iVar6 = read_missing_value_range_record(puVar7);\n                      break;\n                    case 0x43:\n                      iVar6 = read_variable_label_record(puVar7);\n                      break;\n                    case 0x44:\n                      iVar6 = read_value_label_record(puVar7);\n                      break;\n                    case 0x45:\n                      iVar6 = read_document_record(puVar7);\n                      break;\n                    case 0x46:\n                      iVar6 = 8;\n                      if ((*(int *)((long)puVar7 + 0x2cc) == *(int *)(puVar7 + 0x59) + -1) &&\n                         (iVar6 = handle_variables(puVar7), iVar6 == 0)) {\n                        if (puVar7[4] == 0) {\n                          iVar6 = 0;\n                        }\n                        else {\n                          iVar6 = read_por_file_data(puVar7);\n                        }\n                      }\n                      goto LAB_0010183b;\n                    }\n                  } while (iVar6 == 0);\n                }\n              }\n              else {\nswitchD_00101979_caseD_3a:\n                iVar6 = 5;\n              }\n            }\n          }\n          goto LAB_0010183b;\n        }\n      }\n      iVar6 = 2;\n    }\n  }\nLAB_0010183b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  por_ctx_free(puVar7);\n  return iVar6;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  if()\n  if(){\n    if(call(, ))call(, )\n    if(){\n      \n      \n      goto label\n    }\n  }\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , , , )\n  if()goto label\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  for(;;){\n    if(){\n      \n    }elseif(){\n      \n    }\n  }\n  \n  \n  \n  if(call(, , )){\n    \n    goto label\n  }\n  \n  if(call(, , , , )){\n    if(){\n      call(, , , , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    goto label\n  }\n  \n  \n  call()\n  if()goto label\n  while(){\n    call()\n    switch(){\n      case :\n      \n      case :\n      \n      case :\n        \n        call(, , )\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        call()\n        \n      case :\n        \n        if(){\n          \n          goto label\n        }\n        call()\n        if()goto label\n        if(){\n          call()\n        }\n        goto label\n      case :\n        \n        \n        goto label\n    }\n    if()\n  }\n  call()\n  call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  \n  if(){\n    call(, )\n    if(){\n      \n    }else{\n      call(, )\n      \n    }\n    if(){\n      \n      \n      goto label\n    }\n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    \n    if(call(, , )){\n      call(, , )\n      if(){\n        call(, , , , )\n        if()goto label\n        call(, , )\n        if(){\n          \n          \n          \n          \n          do{\n            \n            if(){\n              \n            }\n            \n          }while()\n          \n          call(, , )\n          \n          if(){\n            call(, , , , )\n            if(){\n              \n              if(){\n                call(, , , , )\n                call(, )\n              }\n            }else{\n              call(, , )\n              if(){\n                \n                call()\n                if(){\n                  do{\n                    call()\n                    switch(){\n                      case :\n                      case :\n                      case :\n                        call(, , )\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        goto label\n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        call()\n                        \n                      case :\n                        \n                        if(call()){\n                          if(){\n                            \n                          }else{\n                            call()\n                          }\n                        }\n                        goto label\n                    }\n                  }while()\n                }\n              }else{\n                \n              }\n            }\n          }\n          goto label\n        }\n      }\n      \n    }\n  }\n  call()\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.265625,
          "base_ppl": 2.078125,
          "pr_ppl": 2.078125,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.3125,
          "pr_ast_ppl": 2.3125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a clear, loop-based structure for parsing tags, making it more readable and resembling typical C code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O0.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  uint uVar3;\n  int iVar4;\n  long lVar5;\n  int *local_60;\n  int local_3c;\n  \n  if (param_4 <= *param_3) {\n    return 10;\n  }\n  uVar1 = *param_3;\n  do {\n    local_3c = 0;\n    if (param_4 <= *param_3) goto LAB_001016a7;\n    switch(*param_1) {\n    case 0:\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      *param_1 = 1;\n      break;\n    case 1:\n      local_3c = lzma_vli_decode(param_1 + 0x46,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) goto LAB_001016a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      iVar4 = 2;\n      if (*(long *)(param_1 + 0x46) == 0) {\n        iVar4 = 4;\n      }\n      *param_1 = iVar4;\n      break;\n    case 2:\n    case 3:\n      if (*param_1 == 2) {\n        local_60 = param_1 + 0x48;\n      }\n      else {\n        local_60 = param_1 + 0x4a;\n      }\n      local_3c = lzma_vli_decode(local_60,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) {\nLAB_001016a7:\n        if (*param_3 - uVar1 != 0) {\n          iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n          param_1[0x4e] = iVar4;\n        }\n        return local_3c;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        if ((*(ulong *)(param_1 + 0x48) < 5) || (0x7ffffffffffffffc < *(ulong *)(param_1 + 0x48))) {\n          return 9;\n        }\n        *param_1 = 3;\n      }\n      else {\n        hash_append(param_1 + 0x24,*(undefined8 *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (((*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) ||\n            (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26))) ||\n           (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lVar5 = *(long *)(param_1 + 0x46);\n        *(long *)(param_1 + 0x46) = lVar5 + -1;\n        iVar4 = 2;\n        if (lVar5 + -1 == 0) {\n          iVar4 = 4;\n        }\n        *param_1 = iVar4;\n      }\n      break;\n    case 4:\n      lVar5 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      *(ulong *)(param_1 + 0x4c) = 4U - lVar5 & 3;\n      *param_1 = 5;\n    case 5:\n      if (*(long *)(param_1 + 0x4c) == 0) {\n        if (((*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) ||\n            (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26))) ||\n           (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar3 = lzma_check_size(10);\n        iVar4 = memcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar3);\n        if (iVar4 != 0) {\n          return 9;\n        }\n        iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n        param_1[0x4e] = iVar4;\n        *param_1 = 6;\nswitchD_001011ee_caseD_6:\n        while( true ) {\n          if (*param_3 == param_4) {\n            return 0;\n          }\n          uVar3 = param_1[0x4e];\n          lVar5 = *(long *)(param_1 + 0x4c);\n          uVar1 = *param_3;\n          *param_3 = uVar1 + 1;\n          if ((uVar3 >> ((byte)(lVar5 << 3) & 0x1f) & 0xff) != (uint)*(byte *)(param_2 + uVar1))\n          break;\n          lVar5 = *(long *)(param_1 + 0x4c);\n          *(ulong *)(param_1 + 0x4c) = lVar5 + 1U;\n          if (3 < lVar5 + 1U) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *(long *)(param_1 + 0x4c) = *(long *)(param_1 + 0x4c) + -1;\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      break;\n    case 6:\n      goto switchD_001011ee_caseD_6;\n    default:\n      return 0xb;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  uint uVar3;\n  int iVar4;\n  long lVar5;\n  int *local_60;\n  int local_3c;\n  \n  if (param_4 <= *param_3) {\n    return 10;\n  }\n  uVar1 = *param_3;\n  do {\n    local_3c = 0;\n    if (param_4 <= *param_3) goto LAB_001016a7;\n    switch(*param_1) {\n    case 0:\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      *param_1 = 1;\n      break;\n    case 1:\n      local_3c = lzma_vli_decode(param_1 + 0x46,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) goto LAB_001016a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      iVar4 = 2;\n      if (*(long *)(param_1 + 0x46) == 0) {\n        iVar4 = 4;\n      }\n      *param_1 = iVar4;\n      break;\n    case 2:\n    case 3:\n      if (*param_1 == 2) {\n        local_60 = param_1 + 0x48;\n      }\n      else {\n        local_60 = param_1 + 0x4a;\n      }\n      local_3c = lzma_vli_decode(local_60,param_1 + 0x4c,param_2,param_3,param_4);\n      if (local_3c != 1) {\nLAB_001016a7:\n        if (*param_3 - uVar1 != 0) {\n          iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n          param_1[0x4e] = iVar4;\n        }\n        return local_3c;\n      }\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        if ((*(ulong *)(param_1 + 0x48) < 5) || (0x7ffffffffffffffc < *(ulong *)(param_1 + 0x48))) {\n          return 9;\n        }\n        *param_1 = 3;\n      }\n      else {\n        hash_append(param_1 + 0x24,*(undefined8 *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (((*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) ||\n            (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26))) ||\n           (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lVar5 = *(long *)(param_1 + 0x46);\n        *(long *)(param_1 + 0x46) = lVar5 + -1;\n        iVar4 = 2;\n        if (lVar5 + -1 == 0) {\n          iVar4 = 4;\n        }\n        *param_1 = iVar4;\n      }\n      break;\n    case 4:\n      lVar5 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      *(ulong *)(param_1 + 0x4c) = 4U - lVar5 & 3;\n      *param_1 = 5;\n    case 5:\n      if (*(long *)(param_1 + 0x4c) == 0) {\n        if (((*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) ||\n            (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26))) ||\n           (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a))) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar3 = lzma_check_size(10);\n        iVar4 = memcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar3);\n        if (iVar4 != 0) {\n          return 9;\n        }\n        iVar4 = lzma_crc32(param_2 + uVar1,*param_3 - uVar1,param_1[0x4e]);\n        param_1[0x4e] = iVar4;\n        *param_1 = 6;\nLAB_001015f6:\n        while( true ) {\n          if (*param_3 == param_4) {\n            return 0;\n          }\n          uVar3 = param_1[0x4e];\n          lVar5 = *(long *)(param_1 + 0x4c);\n          uVar1 = *param_3;\n          *param_3 = uVar1 + 1;\n          if ((uVar3 >> ((byte)(lVar5 << 3) & 0x1f) & 0xff) != (uint)*(byte *)(param_2 + uVar1))\n          break;\n          lVar5 = *(long *)(param_1 + 0x4c);\n          *(ulong *)(param_1 + 0x4c) = lVar5 + 1U;\n          if (3 < lVar5 + 1U) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *(long *)(param_1 + 0x4c) = *(long *)(param_1 + 0x4c) + -1;\n      uVar2 = *param_3;\n      *param_3 = uVar2 + 1;\n      if (*(char *)(param_2 + uVar2) != '\\0') {\n        return 9;\n      }\n      break;\n    case 6:\n      goto LAB_001015f6;\n    default:\n      return 0xb;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  if()return\n  \n  \n  \n  \n  \n  while()switch(){\n    case :\n      \n      if()return\n      \n      \n    case :\n      {\n        call(, , , , )\n        if()goto label\n        \n        if()return\n        \n        \n        \n        (? : )\n        \n      }\n    case :\n    case :\n      {\n        (? : )\n        call(, , , , )\n        if()goto label\n        \n        \n        if(){\n          if()return\n          \n        }else{\n          \n          call(, , )\n          \n          \n          \n          \n          \n          \n          if()return\n          \n          (? : )\n        }\n        \n      }\n    case :\n      call()call(, )\n      \n      \n    case :\n      if(){\n        \n        if()return\n        \n      }\n      \n      if()return\n      \n      call(, )\n      call(, )\n      if(call(, , call()))return\n      \n      call(, , )\n      \n      \n    case :\n      do{\n        if()return\n        if(){\n          return\n        }\n      }while()\n      return\n    case :\n      \n      call()\n      return\n  }\n  {\n    \n    if()call(, , )\n  }\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  \n  do{\n    \n    if()goto label\n    switch(){\n      case :\n        \n        \n        if(){\n          return\n        }\n        \n        \n      case :\n        call(, , , , )\n        if()goto label\n        if(){\n          return\n        }\n        \n        \n        \n        if(){\n          \n        }\n        \n        \n      case :\n      case :\n        if(){\n          \n        }else{\n          \n        }\n        call(, , , , )\n        if(){\n          if(){\n            call(, , )\n            \n          }\n          return\n        }\n        \n        \n        if(){\n          if(){\n            return\n          }\n          \n        }else{\n          call(, , )\n          if(){\n            return\n          }\n          \n          \n          \n          if(){\n            \n          }\n          \n        }\n        \n      case :\n        call(, )\n        \n        \n      case :\n        if(){\n          if(){\n            return\n          }\n          call(, )\n          call(, )\n          call()\n          call(, , )\n          if(){\n            return\n          }\n          call(, , )\n          \n          \n          while(){\n            if(){\n              return\n            }\n            \n            \n            \n            \n            if(call())\n            \n            \n            if(){\n              return\n            }\n          }\n          return\n        }\n        \n        \n        \n        if(){\n          return\n        }\n        \n      case :\n        goto label\n      case :\n        \n        return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  if(){\n    return\n  }\n  \n  do{\n    \n    if()goto label\n    switch(){\n      case :\n        \n        \n        if(){\n          return\n        }\n        \n        \n      case :\n        call(, , , , )\n        if()goto label\n        if(){\n          return\n        }\n        \n        \n        \n        if(){\n          \n        }\n        \n        \n      case :\n      case :\n        if(){\n          \n        }else{\n          \n        }\n        call(, , , , )\n        if(){\n          if(){\n            call(, , )\n            \n          }\n          return\n        }\n        \n        \n        if(){\n          if(){\n            return\n          }\n          \n        }else{\n          call(, , )\n          if(){\n            return\n          }\n          \n          \n          \n          if(){\n            \n          }\n          \n        }\n        \n      case :\n        call(, )\n        \n        \n      case :\n        if(){\n          if(){\n            return\n          }\n          call(, )\n          call(, )\n          call()\n          call(, , )\n          if(){\n            return\n          }\n          call(, , )\n          \n          \n          while(){\n            if(){\n              return\n            }\n            \n            \n            \n            \n            if(call())\n            \n            \n            if(){\n              return\n            }\n          }\n          return\n        }\n        \n        \n        \n        if(){\n          return\n        }\n        \n      case :\n        goto label\n      case :\n        \n        return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 2.578125,
          "base_ppl": 1.890625,
          "pr_ppl": 1.8515625,
          "source_ast_ppl": 3.65625,
          "base_ast_ppl": 2.703125,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": -0.0390625
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while missing some semantic accuracy, presents a more structured and readable code flow compared to Candidate A's repetitive goto statements.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_dta-O2.so",
        "function": "readstat_parse_dta",
        "source_code": "readstat_error_t readstat_parse_dta(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n    int i;\n    dta_ctx_t    *ctx;\n    size_t file_size = 0;\n\n    ctx = dta_ctx_alloc(io);\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    char magic[4];\n    if (io->read(magic, 4, io->io_ctx) != 4) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx);\n    if (file_size == -1) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"Failed to seek to start of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_SEEK;\n        goto cleanup;\n    }\n\n    if (strncmp(magic, \"<sta\", 4) == 0) {\n        dta_header64_t header;\n        if ((retval = dta_read_xmlish_header(ctx, &header)) != READSTAT_OK) {\n            goto cleanup;\n        }\n        retval = dta_ctx_init(ctx, header.nvar, header.nobs, header.byteorder, header.ds_format,\n                parser->input_encoding, parser->output_encoding);\n    } else {\n        dta_header_t header;\n        if ((retval = dta_read_header(ctx, &header)) != READSTAT_OK) {\n            goto cleanup;\n        }\n        retval = dta_ctx_init(ctx, header.nvar, header.nobs, header.byteorder, header.ds_format,\n                parser->input_encoding, parser->output_encoding);\n    }\n    if (retval != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->user_ctx = user_ctx;\n    ctx->file_size = file_size;\n    ctx->handle = parser->handlers;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n    int64_t nobs_after_skipping = ctx->nobs - ctx->row_offset;\n    if (nobs_after_skipping < 0) {\n        nobs_after_skipping = 0;\n        ctx->row_offset = ctx->nobs;\n    }\n    ctx->row_limit = nobs_after_skipping;\n    if (parser->row_limit > 0 && parser->row_limit < nobs_after_skipping)\n        ctx->row_limit = parser->row_limit;\n\n    retval = dta_update_progress(ctx);\n    if (retval != READSTAT_OK)\n        goto cleanup;\n    \n    if ((retval = dta_read_label_and_timestamp(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_read_tag(ctx, \"</header>\")) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.metadata) {\n        readstat_metadata_t metadata = {\n            .row_count = ctx->row_limit,\n            .var_count = ctx->nvar,\n            .file_label = ctx->data_label,\n            .creation_time = ctx->timestamp,\n            .modified_time = ctx->timestamp,\n            .file_format_version = ctx->ds_format,\n            .is64bit = ctx->ds_format >= 118,\n            .endianness = ctx->endianness\n        };\n        if (ctx->handle.metadata(&metadata, user_ctx) != READSTAT_HANDLER_OK) {\n            retval = READSTAT_ERROR_USER_ABORT;\n            goto cleanup;\n        }\n    }\n\n    if ((retval = dta_read_map(ctx)) != READSTAT_OK) {\n        retval = READSTAT_ERROR_READ;\n        goto cleanup;\n    }\n\n    if ((retval = dta_read_descriptors(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    for (i=0; i<ctx->nvar; i++) {\n        size_t      max_len;\n        if ((retval = dta_type_info(ctx->typlist[i], ctx, &max_len, NULL)) != READSTAT_OK)\n            goto cleanup;\n\n        ctx->record_len += max_len;\n    }\n\n    if ((ctx->nvar > 0 || ctx->nobs > 0) && ctx->record_len == 0) {\n        retval = READSTAT_ERROR_PARSE;\n        goto cleanup;\n    }\n\n    if ((retval = dta_handle_variables(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_read_expansion_fields(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if (!ctx->file_is_xmlish) {\n        ctx->data_offset = io->seek(0, READSTAT_SEEK_CUR, io->io_ctx);\n        if (ctx->data_offset == -1) {\n            retval = READSTAT_ERROR_SEEK;\n            goto cleanup;\n        }\n        ctx->value_labels_offset = ctx->data_offset + ctx->record_len * ctx->nobs;\n    }\n\n    if ((retval = dta_read_strls(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_read_data(ctx)) != READSTAT_OK)\n        goto cleanup;\n\n    if ((retval = dta_handle_value_labels(ctx)) != READSTAT_OK)\n        goto cleanup;\n\ncleanup:\n    io->close(io->io_ctx);\n    if (ctx)\n        dta_ctx_free(ctx);\n\n    return retval;\n}\n",
        "function_base": "\nint readstat_parse_dta(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long lVar6;\n  code *pcVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  long lVar10;\n  uint uVar11;\n  int local_94;\n  undefined8 local_90;\n  ulong local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  long local_70;\n  undefined4 local_68;\n  undefined4 local_64;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined1 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar4 = (undefined8 *)dta_ctx_alloc(puVar1);\n  iVar2 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar2 == -1) {\n    iVar2 = 1;\n    goto LAB_0010154b;\n  }\n  lVar5 = (*(code *)puVar1[3])(&local_94,4,puVar1[5]);\n  iVar2 = 2;\n  if (lVar5 != 4) goto LAB_0010154b;\n  lVar5 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n  if (lVar5 == -1) {\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 0x1f2) = 0x656c696620666f;\n    uVar8 = 0x666f20646e65206f;\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    if (lVar6 != -1) {\n      if (local_94 == 0x6174733c) {\n        iVar2 = dta_read_xmlish_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88;\n        uVar11 = local_90._4_4_;\n      }\n      else {\n        iVar2 = dta_read_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88 & 0xffffffff;\n        uVar11 = (uint)local_90._4_2_;\n      }\n      iVar2 = dta_ctx_init(puVar4,uVar11,uVar9,local_90._1_1_,local_90 & 0xff,param_1[9],param_1[10]\n                          );\n      if (iVar2 != 0) goto LAB_0010154b;\n      puVar4[0x39] = param_3;\n      puVar4[0x38] = lVar5;\n      puVar4[0x37] = param_1[7];\n      puVar4[0x36] = param_1[6];\n      puVar4[0x35] = param_1[5];\n      puVar4[0x34] = param_1[4];\n      puVar4[0x33] = param_1[3];\n      puVar4[0x32] = param_1[2];\n      uVar8 = *param_1;\n      puVar4[0x31] = param_1[1];\n      puVar4[0x30] = uVar8;\n      lVar5 = param_1[0xc];\n      if (lVar5 < 1) {\n        lVar5 = puVar4[0x25];\n      }\n      else {\n        puVar4[0x25] = lVar5;\n      }\n      lVar5 = puVar4[0x22] - lVar5;\n      if (lVar5 < 0) {\n        puVar4[0x25] = puVar4[0x22];\n        lVar5 = 0;\n      }\n      lVar6 = param_1[0xb];\n      lVar10 = lVar5;\n      if (lVar6 < lVar5) {\n        lVar10 = lVar6;\n      }\n      if (lVar6 < 1) {\n        lVar10 = lVar5;\n      }\n      puVar4[0x24] = lVar10;\n      iVar2 = dta_update_progress(puVar4);\n      if (((iVar2 != 0) || (iVar2 = dta_read_label_and_timestamp(puVar4), iVar2 != 0)) ||\n         (iVar2 = dta_read_tag(puVar4,\"</header>\"), iVar2 != 0)) goto LAB_0010154b;\n      if ((code *)puVar4[0x30] != (code *)0x0) {\n        local_90 = puVar4[0x24];\n        local_88 = (ulong)*(int *)((long)puVar4 + 0x10c);\n        local_80 = puVar4[3];\n        local_70 = (long)*(int *)(puVar4 + 0x21);\n        local_68 = 0;\n        local_64 = *(undefined4 *)(puVar4 + 0x2e);\n        local_60 = 0;\n        local_58 = *puVar4;\n        local_50 = 0;\n        local_48 = 0x75 < local_70;\n        local_40 = 0;\n        local_38 = 0;\n        local_78 = local_80;\n        iVar3 = (*(code *)puVar4[0x30])(&local_90,param_3);\n        iVar2 = 4;\n        if (iVar3 != 0) goto LAB_0010154b;\n      }\n      iVar3 = dta_read_map(puVar4);\n      iVar2 = 2;\n      if ((iVar3 != 0) || (iVar2 = dta_read_descriptors(puVar4), iVar2 != 0)) goto LAB_0010154b;\n      if (*(int *)((long)puVar4 + 0x10c) < 1) {\nLAB_00101689:\n        if (0 < (long)puVar4[0x22]) goto LAB_00101693;\n      }\n      else {\n        lVar5 = 0;\n        do {\n          iVar2 = dta_type_info(*(undefined2 *)(puVar4[7] + lVar5 * 2),puVar4,&local_90,0);\n          if (iVar2 != 0) goto LAB_0010154b;\n          puVar4[0x23] = puVar4[0x23] + local_90;\n          lVar5 = lVar5 + 1;\n        } while (lVar5 < *(int *)((long)puVar4 + 0x10c));\n        if (*(int *)((long)puVar4 + 0x10c) < 1) goto LAB_00101689;\nLAB_00101693:\n        if (puVar4[0x23] == 0) {\n          iVar2 = 5;\n          goto LAB_0010154b;\n        }\n      }\n      iVar2 = dta_handle_variables(puVar4);\n      if ((iVar2 == 0) && (iVar2 = dta_read_expansion_fields(puVar4), iVar2 == 0)) {\n        if ((*(byte *)(puVar4 + 0x27) & 4) == 0) {\n          lVar5 = (*(code *)puVar1[2])(0,1,puVar1[5]);\n          puVar4[0x1e] = lVar5;\n          if (lVar5 == -1) {\n            iVar2 = 0xf;\n            goto LAB_0010154b;\n          }\n          puVar4[0x20] = puVar4[0x22] * puVar4[0x23] + lVar5;\n        }\n        iVar2 = dta_read_strls(puVar4);\n        if ((iVar2 == 0) && (iVar2 = dta_read_data(puVar4), iVar2 == 0)) {\n          iVar2 = dta_handle_value_labels(puVar4);\n        }\n      }\n      goto LAB_0010154b;\n    }\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 500) = 0x656c696620666f;\n    uVar8 = 0x207472617473206f;\n  }\n  iVar2 = 0xf;\n  *(undefined8 *)((long)puVar4 + 0x1ec) = uVar8;\n  *(undefined8 *)((long)puVar4 + 0x1e4) = 0x74206b656573206f;\n  *(undefined8 *)((long)puVar4 + 0x1dc) = 0x742064656c696146;\n  (*pcVar7)((long)puVar4 + 0x1dc,puVar4[0x39]);\nLAB_0010154b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if (puVar4 != (undefined8 *)0x0) {\n    dta_ctx_free(puVar4);\n  }\n  return iVar2;\n}\n\n",
        "function_pr": "\nint readstat_parse_dta(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long lVar6;\n  code *pcVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  long lVar10;\n  uint uVar11;\n  int local_94;\n  undefined8 local_90;\n  ulong local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  long local_70;\n  undefined4 local_68;\n  undefined4 local_64;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  \n  puVar1 = (undefined8 *)param_1[8];\n  puVar4 = (undefined8 *)dta_ctx_alloc(puVar1);\n  iVar2 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar2 == -1) {\n    iVar2 = 1;\n    goto LAB_0010154b;\n  }\n  lVar5 = (*(code *)puVar1[3])(&local_94,4,puVar1[5]);\n  iVar2 = 2;\n  if (lVar5 != 4) goto LAB_0010154b;\n  lVar5 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n  if (lVar5 == -1) {\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 0x1f2) = 0x656c696620666f;\n    uVar8 = 0x666f20646e65206f;\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    if (lVar6 != -1) {\n      if (local_94 == 0x6174733c) {\n        iVar2 = dta_read_xmlish_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88;\n        uVar11 = local_90._4_4_;\n      }\n      else {\n        iVar2 = dta_read_header(puVar4,&local_90);\n        if (iVar2 != 0) goto LAB_0010154b;\n        uVar9 = local_88 & 0xffffffff;\n        uVar11 = (uint)local_90._4_2_;\n      }\n      iVar2 = dta_ctx_init(puVar4,uVar11,uVar9,local_90._1_1_,local_90 & 0xff,param_1[9],param_1[10]\n                          );\n      if (iVar2 != 0) goto LAB_0010154b;\n      puVar4[0x39] = param_3;\n      puVar4[0x38] = lVar5;\n      puVar4[0x37] = param_1[7];\n      puVar4[0x36] = param_1[6];\n      puVar4[0x35] = param_1[5];\n      puVar4[0x34] = param_1[4];\n      puVar4[0x33] = param_1[3];\n      puVar4[0x32] = param_1[2];\n      uVar8 = *param_1;\n      puVar4[0x31] = param_1[1];\n      puVar4[0x30] = uVar8;\n      lVar5 = param_1[0xc];\n      if (lVar5 < 1) {\n        lVar5 = puVar4[0x25];\n      }\n      else {\n        puVar4[0x25] = lVar5;\n      }\n      lVar5 = puVar4[0x22] - lVar5;\n      if (lVar5 < 0) {\n        puVar4[0x25] = puVar4[0x22];\n        lVar5 = 0;\n      }\n      lVar6 = param_1[0xb];\n      lVar10 = lVar5;\n      if (lVar6 < lVar5) {\n        lVar10 = lVar6;\n      }\n      if (lVar6 < 1) {\n        lVar10 = lVar5;\n      }\n      puVar4[0x24] = lVar10;\n      iVar2 = dta_update_progress(puVar4);\n      if (((iVar2 != 0) || (iVar2 = dta_read_label_and_timestamp(puVar4), iVar2 != 0)) ||\n         (iVar2 = dta_read_tag(puVar4,\"</header>\"), iVar2 != 0)) goto LAB_0010154b;\n      if ((code *)puVar4[0x30] != (code *)0x0) {\n        local_90 = puVar4[0x24];\n        local_88 = (ulong)*(int *)((long)puVar4 + 0x10c);\n        local_80 = puVar4[3];\n        local_70 = (long)*(int *)(puVar4 + 0x21);\n        local_68 = 0;\n        local_64 = *(undefined4 *)(puVar4 + 0x2e);\n        local_60 = 0;\n        local_58 = *puVar4;\n        local_50 = 0;\n        local_48 = 0x75 < local_70;\n        local_40 = 0;\n        local_38 = 0;\n        local_78 = local_80;\n        iVar3 = (*(code *)puVar4[0x30])(&local_90,param_3);\n        iVar2 = 4;\n        if (iVar3 != 0) goto LAB_0010154b;\n      }\n      iVar3 = dta_read_map(puVar4);\n      iVar2 = 2;\n      if ((iVar3 != 0) || (iVar2 = dta_read_descriptors(puVar4), iVar2 != 0)) goto LAB_0010154b;\n      if (*(int *)((long)puVar4 + 0x10c) < 1) {\nLAB_00101689:\n        if (0 < (long)puVar4[0x22]) goto LAB_00101693;\n      }\n      else {\n        lVar5 = 0;\n        do {\n          iVar2 = dta_type_info(*(undefined2 *)(puVar4[7] + lVar5 * 2),puVar4,&local_90,0);\n          if (iVar2 != 0) goto LAB_0010154b;\n          puVar4[0x23] = puVar4[0x23] + local_90;\n          lVar5 = lVar5 + 1;\n        } while (lVar5 < *(int *)((long)puVar4 + 0x10c));\n        if (*(int *)((long)puVar4 + 0x10c) < 1) goto LAB_00101689;\nLAB_00101693:\n        if (puVar4[0x23] == 0) {\n          iVar2 = 5;\n          goto LAB_0010154b;\n        }\n      }\n      iVar2 = dta_handle_variables(puVar4);\n      if ((iVar2 == 0) && (iVar2 = dta_read_expansion_fields(puVar4), iVar2 == 0)) {\n        if ((*(byte *)(puVar4 + 0x27) & 4) == 0) {\n          lVar5 = (*(code *)puVar1[2])(0,1,puVar1[5]);\n          puVar4[0x1e] = lVar5;\n          if (lVar5 == -1) {\n            iVar2 = 0xf;\n            goto LAB_0010154b;\n          }\n          puVar4[0x20] = puVar4[0x22] * puVar4[0x23] + lVar5;\n        }\n        iVar2 = dta_read_strls(puVar4);\n        if ((iVar2 == 0) && (iVar2 = dta_read_data(puVar4), iVar2 == 0)) {\n          iVar2 = dta_handle_value_labels(puVar4);\n        }\n      }\n      goto LAB_0010154b;\n    }\n    pcVar7 = (code *)puVar4[0x36];\n    iVar2 = 0xf;\n    if (pcVar7 == (code *)0x0) goto LAB_0010154b;\n    *(undefined8 *)((long)puVar4 + 500) = 0x656c696620666f;\n    uVar8 = 0x207472617473206f;\n  }\n  iVar2 = 0xf;\n  *(undefined8 *)((long)puVar4 + 0x1ec) = uVar8;\n  *(undefined8 *)((long)puVar4 + 0x1e4) = 0x74206b656573206f;\n  *(undefined8 *)((long)puVar4 + 0x1dc) = 0x742064656c696146;\n  (*pcVar7)((long)puVar4 + 0x1dc,puVar4[0x39]);\nLAB_0010154b:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if (puVar4 != (undefined8 *)0x0) {\n    dta_ctx_free(puVar4);\n  }\n  return iVar2;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  call()\n  if(call(, )){\n    \n    goto label\n  }\n  \n  if(call(, , )){\n    \n    goto label\n  }\n  call(, , )\n  if(){\n    if(){\n      call(, , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    if(){\n      call(, , )\n      call(, )\n    }\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(call(, )){\n      goto label\n    }\n    call(, , , , , , )\n  }else{\n    \n    if(call(, )){\n      goto label\n    }\n    call(, , , , , , )\n  }\n  if(){\n    goto label\n  }\n  \n  \n  \n  if()\n  \n  if(){\n    \n    \n  }\n  \n  if()\n  call()\n  if()goto label\n  if(call())goto label\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(call(, )){\n      \n      goto label\n    }\n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  for(;;){\n    \n    if(call(, , , ))goto label\n    \n  }\n  if(){\n    \n    goto label\n  }\n  if(call())goto label\n  if(call())goto label\n  if(){\n    call(, , )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call())goto label\n  if(call())goto label\n  if(call())goto label\n  call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  if(){\n    \n    goto label\n  }\n  call(, , )\n  \n  if()goto label\n  call(, , )\n  if(){\n    \n    \n    if()goto label\n    \n    \n  }else{\n    call(, , )\n    if(){\n      if(){\n        call(, )\n        if()goto label\n        \n        \n      }else{\n        call(, )\n        if()goto label\n        \n        \n      }\n      call(, , , , , , )\n      if()goto label\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      if(){\n        \n      }else{\n        \n      }\n      \n      if(){\n        \n        \n      }\n      \n      \n      if(){\n        \n      }\n      if(){\n        \n      }\n      \n      call()\n      if(call()call(, ))goto label\n      if(){\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        call(, )\n        \n        if()goto label\n      }\n      call()\n      \n      if(call())goto label\n      if(){\n        if()goto label\n      }else{\n        \n        do{\n          call(, , , )\n          if()goto label\n          \n          \n        }while()\n        if()goto label\n        if(){\n          \n          goto label\n        }\n      }\n      call()\n      if(call()){\n        if(){\n          call(, , )\n          \n          if(){\n            \n            goto label\n          }\n          \n        }\n        call()\n        if(call()){\n          call()\n        }\n      }\n      goto label\n    }\n    \n    \n    if()goto label\n    \n    \n  }\n  \n  \n  \n  \n  call(, )\n  call()\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  if(){\n    \n    goto label\n  }\n  call(, , )\n  \n  if()goto label\n  call(, , )\n  if(){\n    \n    \n    if()goto label\n    \n    \n  }else{\n    call(, , )\n    if(){\n      if(){\n        call(, )\n        if()goto label\n        \n        \n      }else{\n        call(, )\n        if()goto label\n        \n        \n      }\n      call(, , , , , , )\n      if()goto label\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      if(){\n        \n      }else{\n        \n      }\n      \n      if(){\n        \n        \n      }\n      \n      \n      if(){\n        \n      }\n      if(){\n        \n      }\n      \n      call()\n      if(call()call(, ))goto label\n      if(){\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        call(, )\n        \n        if()goto label\n      }\n      call()\n      \n      if(call())goto label\n      if(){\n        if()goto label\n      }else{\n        \n        do{\n          call(, , , )\n          if()goto label\n          \n          \n        }while()\n        if()goto label\n        if(){\n          \n          goto label\n        }\n      }\n      call()\n      if(call()){\n        if(){\n          call(, , )\n          \n          if(){\n            \n            goto label\n          }\n          \n        }\n        call()\n        if(call()){\n          call()\n        }\n      }\n      goto label\n    }\n    \n    \n    if()goto label\n    \n    \n  }\n  \n  \n  \n  \n  call(, )\n  call()\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.046875,
          "base_ppl": 1.9375,
          "pr_ppl": 1.9375,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.453125,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses modern C structures and conventions, making it more readable and maintainable.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      }
    ]
  }
}