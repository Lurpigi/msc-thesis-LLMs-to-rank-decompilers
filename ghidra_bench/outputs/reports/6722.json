{
  "pr": "6722",
  "mean_delta_perplexity": -0.0121875,
  "mean_perplexity_base": 1.8484375,
  "mean_perplexity_pr": 1.83625,
  "mean_perplexity_source": 1.9709375,
  "mean_perplexity_base_ast": 2.3540625,
  "mean_perplexity_pr_ast": 2.35125,
  "mean_perplexity_source_ast": 2.5328125,
  "results": {
    "qwen-3": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)*(type)(id + 1));\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = (type)call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = (id) * (type)id;\n            *(type)((type)id + 0xd) = *(type)id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (id) * (type)(id + 5));\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (id) * (type)(id + 6));\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (id) * (type)(id + id * 2 + 1), (id) * (type)((type)id + id * 4 + 3), (id) * (type)(id + id * 2 + 2));\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (id) * (type)(id + 1));\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.078125,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.296875,
          "base_ast_ppl": 2.25,
          "pr_ast_ppl": 2.21875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses array notation (param_1[1]) and simpler casts, which aligns with idiomatic C practices for array access. This approach abstracts pointer arithmetic, making the code more readable and closer to high-level human thinking. Candidate B's explicit pointer arithmetic and casts, while functionally equivalent, lean toward lower-level machine-like operations, reducing clarity for human readers.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A uses array notation (param_1[1]) which aligns more closely with the source code's struct member access (pWB->filepos) in terms of syntactic structure, even though both versions are semantically equivalent. The changes in Candidate B introduce explicit pointer arithmetic, which diverges from the source code's higher-level struct member syntax.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A retains array notation (e.g., `id[1]`, `id[5]`) which aligns with high-level, human-readable abstractions. Candidate B replaces these with explicit pointer arithmetic (`id + 1`, `id + 5`), which introduces lower-level machine-like constructs. Array indexing is a semantic structure favored in idiomatic design, while pointer arithmetic reflects a more concrete, assembly-like approach. The diff also shows Candidate B adds redundant type casts (e.g., `(type)call(...)`) that obscure clarity without improving structure.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)*(type)(id + 1));\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = (type)call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = (id) * (type)id;\n            *(type)((type)id + 0xd) = *(type)id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (id) * (type)(id + 5));\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (id) * (type)(id + 6));\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (id) * (type)(id + id * 2 + 1), (id) * (type)((type)id + id * 4 + 3), (id) * (type)(id + id * 2 + 2));\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (id) * (type)(id + 1));\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.078125,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.296875,
          "base_ast_ppl": 2.25,
          "pr_ast_ppl": 2.21875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses array notation (e.g., param_1[1], __ptr[5]) which abstracts pointer arithmetic into a higher-level, human-readable form. Candidate B replaces this with explicit pointer arithmetic and casting (e.g., *(int *)(param_1 + 1), *(byte *)(__ptr + 5)), which mirrors low-level machine operations. Since human engineering prioritizes semantic abstractions over concrete pointer manipulation, Candidate A's structure better aligns with high-level thinking.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate A retains array indexing (id[1]) which aligns with higher-level abstractions in C-like code, whereas Candidate B uses explicit pointer arithmetic (id + 1) and additional casts, which lean toward lower-level machine-like operations. Since the logic remains identical and array notation is more idiomatic in abstract code design, Candidate A avoids unnecessary complexity and adheres to human-like structural clarity.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch(*(undefined *)(param_2 + 3)) {\n    case 1:\n      local_28 = (long)(char)param_3;\n      break;\n    case 2:\n    case 7:\n    case 10:\n      local_28 = (long)(short)param_3;\n      break;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x29:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      local_28 = (long)(int)param_3;\n      break;\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",*(undefined *)(param_2 + 3));\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type id){\n  if(!(id->id & id)){\n    switch(id->id){\n      case id:\n        id = call(id, id, id);\n        break;\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        break;\n      case def:\n        if(id->id & id)call(id, str, id->id);\n        return id;\n    }\n  }\n  return id;\n}",
        "base_ast": " id( id, type *id,  id){\n  type id;\n  id = id;\n  if((*id & 8) == 0){\n    switch((type)id[3]){\n      case str:\n        id = (type)(type)id;\n        break;\n      case str:\n      case str:\n      case str:\n        id = (type)(type)id;\n        break;\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n        break;\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n        id = (type)(type)id;\n        break;\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n        break;\n      case def:\n        if((*(type)(id + 0x44) & 0x40) != 0){\n          call(id, str, (type)id[3]);\n        }\n        return -1;\n    }\n  }\n  return id;\n}",
        "pr_ast": " id( id, type *id,  id){\n  type id;\n  id = id;\n  if((*id & 8) == 0){\n    switch(*(type)(id + 3)){\n      case 1:\n        id = (type)(type)id;\n        break;\n      case 2:\n      case 7:\n      case 10:\n        id = (type)(type)id;\n        break;\n      case 3:\n      case 5:\n      case 0xd:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x29:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x3b:\n        break;\n      case 4:\n      case 6:\n      case 8:\n      case 9:\n      case 0xb:\n      case 0xc:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x21:\n      case 0x22:\n      case 0x23:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n        id = (type)(type)id;\n        break;\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n      case 0x24:\n      case 0x25:\n      case 0x26:\n      case 0x2a:\n      case 0x2b:\n      case 0x2c:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n        break;\n      case def:\n        if((*(type)(id + 0x44) & 0x40) != 0){\n          call(id, str, *(type)(id + 3));\n        }\n        return -1;\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.03125,
          "base_ppl": 2.4375,
          "pr_ppl": 1.90625,
          "source_ast_ppl": 1.8828125,
          "base_ast_ppl": 2.1875,
          "pr_ast_ppl": 1.8671875,
          "delta_ppl": -0.53125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar3 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(local_18 + 1));\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = *(byte *)local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(local_28 + 5));\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(local_28 + 6));\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar3) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)*(byte *)local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              bVar1 = *(byte *)local_28;\n              bVar2 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)bVar1 + (uint)bVar2 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)*(byte *)local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)*(byte *)(local_78 + 1));\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(local_28 + 1));\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)*(byte *)local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 !=\n                       0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)*(byte *)(local_28 + 1) +\n                       (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar3 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = id;\n    call(&id, 0, 4);\n    call(&id, 0, 4);\n    id = (type)0x0;\n    id = bool;\n    id = 0;\n    call(str);\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        call(str, (id) * (type)(*id + 8), *(type)(*id + 0x10) & 0xffffffff, *(type)(*id + 0x20) & 0xffffffff, *(type)(*id + 0x28) & 0xffffffff);\n      }\n      id = call(&id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(&id);\n      if(*(type)id != 0){\n        call(&id);\n      }\n      if(id.id != 0){\n        id = call(id, (type)id.id);\n        if(id == (type)0x0){\n          if(*(type)id != 0){\n            call(*(type)id, str, (type)id.id);\n          }\n          id = 5;\n          break;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != 0){\n            call(*(type)id, str);\n          }\n          id = 3;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      id = id & 0xffff;\n      if(id != 10){\n        if(id == 0x18){\n          if(*(type)id != 0){\n            call(str);\n            for(id = 0;  id < (type)(id >> 0x10); id = id + 1){\n              call(str, (id) * (type)((type)id + (type)id));\n            }\n            call(str);\n          }\n        }elseif(id == 0x22){\n          *(type)((type)id + 0xd) = (id) * id;\n          if(*(type)id != 0){\n            call(str, (id) * (type)((type)id + 0xd));\n          }\n        }else{\n          if(id == 0x2f){\n            id = 6;\n            break;\n          }\n          if(id == 0x31){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n          }elseif(id == 0x3c){\n            if(id){\n              if(((type)id == 0xfc) && (id = call(id, id, id.id)id != 0))break;\n              id = id;\n            }\n          }elseif(id == 0x3d){\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, (id) * id / 0x14, (id) * id % 0x14);\n              call(str, (type)id[1] / 0x14, (type)id[1] % 0x14);\n              call(str, (type)id[2] / 0x14, (type)id[2] % 0x14);\n              call(str, (type)id[3] / 0x14, (type)id[3] % 0x14);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              call(str, (type)id[8]);\n            }\n          }elseif(id == 0x42){\n            *(type)((type)id + 0x12) = call(id) * id + (id) * (type)((type)id + 1) * 0x100;\n            if(*(type)id != 0){\n              call(str, (id) * (type)((type)id + 0x12));\n            }\n          }elseif(id == 0x85){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != 0)break;\n          }elseif(id == 0x92){\n            if(10 < *(type)id){\n              id = id + 1;\n              id = *id;\n              id = *(type)((type)id + 1);\n              for(id = 0;  id < (type)((type)(type)id + (type)id * 0x100); id = id + 1){\n                call(str, call(id + 8), call(id) * id, (id) * (type)((type)id + 1), (type)(type)id[1]);\n                id = id + 2;\n              }\n            }\n          }elseif(id == 0xe0){\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(str, (id) * id);\n                call(str, (type)id[1]);\n                call(str, (type)id[2]);\n                call(str, (type)id[3]);\n                call(str, (type)id[4]);\n                call(str, (type)id[5]);\n                call(str, (type)id[6]);\n                call(str, (type)id[7]);\n              }\n            }\n          }else{\n            if(id == 0xfc){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != 0xff){\n              if(id == 0x231)goto lbl;\n              if(id == 0x293){\n                if(*(type)id != 0){\n                  call(str, call(*id & 0x7ff));\n                  if((*id & 0x8000) == 0){\n                    id = (type)call(id + 1, (type)(type)((id >> 0x10) - 2), 1, id);\n                    call(str, id);\n                    call(id);\n                  }else{\n                    call(str, (type)(type)id[1]);\n                    call(str, (id) * (type)((type)id + 3));\n                  }\n                }\n              }else{\n                if(id == 0x41e){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == 0x809){\n                  *(type)((type)id + 0xc) = call(id) * id + (id) * (type)((type)id + 1) * 0x100 != 0x600;\n                  *(type)((type)id + 0xe) = (type)(type)id[1] + (id) * (type)((type)id + 3) * 0x100;\n                  if(*(type)id != 0){\n                    id = str;\n                    if(*(type)((type)id + 0xc) != str){\n                      id = str;\n                    }\n                    call(str, id);\n                    call(str, (id) * (type)((type)id + 0xe));\n                  }\n                }elseif(*(type)id != 0){\n                  call(str, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id + 0x3c) == str){\n        id = (type)id != 10;\n      }\n    }while(id);\n    if(id != (type)0x0){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = id;\n    call(&id, 0, 4);\n    call(&id, 0, 4);\n    id = (type)0x0;\n    id = bool;\n    id = 0;\n    call(str);\n    do{\n      if(10 < *(type)id){\n        call(str, (type)*(type)(id + 1));\n        call(str, (id) * (type)(*id + 8), *(type)(*id + 0x10) & 0xffffffff, *(type)(*id + 0x20) & 0xffffffff, *(type)(*id + 0x28) & 0xffffffff);\n      }\n      id = call(&id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(&id);\n      if(*(type)id != 0){\n        call(&id);\n      }\n      if(id.id != 0){\n        id = (type)call(id, (type)id.id);\n        if(id == (type)0x0){\n          if(*(type)id != 0){\n            call(*(type)id, str, (type)id.id);\n          }\n          id = 5;\n          break;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != 0){\n            call(*(type)id, str);\n          }\n          id = 3;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      id = id & 0xffff;\n      if(id != 10){\n        if(id == 0x18){\n          if(*(type)id != 0){\n            call(str);\n            for(id = 0;  id < (type)(id >> 0x10); id = id + 1){\n              call(str, (id) * (type)((type)id + (type)id));\n            }\n            call(str);\n          }\n        }elseif(id == 0x22){\n          *(type)((type)id + 0xd) = *(type)id;\n          if(*(type)id != 0){\n            call(str, (id) * (type)((type)id + 0xd));\n          }\n        }else{\n          if(id == 0x2f){\n            id = 6;\n            break;\n          }\n          if(id == 0x31){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (id) * (type)(id + 5));\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (id) * (type)(id + 6));\n              if(id != 0){\n                call(str, id);\n              }\n            }\n          }elseif(id == 0x3c){\n            if(id){\n              if(((type)id == 0xfc) && (id = call(id, id, id.id)id != 0))break;\n              id = id;\n            }\n          }elseif(id == 0x3d){\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, (id) * id / 0x14, (id) * id % 0x14);\n              call(str, (type)id[1] / 0x14, (type)id[1] % 0x14);\n              call(str, (type)id[2] / 0x14, (type)id[2] % 0x14);\n              call(str, (type)id[3] / 0x14, (type)id[3] % 0x14);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              call(str, (type)id[8]);\n            }\n          }elseif(id == 0x42){\n            *(type)((type)id + 0x12) = (id) * (type)id + (id) * (type)((type)id + 1) * 0x100;\n            if(*(type)id != 0){\n              call(str, (id) * (type)((type)id + 0x12));\n            }\n          }elseif(id == 0x85){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != 0)break;\n          }elseif(id == 0x92){\n            if(10 < *(type)id){\n              id = id + 1;\n              id = *(type)id;\n              id = *(type)((type)id + 1);\n              for(id = 0;  id < (type)((type)id + (type)id * 0x100); id = id + 1){\n                call(str, call(id + 8), (id) * (type)id, (id) * (type)((type)id + 1), (id) * (type)(id + 1));\n                id = id + 2;\n              }\n            }\n          }elseif(id == 0xe0){\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(str, (id) * id);\n                call(str, (type)id[1]);\n                call(str, (type)id[2]);\n                call(str, (type)id[3]);\n                call(str, (type)id[4]);\n                call(str, (type)id[5]);\n                call(str, (type)id[6]);\n                call(str, (type)id[7]);\n              }\n            }\n          }else{\n            if(id == 0xfc){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != 0xff){\n              if(id == 0x231)goto lbl;\n              if(id == 0x293){\n                if(*(type)id != 0){\n                  call(str, call(*id & 0x7ff));\n                  if((*id & 0x8000) == 0){\n                    id = (type)call(id + 1, (type)(type)((id >> 0x10) - 2), 1, id);\n                    call(str, id);\n                    call(id);\n                  }else{\n                    call(str, (id) * (type)(id + 1));\n                    call(str, (id) * (type)((type)id + 3));\n                  }\n                }\n              }else{\n                if(id == 0x41e){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == 0x809){\n                  *(type)((type)id + 0xc) = (id) * (type)id + (id) * (type)((type)id + 1) * 0x100 != 0x600;\n                  *(type)((type)id + 0xe) = (id) * (type)(id + 1) + (id) * (type)((type)id + 3) * 0x100;\n                  if(*(type)id != 0){\n                    id = str;\n                    if(*(type)((type)id + 0xc) != str){\n                      id = str;\n                    }\n                    call(str, id);\n                    call(str, (id) * (type)((type)id + 0xe));\n                  }\n                }elseif(*(type)id != 0){\n                  call(str, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id + 0x3c) == str){\n        id = (type)id != 10;\n      }\n    }while(id);\n    if(id != (type)0x0){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.015625,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.296875,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.34375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate A uses array notation (id[5]) which is more idiomatic in C-like languages, reflecting higher-level abstractions. Candidate B replaces this with pointer arithmetic (id + 5), which is more machine-like and could obscure intent. The tie-breaker favors less artificial nesting, and Candidate A's array syntax aligns better with human-readable patterns.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = (type)call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = (type)call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.34375,
          "base_ppl": 1.859375,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 2.234375,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "The logic flow and control structures (e.g., `if`, `else`, `switch`) are identical between versions A and B. The only difference is a type cast `(char *)` added in B. Since this change does not alter the control flow or introduce artificial nesting, the tie-breaker applies: the original version (A) is preferred as it avoids unnecessary type casting, maintaining simplicity and readability without compromising logic.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns closer with the Source Code structure by omitting an unnecessary cast to char*, which is not present in the original code. The Source Code uses a direct assignment of bsearch() to a varlookup_t* without casting, while Candidate B introduces a cast that diverges from this structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = (type)call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = (type)call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.34375,
          "base_ppl": 1.859375,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 2.234375,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns with the Source Code structure as it correctly uses the return type of bsearch without unnecessary casting. Candidate B introduces a (char *) cast that is not present in the original source, which could misrepresent the data type and control flow.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "The structural changes in Candidate B introduce explicit type casting, which does not alter the control flow hierarchy. Since the logic remains identical and the tie-breaker favors less artificial nesting, Candidate A is more idiomatic as it avoids redundant type casting without affecting control flow clarity.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores explicit type casts (e.g., `(type)call(...)`) present in the Source AST but missing in Candidate A. The Source contains multiple `(type)` casts (e.g., `type *id = (type)id;`), and Candidate B aligns with this by adding the missing cast nodes, matching the Source's topology and complexity.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = (type)call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.4375,
          "base_ppl": 2.0625,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.34375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores type casts (e.g., `(type)call(...)`) present in the Source AST but absent in Candidate A. These casts are explicitly present in the Ground Truth (e.g., `type *id = (type)id;`), aligning with the Source's topology. The nesting depth remains unchanged in both versions, but B matches the Source's structural fidelity.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = (type)call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.4375,
          "base_ppl": 2.0625,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.34375,
          "pr_ast_ppl": 2.34375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more with the source structure by explicitly casting the bsearch result to a char pointer, which mirrors the source's use of pointer arithmetic and struct handling. While both versions have type mismatches, Candidate B's cast reflects a closer approximation of the source's memory manipulation patterns.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[8192];\n  type id;\n  type *id;\n  type id[79];\n  type id[9];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + (type)id;\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)*(type)(id + (type)id * 2);\n    id = (id) * (type)(id + (type)id * 2);\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] + 0x2c];\n      id = &id + (type)(type)id[id];\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id == (type)0x0){\n              call(id, 0x2000, str, id);\n              if(*(type)(id + 0x30) != 0){\n                call(id, *(type)(id + 0x50));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id + -0x28;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id;\n              }\n            }\n            break;\n          case 4:\n            call(id, id, id);\n            id[id] = 0;\n            break;\n          case 5:\n            id = id;\n            break;\n          case 6:\n            id = (type)id - (type)id;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] + 0x2c];\n    id = &id + (type)(type)id[id];\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, 0x28, id);\n        id = id;\n        if(id == (type)0x0){\n          call(id, 0x2000, str, id);\n          if(*(type)(id + 0x30) != 0){\n            call(id, *(type)(id + 0x50));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id + -0x28;\n          }\n          while(bool){\n            id = id + 0x28;\n            id = bool;\n            if(((type)id - (type)id) / 0x28 < (type)id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = 0;\n      }elseif(id == str){\n        id = (type)id - (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, (type)id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[8192];\n  type id;\n  type *id;\n  type id[79];\n  type id[9];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + (type)id;\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)*(type)(id + (type)id * 2);\n    id = (id) * (type)(id + (type)id * 2);\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] + 0x2c];\n      id = &id + (type)(type)id[id];\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = (type)call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id == (type)0x0){\n              call(id, 0x2000, str, id);\n              if(*(type)(id + 0x30) != 0){\n                call(id, *(type)(id + 0x50));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id + -0x28;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id;\n              }\n            }\n            break;\n          case 4:\n            call(id, id, id);\n            id[id] = 0;\n            break;\n          case 5:\n            id = id;\n            break;\n          case 6:\n            id = (type)id - (type)id;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] + 0x2c];\n    id = &id + (type)(type)id[id];\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = (type)call(id, id, (type)id, 0x28, id);\n        id = id;\n        if(id == (type)0x0){\n          call(id, 0x2000, str, id);\n          if(*(type)(id + 0x30) != 0){\n            call(id, *(type)(id + 0x50));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id + -0x28;\n          }\n          while(bool){\n            id = id + 0x28;\n            id = bool;\n            if(((type)id - (type)id) / 0x28 < (type)id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = 0;\n      }elseif(id == str){\n        id = (type)id - (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, (type)id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.34375,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.796875,
          "source_ast_ppl": 2.234375,
          "base_ast_ppl": 2.078125,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A retains original variable types (e.g., 'undefined1' vs 'undefined') without introducing explicit casts, aligning closer with the source code's structural patterns. While the decompiled code's variable types differ from the source, the changes in Candidate B (adding '(char *)' casts) introduce noise that doesn't reflect the source's use of struct pointers. Structural isomorphism (control flow) remains unchanged between A and B, but Candidate A avoids regression by preserving original decompiler-type declarations.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "The structural changes in Candidate B involve adding a redundant type cast `(type)` around the `call()` function. This does not alter the control flow skeleton (e.g., no new loops, switches, or conditionals are introduced). Since the control flow remains identical between A and B, the tie-breaker rule applies: Candidate A has less artificial nesting/depth. The cast in B is a semantic detail, not a structural improvement to idiomatic control flow.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B introduces explicit casts around function calls, which add new node types (CastExpression) not present in the Source AST. Candidate A preserves the original structure without adding new node types, aligning with the Source's topology.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + 0x400;\n  id = id + id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id + (type)(type)(type)id[id] + 1;\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id != (type)0x0){\n              while(bool){\n                id = id + -0x28;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id + 0x28){\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n              }\n            }\n            break;\n          case 4:\n            if(*id != 0){\n              if((-call(*id - 0x30) - 1) / 10 < id){\n                id = id + 1;\n                goto lbl;\n              }\n              id = id * 10 + call(*id - 0x30);\n            }\n            break;\n          case 5:\n            id = 0;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id + (type)(type)(type)id[id] + 1;\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        while(bool){\n          id = id + -0x28;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id + 0x28;\n          id = bool;\n          if(((type)id - (type)id) / 0x28 < (type)id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id + 0x28){\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)id, str, (type)id - (type)id, (type)id - (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + 0x400;\n  id = id + id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id + (type)(type)(type)id[id] + 1;\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = (type)call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id != (type)0x0){\n              while(bool){\n                id = id + -0x28;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id + 0x28){\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n              }\n            }\n            break;\n          case 4:\n            if(*id != 0){\n              if((-call(*id - 0x30) - 1) / 10 < id){\n                id = id + 1;\n                goto lbl;\n              }\n              id = id * 10 + call(*id - 0x30);\n            }\n            break;\n          case 5:\n            id = 0;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id + (type)(type)(type)id[id] + 1;\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        while(bool){\n          id = id + -0x28;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id + 0x28;\n          id = bool;\n          if(((type)id - (type)id) / 0x28 < (type)id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id + 0x28){\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)id, str, (type)id - (type)id, (type)id - (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.4375,
          "base_ppl": 1.84375,
          "pr_ppl": 1.828125,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.015625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A preserves the correct type for bsearch results (no cast to char*), aligning with the source code's use of varlookup_t pointers. Candidate B introduces a cast to char* which diverges from the source's type-correct structure. The switch statements are present in both, but A maintains fidelity to the original data types.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = id - 1900;\n              }\n              break;\n            }\n          case 16:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 17:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 44)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  44;\n  id != id\n  {\n    type id[1024];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 2.3125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 2.140625,
          "base_ast_ppl": 2.578125,
          "pr_ast_ppl": 2.59375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses idiomatic array access (direct indexing) and precise type definitions (undefined1), which align with standard C practices and improve readability. Candidate B introduces redundant address-of operator (&) and less specific type (undefined), which may obscure intent and increase cognitive load.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A preserves direct array indexing (`_dta_timestamp_parse_cond_targs[uVar9]`), matching the Source Code's structure. Candidate B introduces pointer arithmetic (`(&_dta_timestamp_parse_cond_targs)[uVar9]`), which diverges from the original array access pattern. The Source Code uses explicit array indexing, making Candidate A structurally closer.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A uses direct array access (`id[id]`), which is a more straightforward and idiomatic expression compared to Candidate B's use of `(&id)[id]`, which introduces unnecessary pointer arithmetic and obfuscates the intent. The change in B adds complexity without introducing higher-level control flow structures, making A more human-like in its clarity and simplicity.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A retains the original array access (`id[id]`) present in the Source AST, matching its node type and structure. Candidate B introduces a pointer dereference (`&id`), altering the expression's semantics and topology. Since the Source's structure is preserved in A, it aligns better with the Ground Truth.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = id - 1900;\n              }\n              break;\n            }\n          case 16:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 17:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 44)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  44;\n  id != id\n  {\n    type id[1024];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 2.3125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 2.140625,
          "base_ast_ppl": 2.578125,
          "pr_ast_ppl": 2.59375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses direct array indexing without redundant address-of operators, which aligns with idiomatic C practices. The change in Candidate B introduces unnecessary indirection (e.g., `&_dta_timestamp_parse_cond_targs`), which obscures the intent and increases cognitive load. Semantic clarity through direct array access (Candidate A) better reflects human-readable logic flow.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A retains the original array indexing syntax without unnecessary pointer arithmetic, preserving the structural isomorphism of the switch statement present in the Source Code. Candidate B introduces redundant pointer arithmetic (e.g., `&_dta_timestamp_parse_cond_actions[uVar9]`), which does not align with the Source Code's direct array access and may obscure the original logic.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A uses direct variable access (id[id]) without explicit pointer arithmetic, aligning with idiomatic C-style operations. Candidate B introduces &id, which adds explicit pointer manipulation, making the code feel more machine-like. Since the control flow structure remains unchanged and Candidate A's expressions are simpler, it better reflects human-like abstraction.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A retains the original array access pattern (`id[id]`) present in the Source AST, while Candidate B introduces a pointer-to-pointer (`&id[id]`) operation not observed in the Ground Truth. The Source's structure relies on direct array indexing without address-of operators, making Candidate A structurally consistent.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                type id = ((((*(id)))) - str);\n                if(id >= 0 && id <= 9){\n                  id = 10 * id + id;\n                }\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                if(id < 70){\n                  id->id = 100 + id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 47)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  47;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.9140625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.640625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses idiomatic C array access syntax without redundant address-of operators, which aligns with standard practices. Candidate B introduces unnecessary & operators that obscure the intent and may imply incorrect pointer arithmetic. The original version maintains cleaner, more readable array indexing that reflects natural human understanding of array access in C.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A preserves the original array indexing syntax (`_sav_date_parse_cond_actions[uVar7]`), which aligns with the source code's structure. Candidate B uses pointer arithmetic (`(&_sav_date_parse_cond_actions)[uVar7]`), which diverges from the source's explicit array access pattern. The switch statement structure is retained in both, but Candidate A's syntax matches the source more closely.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate A retains the original structure of 'id[id]' present in the Source AST, while Candidate B modifies it to '(&id)[id]'. Since the Source AST topology includes the original expression without alterations, Candidate A aligns more closely with the Ground Truth.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                type id = ((((*(id)))) - str);\n                if(id >= 0 && id <= 9){\n                  id = 10 * id + id;\n                }\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                if(id < 70){\n                  id->id = 100 + id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 47)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  47;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.9140625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.640625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses standard C array access syntax (`_sav_date_parse_cond_targs[uVar7]`), which is idiomatic and concise. Candidate B introduces an explicit address-of operator (`&_sav_date_parse_cond_targs`), which is functionally equivalent but less readable and more verbose. The control flow structures (e.g., `switch`, `do-while`) remain unchanged, so the readability improvement lies in preserving idiomatic C syntax.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A uses direct array indexing (e.g., _sav_date_parse_cond_targs[uVar7]) which matches the source code's structure. Candidate B introduces pointer arithmetic (e.g., (&_sav_date_parse_cond_targs)[uVar7]) that diverges from the original array access pattern in the source code.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A uses direct array indexing (`id[id]`), which is a more concise and idiomatic expression in C-like languages for self-referential array access. Candidate B introduces `&id` (address-of operator), which complicates the expression and may obscure the intent, making it feel more machine-like. Since the structural change does not improve control flow semantics (e.g., adding loops/switches) and instead introduces a more opaque pointer-based operation, Candidate A aligns better with human-like abstraction.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the original array access pattern (`id[id]`) present in the Source AST, while Candidate B introduces a pointer-based access (`(&id)[id]`), which may not align with the Source's topology. The Source's structure relies on direct array indexing, and Candidate A maintains this without altering the node type or nesting depth.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = id + 2;\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if((id != (type)0x0) && (id = *idid != -1)){\n    id = id + 2;\n    id = 0;\n    id = 0;\n    id = 8;\n    id = bool;\n    do{\n      id = 1;\n      id = bool;\n      switch(id){\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          id = bool;\n          id = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto lbl;\n        case 0x21:\n          break;\n        case def:\n          id = 1;\n          id = bool;\n          if(1 < id + 0xbfffffffffffffffU){\n            return 8;\n          }\n      }\n      if(!id){\n        return 8;\n      }\n      id = id + id;\n      id = id + 1;\n      id = *id;\n      id = id + 2;\n      id = id;\n    }while(id != -1);\n    if((id == 1 && id < 5) && (id < 4)){\n      *id = id;\n      id = 0;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.59375,
          "base_ppl": 1.953125,
          "pr_ppl": 1.9609375,
          "source_ast_ppl": 5.1875,
          "base_ast_ppl": 2.4375,
          "pr_ast_ppl": 2.5,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate A retains the original switch statement structure and nesting depth present in the Source AST, while Candidate B introduces additional assignments and complexity not reflected in the Source. The Source's switch cases and loop structure align more closely with Candidate A's topology.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = id + 2;\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if((id != (type)0x0) && (id = *idid != -1)){\n    id = id + 2;\n    id = 0;\n    id = 0;\n    id = 8;\n    id = bool;\n    do{\n      id = 1;\n      id = bool;\n      switch(id){\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          id = bool;\n          id = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto lbl;\n        case 0x21:\n          break;\n        case def:\n          id = 1;\n          id = bool;\n          if(1 < id + 0xbfffffffffffffffU){\n            return 8;\n          }\n      }\n      if(!id){\n        return 8;\n      }\n      id = id + id;\n      id = id + 1;\n      id = *id;\n      id = id + 2;\n      id = id;\n    }while(id != -1);\n    if((id == 1 && id < 5) && (id < 4)){\n      *id = id;\n      id = 0;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.59375,
          "base_ppl": 1.953125,
          "pr_ppl": 1.9609375,
          "source_ast_ppl": 5.1875,
          "base_ast_ppl": 2.4375,
          "pr_ast_ppl": 2.5,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a `switch` statement to handle multiple discrete cases, which aligns with high-level human logic structures. This replaces the original's nested `if-else` and `goto` constructs, reducing spaghetti code and improving readability. While both versions use `goto`, Candidate B's `switch`-based flow is more structured and idiomatic, reflecting clearer logical grouping of cases.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces a `switch` statement that aligns with the original code's logic of checking filter IDs against features. The original source uses a loop to match `filters[i].id` with `features[j].id`, which decompilers often represent as a `switch` for efficiency. Candidate B's structure better reflects this lookup mechanism, while Candidate A retains a more convoluted loop structure. Additionally, Candidate B's reorganization fixes potential control flow ambiguities present in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids artificial nesting and redundant assignments present in Candidate B. While both use semantic structures like `do-while` and `switch`, Candidate B introduces unnecessary assignments (e.g., `id = 0; id = 8; id = bool;`) and deeper nesting, which increases complexity without improving readability. Candidate A maintains a more compact structure with equivalent logic, aligning better with idiomatic design principles.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem step by step. The goal is to determine whether Candidate A or Candidate B more closely matches the Source AST topology based on the given criteria. \n\nFirst, I need to understand what the Ground Truth (Source AST) looks like. The source code provided has a function with several if statements, do-while loops, assignments, and some switch cases. Let me parse through the source code to note key elements.\n\nLooking at the Source AST:\n- There's a function definition with parameters.\n- Inside, there's an initial if statement checking if id is null or if id[0].id equals id, returning id.\n- Then, there are assignments of type id variables to 0, bool, etc.\n- A do-while loop that includes a for loop, some conditionals, and assignments.\n- The loop has multiple id assignments and checks.\n- The loop condition is while(id[++id].id != id).\n- After the loop, there's an if statement checking if id > id or !id or id > 3, then *id = id and return id.\n\nNow, looking at the AST Diff between A and B. The key part is the code block that's changed. Let me focus on the lines that are different.\n\nIn Candidate A, the code after the initial assignments has:\n- id = 0xb;\n- if(id != (type)0x0) { ... }\nInside that if block, there's a do-while loop with a switch statement, some assignments, and a goto lbl. Then, after the loop, there's an if condition, and then a lbl: label.\n\nIn Candidate B, the same section has:\n- The same initial id = 0xb;\n- The if condition is modified to (id != (type)0x0) && (id = *idid != -1) [note: possible typo here? Maybe *id instead of *idid?]\n- Inside the if block, there's more assignments (id = 0, 0, 8, bool), then a do-while loop with a switch statement that has more cases and a goto lbl.\n- The switch in B has more case labels compared to A, and the code inside the switch and loop is more complex.\n- Also, in B, there's a 'def' case which is a default case, and some additional conditions.\n\nNow, applying the criteria:\n\n1. **Topology Match**: The Source AST has a do-while loop with a for loop inside, and a switch statement. Looking at the diff, both A and B have switch statements. However, the Source's switch isn't present in the original code. Wait, the original Source code (Ground Truth) doesn't have a switch statement. Wait, let me check again.\n\nWait, the Ground Truth code provided doesn't have any switch statements. The original code has if-else, do-while, for loops, but no switch. So, if the Source AST doesn't have a switch, then Candidate B introduces a switchStatement node that wasn't present in the original. But according to the first criterion, if Candidate B restores a node type present in the Source but missing in A, then B would be better. However, the Source doesn't have a switch, so adding it in B would not match the Source. Wait, but maybe I'm misunderstanding. The question is whether the + code (Candidate B) restores a node type present in the Source but missing in A. But if the Source doesn't have that node type, then adding it in B would not be a match. Wait, the original Source code (Ground Truth) does not have a switch statement. Therefore, if Candidate B introduces a switchStatement node that wasn't in the original, then that would not be a topology match. However, if Candidate A is missing that node, but the original didn't have it, then neither would be matching. Hmm, maybe I need to check again.\n\nWait, the original Source code (Ground Truth) has a do-while loop, which is present in both A and B. The original code also has a for loop inside the do-while. However, the original code does not have a switch statement. So, if Candidate B introduces a switch statement, that would be a new node not present in the original. Therefore, according to the first criterion, if the Source has a node type that's missing in A but present in B, then B would be better. However, since the Source doesn't have a switch statement, that would not be the case. Therefore, the first criterion may not apply here. Maybe the original code has a switch statement that's not shown here? Wait, the original code provided in the Ground Truth does not have a switch. Let me check again:\n\nOriginal code:\n\ntype id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}\n\nNo switch statements here. So, the Source AST does not have a switch. Therefore, if Candidate B adds a switchStatement node, that would not be present in the Source. However, the original code may have a switch that's not shown? No, the user provided the Ground Truth code as is. Therefore, the first criterion (Topology Match) would not be satisfied by Candidate B adding a switch. Therefore, the first criterion may not be applicable here. So, perhaps the first criterion is not met by either A or B, but maybe the second criterion (Complexity) is more important.\n\nSecond criterion: Complexity - Does the + code match the nesting depth of the Source?\n\nThe original code has a do-while loop with a for loop inside, and some nested conditionals. Let's compare the nesting depth of the loops and conditionals in A and B.\n\nIn Candidate A, the code after the initial assignments has a do-while loop, which contains a switch statement. The switch has multiple cases, and inside the switch, there are assignments and breaks. The loop is nested within the if statement. The original code's do-while loop has a for loop inside, which is more complex than a switch.\n\nIn Candidate B, the code has a more complex switch with more cases, and inside the switch, there's a 'def' case with an if condition. Additionally, the do-while loop in B is more nested with more assignments and conditions. However, the original code's structure is simpler, with a for loop inside the do-while, not a switch.\n\nWait, but the original code's structure is different. The original code's do-while loop has a for loop inside, which is a different structure than a switch. Therefore, if Candidate B introduces a switch, which is not present in the original, then the topology doesn't match. However, the original code's structure is more about loops and conditionals, not switches.\n\nAlternatively, perhaps the original code's structure has a certain nesting depth. Let me count the nesting levels.\n\nOriginal code's structure:\n\n- Function\n  - if statement\n  - do-while loop\n    - for loop\n    - if statements\n    - assignments\n  - if statement\n  - assignments\n  - return\n\nSo, the nesting depth here is up to 3 levels (function -> do-while -> for loop).\n\nIn Candidate A, the structure is:\n\n- if (id != 0x0)\n  - do-while loop\n    - switch statement\n      - multiple cases\n      - assignments, breaks\n  - label\n  - return\n\nThe nesting here is similar: function -> if -> do-while -> switch. The switch is a new node, but the nesting depth is similar.\n\nIn Candidate B, the structure is:\n\n- if (...)\n  - do-while loop\n    - switch with more cases\n    - if statements\n    - assignments\n  - label\n  - return\n\nThe nesting depth here is similar, but the switch is more complex with more cases. However, the original code didn't have a switch, so introducing that might not match the topology.\n\nBut the first criterion says: Does the + code restore a node type present in the Source but missing in A? Since the Source doesn't have a switch, adding it in B would not be restoring a node present in the Source. Therefore, the first criterion isn't met here. So, perhaps the second criterion is more important.\n\nThe second criterion is about complexity, i.e., nesting depth. The original code has a for loop inside a do-while. Candidate A has a switch inside a do-while. Candidate B has a more complex switch with more cases and a default. However, the original code's structure doesn't have a switch, so the presence of a switch in both A and B may not be a match. However, the original code's structure may not have a switch, so perhaps the correct answer is that neither A nor B has a switch, but the original code doesn't either. Wait, but the original code's structure is different. Wait, the original code's do-while loop has a for loop inside, which is a different structure than a switch. So, if the original code doesn't have a switch, then introducing a switch in A or B would not match the Source's topology. Therefore, perhaps the correct answer is that neither A nor B has a switch, but the original code doesn't either. However, the problem states that the Ground Truth is the Source AST, and the question is which version (A or B) mirrors the Source's topology.\n\nWait, maybe I'm missing something. Let me re-examine the Ground Truth code again. The original code has a do-while loop with a for loop inside. The code in Candidate A and B both have do-while loops with switch statements. The original code doesn't have a switch, so perhaps the presence of a switch in both A and B is not matching the Source's topology. However, the original code's structure may have a different node type. Wait, perhaps the original code has a switch that's not shown here? No, the user provided the Ground Truth code as is. Therefore, the original code doesn't have a switch. Therefore, the presence of a switch in both A and B would not be a match. But the question is which version (A or B) mirrors the Source's topology. If the Source's topology doesn't have a switch, then the presence of a switch in both A and B would not be a match. However, the original code may have a switch that's not shown? No, the user provided the code, and there's no switch there.\n\nThis is confusing. Let me think again. The first criterion is whether the + code (Candidate B) restores a node type present in the Source but missing in A. If the Source has a node type (like SwitchStatement) that's missing in A but present in B, then B would be better. However, the Source doesn't have a SwitchStatement, so adding it in B would not be restoring a node present in the Source. Therefore, the first criterion isn't met here. Therefore, the second criterion (complexity) is more important.\n\nThe second criterion is about nesting depth. The original code's structure has a do-while loop containing a for loop. Let's compare the nesting depth of the loops in A and B.\n\nIn Candidate A, the do-while loop contains a switch statement. The switch is a different node type than the for loop in the original code. However, the nesting depth (number of levels) may be similar. The original code has a do-while loop with a for loop inside (two levels), while Candidate A has a do-while loop with a switch (one level). But the switch may have multiple cases, which could be considered as more complex. However, the original code's for loop is more complex than a switch with multiple cases. Alternatively, the nesting depth is similar.\n\nIn Candidate B, the do-while loop contains a switch with more cases, which might be more complex than the original's for loop. However, the original code's structure is different. Therefore, the complexity may not match.\n\nAlternatively, perhaps the original code's structure has a certain number of nested loops and conditionals. Let's count:\n\nOriginal code:\n- Function\n  - if (...)\n  - do-while loop\n    - for loop\n    - if statements\n    - assignments\n  - if (...)\n  - assignments\n  - return\n\nSo, the do-while loop has a for loop inside, which is a level of nesting.\n\nIn Candidate A:\n- if (...)\n  - do-while loop\n    - switch (multiple cases)\n  - label\n  - return\n\nThe switch is a single level inside the do-while.\n\nIn Candidate B:\n- if (...)\n  - do-while loop\n    - switch with more cases and a default\n  - label\n  - return\n\nThe switch here is more complex but still a single level inside the do-while.\n\nThe original code's for loop inside the do-while is a different structure than a switch. Therefore, the topology (node types) may not match. However, the original code's structure may not have a switch, so introducing a switch in both A and B would not match the Source's topology. Therefore, perhaps the correct answer is that neither A nor B matches, but since the question asks to choose between A and B, I need to see which one is closer.\n\nAlternatively, perhaps the original code's structure has a switch that's not shown. Wait, no, the user provided the code, and there's no switch. Therefore, the presence of a switch in both A and B would not be a match. However, the original code's structure may have a different node type. For example, the original code has a for loop inside the do-while, which is a loop node. Candidate A has a switch inside the do-while, which is a different node type. Therefore, the topology doesn't match. But since both A and B have switches, perhaps the original code's structure is different, and the question is which one is closer.\n\nAlternatively, perhaps the original code's structure has a switch that's not shown. But that's not the case. Therefore, the first criterion (Topology Match) is not met by either A or B, but the second criterion (complexity) may be considered.\n\nThe original code's complexity in terms of nesting depth: the do-while loop contains a for loop. The for loop has a condition and an increment. The switch in A and B has multiple cases, which may be more complex in terms of code structure but not in nesting depth.\n\nAlternatively, the original code's complexity may be higher because of the for loop inside the do-while, which is more complex than a switch. Therefore, Candidate B's switch may not match the complexity.\n\nAlternatively, the original code's structure may have a certain number of assignments and conditionals. For example, the original code has multiple assignments and conditionals inside the loops. Candidate B has more assignments and more complex conditions.\n\nBut this is getting too vague. Let me look back at the diff. The original code's do-while loop has a for loop inside. In Candidate A, the do-while loop has a switch. In Candidate B, the do-while loop also has a switch, but with more cases and a default. The original code's for loop is more complex than the switch in terms of code structure. However, the switch in B may have more cases, making it more complex. But the original code's structure is different.\n\nWait, the original code's do-while loop has a for loop that runs while id[id].id != id[id].id, which is a condition that may loop multiple times. The switch in B has multiple cases, which may be more complex. However, the original code's structure doesn't have a switch, so introducing it in B may not match the Source's topology.\n\nBut the question is which version (A or B) mirrors the Source's topology. If the Source's topology doesn't have a switch, then neither A nor B has a switch. But the diff shows that both A and B have switches. Wait, no. Let me check the diff again.\n\nIn the diff, the lines in Candidate A and B are different. The original code (Ground Truth) has a do-while loop with a for loop inside. In the diff, the code in Candidate A and B has a do-while loop with a switch statement. Therefore, the original code's structure is different from both A and B. However, the question is to compare the AST changes against the Ground Truth. So, perhaps the Ground Truth has a switch that's not shown? No, the user provided the code, and there's no switch.\n\nThis is confusing. Maybe I'm missing something. Let me re-express the Ground Truth code's structure:\n\nThe Ground Truth code has:\n\n- A function with parameters.\n- An initial if statement.\n- Then, assignments of type id variables.\n- A do-while loop that contains:\n  - a for loop\n  - if statements\n  - assignments\n- After the loop, another if statement.\n- Assignments and return.\n\nSo, the main structure is a do-while loop containing a for loop. The switch is not present here.\n\nIn the diff, both A and B have a do-while loop containing a switch statement. Therefore, the structure of the code in A and B is different from the Source. However, the question is which version (A or B) mirrors the Source's topology. If the Source's topology doesn't have a switch, then neither A nor B has it. But the diff shows that both A and B have switches. Therefore, this suggests that the original code may have a switch that's not shown, but the user provided the code as is. Therefore, perhaps the correct answer is that neither A nor B matches, but since we have to choose between them, we need to see which one is closer.\n\nAlternatively, perhaps the original code's structure has a switch that's been transformed into a different structure in the diff. For example, the original code's for loop may have been decompiled into a switch statement in the AST. But that's speculative.\n\nAlternatively, the original code's for loop may have been represented as a switch in the AST, but that's not clear.\n\nGiven the ambiguity, perhaps the key is to look at the nesting depth. The original code has a do-while loop with a for loop inside (two levels). Candidate A has a do-while loop with a switch (one level). Candidate B has a do-while loop with a switch (one level), but with more cases. The original code's for loop is more complex than a switch with multiple cases. Therefore, the nesting depth may not match. However, the original code's structure is different, so it's unclear.\n\nAlternatively, the original code's structure may have a switch that's been optimized or transformed into a different structure, but without more information, it's hard to say.\n\nGiven the ambiguity, perhaps the answer is that Candidate B has more complexity in terms of the switch cases, which"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013e6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013e6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id)++] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = 0;\n        id->id = (id->id == 0 ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = 0;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (--id->id == 0 ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(4) - call(id->id.id, id->id.id)) & 3;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > 0){\n        --id->id;\n        if(id[(*id)++] != 0x00)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != 0)return id;\n      id->id = call(id + id, *id - id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id >> (id->id * 8)) & 0xFF) != id[(*id)++]){\n          idreturn id;\n        }\n      }while(++id->id < 4);\n      return id;\n    case def:\n      call(0);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id - id;\n    if(id > 0)id->id = call(id + id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return 10;\n  }\n  id = (type)(id + 0x4c);\n  id = (type)(id + 0x46);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case 0:\n        *id = id + 1;\n        id = 1;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        break;\n      case 1:\n        id = call(id, id, id, id, id);\n        if(id != 1){\n          lbl:\n          id = *id - id;\n          if(id == 0){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id + 0x46) != *(type)(id + 6)){\n          return 9;\n        }\n        *id = 0;\n        id = call(*(type)(id + 0x46) == 0) * 2 + 2;\n        break;\n      case 2:\n      case 3:\n        id = id + 0x48;\n        if(id != 2){\n          id = id + 0x4a;\n        }\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        id[0x4c] = 0;\n        id[0x4d] = 0;\n        if(*id == 2){\n          id = 3;\n          if(*(type)(id + 0x48) + 0x8000000000000003U < 0x8000000000000008){\n            return 9;\n          }\n        }else{\n          call(id + 0x24, *(type)(id + 0x48), *(type)(id + 0x4a));\n          if(*(type)(id + 2) < *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) < *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) < *(type)(id + 0x2a)){\n            return 9;\n          }\n          *id = *id + -1;\n          id = call(*id == 0) * 2 + 2;\n        }\n        break;\n      case 4:\n        id = call(*(type)(id + 0x28), *(type)(id + 0x2a));\n        id = call(-id & 3);\n        *(type)(id + 0x4c) = id;\n        *id = 5;\n        goto lbl;\n      case 5:\n        id = *id;\n        lbl:\n        if(id == 0){\n          if(*(type)(id + 2) != *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) != *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) != *(type)(id + 0x2a)){\n            return 9;\n          }\n          call(id + 10, 10);\n          call(id + 0x2c, 10);\n          id = call(10);\n          id = call(id + 10, id + 0x2c, (type)id);\n          if(id != 0){\n            return 9;\n          }\n          id = call(id + id, *id - id, id[0x4e]);\n          id[0x4e] = id;\n          *id = 6;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return 0;\n            }\n            id = id[0x4c];\n            id = id[0x4e];\n            *id = id + 1;\n            if(*(type)(id + id) != (type)(id >> (call(id << 3) & 0x1f)))break;\n            id = *id;\n            *id = id + 1;\n            if(3 < id + 1){\n              return 1;\n            }\n          }\n          return 9;\n        }\n        *id = id - 1;\n        id = *id;\n        *id = id + 1;\n        id = 5;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        goto lbl;\n      case 6:\n        goto lbl;\n      case def:\n        return 0xb;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = 0;\n  id = *id - id;\n  if(id == 0){\n    return 0;\n  }\n  lbl:\n  id = call(id + id, id, id[0x4e]);\n  id[0x4e] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return 10;\n  }\n  id = (type)(id + 0x4c);\n  id = (type)(id + 0x46);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case 0:\n        *id = id + 1;\n        id = 1;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        break;\n      case 1:\n        id = call(id, id, id, id, id);\n        if(id != 1){\n          lbl:\n          id = *id - id;\n          if(id == 0){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id + 0x46) != *(type)(id + 6)){\n          return 9;\n        }\n        *id = 0;\n        id = call(*(type)(id + 0x46) == 0) * 2 + 2;\n        break;\n      case 2:\n      case 3:\n        id = id + 0x48;\n        if(id != 2){\n          id = id + 0x4a;\n        }\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        id[0x4c] = 0;\n        id[0x4d] = 0;\n        if(*id == 2){\n          id = 3;\n          if(*(type)(id + 0x48) + 0x8000000000000003U < 0x8000000000000008){\n            return 9;\n          }\n        }else{\n          call(id + 0x24, *(type)(id + 0x48), *(type)(id + 0x4a));\n          if(*(type)(id + 2) < *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) < *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) < *(type)(id + 0x2a)){\n            return 9;\n          }\n          *id = *id + -1;\n          id = call(*id == 0) * 2 + 2;\n        }\n        break;\n      case 4:\n        id = call(*(type)(id + 0x28), *(type)(id + 0x2a));\n        id = call(-id & 3);\n        *(type)(id + 0x4c) = id;\n        *id = 5;\n        if(id == 0)goto lbl;\n        lbl:\n        *id = id - 1;\n        id = *id;\n        *id = id + 1;\n        id = 5;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        goto lbl;\n      case 5:\n        id = *id;\n        if(id != 0)goto lbl;\n        lbl:\n        if(*(type)(id + 2) != *(type)(id + 0x24)){\n          return 9;\n        }\n        if(*(type)(id + 4) != *(type)(id + 0x26)){\n          return 9;\n        }\n        if(*(type)(id + 8) != *(type)(id + 0x2a)){\n          return 9;\n        }\n        call(id + 10, 10);\n        call(id + 0x2c, 10);\n        id = call(10);\n        id = call(id + 10, id + 0x2c, (type)id);\n        if(id != 0){\n          return 9;\n        }\n        id = call(id + id, *id - id, id[0x4e]);\n        id[0x4e] = id;\n        *id = 6;\n      case 6:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return 0;\n          }\n          id = id[0x4c];\n          id = id[0x4e];\n          *id = id + 1;\n          if(*(type)(id + id) != (type)(id >> (call(id << 3) & 0x1f)))break;\n          id = *id;\n          *id = id + 1;\n          if(3 < id + 1){\n            return 1;\n          }\n        }\n        return 9;\n      case def:\n        return 0xb;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = 0;\n  id = *id - id;\n  if(id == 0){\n    return 0;\n  }\n  lbl:\n  id = call(id + id, id, id[0x4e]);\n  id[0x4e] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.890625,
          "base_ppl": 2.109375,
          "pr_ppl": 2.078125,
          "source_ast_ppl": 3.25,
          "base_ast_ppl": 2.625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B restructures the switch case handling to avoid goto statements and aligns the control flow with the original source's structured approach. The original source uses clear case labels and avoids goto, which Candidate B mirrors by reorganizing the code into labeled blocks without jumps, improving structural isomorphism.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores the 'SwitchStatement' topology with expanded case 5 logic matching the Source's nested checks and loop structure, while Candidate A's minimal case 5 lacks these details. B's nested complexity and label handling align with the Ground Truth's structure.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013d6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013d6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id)++] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = 0;\n        id->id = (id->id == 0 ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = 0;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (--id->id == 0 ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(4) - call(id->id.id, id->id.id)) & 3;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > 0){\n        --id->id;\n        if(id[(*id)++] != 0x00)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != 0)return id;\n      id->id = call(id + id, *id - id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id >> (id->id * 8)) & 0xFF) != id[(*id)++]){\n          idreturn id;\n        }\n      }while(++id->id < 4);\n      return id;\n    case def:\n      call(0);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id - id;\n    if(id > 0)id->id = call(id + id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return 10;\n  }\n  id = (type)(id + 0x4c);\n  id = (type)(id + 0x46);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case 0:\n        *id = id + 1;\n        id = 1;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        break;\n      case 1:\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        if(*(type)(id + 0x46) != *(type)(id + 6)){\n          return 9;\n        }\n        *id = 0;\n        id = call(*(type)(id + 0x46) == 0) * 2 + 2;\n        break;\n      case 2:\n      case 3:\n        id = id + 0x48;\n        if(id != 2){\n          id = id + 0x4a;\n        }\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        id[0x4c] = 0;\n        id[0x4d] = 0;\n        if(*id == 2){\n          id = 3;\n          if(*(type)(id + 0x48) + 0x8000000000000003U < 0x8000000000000008){\n            return 9;\n          }\n        }else{\n          call(id + 0x24, *(type)(id + 0x48), *(type)(id + 0x4a));\n          if(*(type)(id + 2) < *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) < *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) < *(type)(id + 0x2a)){\n            return 9;\n          }\n          *id = *id + -1;\n          id = call(*id == 0) * 2 + 2;\n        }\n        break;\n      case 4:\n        id = call(*(type)(id + 0x28), *(type)(id + 0x2a));\n        id = call(-id & 3);\n        *(type)(id + 0x4c) = id;\n        *id = 5;\n        goto lbl;\n      case 5:\n        id = *id;\n        lbl:\n        if(id == 0){\n          if(*(type)(id + 2) != *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) != *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) != *(type)(id + 0x2a)){\n            return 9;\n          }\n          call(id + 10, 10);\n          call(id + 0x2c, 10);\n          id = call(10);\n          id = call(id + 10, id + 0x2c, (type)id);\n          if(id != 0){\n            return 9;\n          }\n          id = call(id + id, *id - id, id[0x4e]);\n          id[0x4e] = id;\n          *id = 6;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return 0;\n            }\n            id = id[0x4c];\n            id = id[0x4e];\n            *id = id + 1;\n            if(*(type)(id + id) != (type)(id >> (call(id << 3) & 0x1f)))break;\n            id = *id;\n            *id = id + 1;\n            if(3 < id + 1){\n              return 1;\n            }\n          }\n          return 9;\n        }\n        *id = id - 1;\n        id = *id;\n        *id = id + 1;\n        id = 5;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        goto lbl;\n      case 6:\n        goto lbl;\n      case def:\n        return 0xb;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = 0;\n  lbl:\n  if(*id - id == 0){\n    return id;\n  }\n  id = call(id + id, *id - id, id[0x4e]);\n  id[0x4e] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return 10;\n  }\n  id = (type)(id + 0x4c);\n  id = (type)(id + 0x46);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case 0:\n        *id = id + 1;\n        id = 1;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        break;\n      case 1:\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        if(*(type)(id + 0x46) != *(type)(id + 6)){\n          return 9;\n        }\n        *id = 0;\n        id = call(*(type)(id + 0x46) == 0) * 2 + 2;\n        break;\n      case 2:\n      case 3:\n        id = id + 0x48;\n        if(id != 2){\n          id = id + 0x4a;\n        }\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        id[0x4c] = 0;\n        id[0x4d] = 0;\n        if(*id == 2){\n          id = 3;\n          if(*(type)(id + 0x48) + 0x8000000000000003U < 0x8000000000000008){\n            return 9;\n          }\n        }else{\n          call(id + 0x24, *(type)(id + 0x48), *(type)(id + 0x4a));\n          if(*(type)(id + 2) < *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) < *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) < *(type)(id + 0x2a)){\n            return 9;\n          }\n          *id = *id + -1;\n          id = call(*id == 0) * 2 + 2;\n        }\n        break;\n      case 4:\n        id = call(*(type)(id + 0x28), *(type)(id + 0x2a));\n        id = call(-id & 3);\n        *(type)(id + 0x4c) = id;\n        *id = 5;\n        if(id == 0)goto lbl;\n        lbl:\n        *id = id - 1;\n        id = *id;\n        *id = id + 1;\n        id = 5;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        goto lbl;\n      case 5:\n        id = *id;\n        if(id != 0)goto lbl;\n        lbl:\n        if(*(type)(id + 2) != *(type)(id + 0x24)){\n          return 9;\n        }\n        if(*(type)(id + 4) != *(type)(id + 0x26)){\n          return 9;\n        }\n        if(*(type)(id + 8) != *(type)(id + 0x2a)){\n          return 9;\n        }\n        call(id + 10, 10);\n        call(id + 0x2c, 10);\n        id = call(10);\n        id = call(id + 10, id + 0x2c, (type)id);\n        if(id != 0){\n          return 9;\n        }\n        id = call(id + id, *id - id, id[0x4e]);\n        id[0x4e] = id;\n        *id = 6;\n      case 6:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return 0;\n          }\n          id = id[0x4c];\n          id = id[0x4e];\n          *id = id + 1;\n          if(*(type)(id + id) != (type)(id >> (call(id << 3) & 0x1f)))break;\n          id = *id;\n          *id = id + 1;\n          if(3 < id + 1){\n            return 1;\n          }\n        }\n        return 9;\n      case def:\n        return 0xb;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = 0;\n  lbl:\n  if(*id - id == 0){\n    return id;\n  }\n  id = call(id + id, *id - id, id[0x4e]);\n  id[0x4e] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.890625,
          "base_ppl": 2.140625,
          "pr_ppl": 2.078125,
          "source_ast_ppl": 3.25,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = (((*(id)))) - str;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 12)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  12;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.5625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.359375,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 3.25,
          "pr_ast_ppl": 3.28125,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses a more idiomatic array access syntax (`_sav_time_parse_cond_targs[uVar12]`), which aligns with standard C conventions and avoids explicit pointer arithmetic. The switch statement in Candidate A also uses `undefined1`, a more specific type, which improves clarity compared to the less descriptive `undefined` in Candidate B. Both versions share the same control flow structure (switch), but Candidate A's syntax is more readable and conventional, reducing cognitive load for human readers.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A preserves the original switch structure by dereferencing _acts directly, matching the source code's use of switch ( (*( _acts)) ). Candidate B introduces a memory address calculation, diverging from the source's clear pointer dereference approach.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A uses a more direct expression (id[id]) without introducing pointer arithmetic via &id, which aligns with simpler, less machine-like idioms. Candidate B's use of &id introduces explicit pointer manipulation, which leans toward low-level concrete operations. Since the control flow structure remains unchanged, the tie-breaker favors Candidate A's less artificial expression.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the original cast structure present in the Source AST, while Candidate B introduces a new node type (`&id`) not found in the Source. The Source's line uses a simple cast `(type)id[id]`, and Candidate A's extra cast does not alter the fundamental node type (cast), whereas Candidate B's use of `&id` introduces a different operation (address-of) absent in the Source.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = (((*(id)))) - str;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 12)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  12;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.5625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.359375,
          "source_ast_ppl": 2.703125,
          "base_ast_ppl": 3.25,
          "pr_ast_ppl": 3.28125,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A uses a more concise and idiomatic array access syntax, which aligns with human-readable C conventions. The change in Candidate B introduces an unnecessary address-of operator that does not alter logic but increases syntactic complexity without benefit. Both versions share identical control flow structures (switch, do-while), but Candidate A's brevity reduces cognitive load.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A preserves the original array indexing (`_sav_time_parse_cond_targs[_trans]`) and uses a switch on the action value from `_acts`, aligning with the source's variable-based control flow. Candidate B introduces pointer arithmetic (`&_sav_time_parse_cond_targs[uVar12]`) and memory address calculations, diverging from the source's structured array access and switch logic.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A uses a simpler expression `id[id]` without unnecessary pointer arithmetic, which aligns with idiomatic C practices. Candidate B introduces `&id` which may imply low-level pointer manipulation, making the code feel more like a machine-level hack. Since the control flow structure remains unchanged and the logic is not clearly improved, Candidate A's cleaner expression is more human-like.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the original array indexing structure (id[id]) present in the Source, while Candidate B introduces a pointer-to-id (&id) and additional casting that diverges from the Source's topology and complexity. The Source's line is a simple array access without pointer arithmetic or nested casts, making Candidate A structurally aligned.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < 0){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(0 < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.5625,
          "base_ppl": 2.640625,
          "pr_ppl": 2.609375,
          "source_ast_ppl": 4.28125,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B's condition '0 < (int)uVar1' directly expresses the intent of checking for a positive value, avoiding the counterintuitive negation used in Candidate A. This aligns with human-readable logic by eliminating unnecessary arithmetic negation, making the control flow more intuitive and closer to natural language reasoning.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B's condition `0 < (int)uVar1` is logically equivalent to Candidate A's `(int)-uVar1 < 0` but is more readable and aligns with standard C-style checks (e.g., `if (value != 0)`). While the structural isomorphism (e.g., `for`, `switch`) is unchanged, the correction improves clarity without introducing noise, aligning closer to the source's intent.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B simplifies the condition to a direct comparison with zero (0 < (type)id), which is more idiomatic and aligns with human-readable logic. The original condition ((type)-id < 0) is semantically equivalent but requires mental inversion of the inequality, making it less intuitive. Clear, straightforward comparisons are preferred in idiomatic design.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "motivation": "Candidate B's condition '0 < (type)id' aligns with the Source's logical structure by directly checking positivity, which matches the typical pattern in the Ground Truth's nested control flow. Candidate A's condition '((type)-id < 0)' is logically equivalent but uses negation, which may diverge from the Source's explicit comparison style.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < 0){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(0 < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.5625,
          "base_ppl": 2.640625,
          "pr_ppl": 2.609375,
          "source_ast_ppl": 4.28125,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B simplifies the conditional logic by directly checking if uVar1 is positive (0 < (int)uVar1), which is more intuitive and avoids the negation and implicit inversion of Candidate A's ((int)-uVar1 < 0). This aligns with human-like logic by reducing cognitive overhead and eliminating unnecessary arithmetic negation.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate B simplifies the condition by avoiding nested negation, making the logic more direct and idiomatic. The comparison `0 < (type)id` aligns with common C-style readability (checking positivity directly), whereas Candidate A's `(type)-id < 0` introduces a confusing negation that obscures the intent. Since both conditions are logically equivalent, Candidate B's cleaner expression reduces cognitive load and adheres to idiomatic conventions.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem. So, the task is to determine whether Candidate A or Candidate B in the diff matches the Source AST topology better. The criteria given are Topology Match and Complexity, specifically looking at node types and nesting depth.\n\nFirst, I need to understand the Ground Truth (Source AST) code. It's a C function with a lot of type declarations, assignments, conditionals, loops, and a switch statement. There's a switch with multiple cases, some gotos, and calls to functions. The structure seems quite complex with nested statements and control flow.\n\nNow, looking at the AST Diff between A and B. The diff shows a change in a conditional statement. In Candidate A, the line is: if((type)-id < 0){ ... }, and in Candidate B, it's: if(0 < (type)id){ ... }.\n\nThe question is which of these two lines aligns better with the Source AST's structure. The original Source code has a switch statement with cases and a goto label. But the diff is about a specific if condition. \n\nThe first criterion is Topology Match: Does the '+' code (Candidate B) restore a node type present in the Source but missing in Candidate A? The original Source code has a switch statement, but the diff here is about an if statement. The node types here are if statements. Both A and B have if statements. So maybe this isn't about adding a new node type but about the structure of the condition.\n\nThe second criterion is Complexity: Does the '+' code match the nesting depth of the Source? The Source code has complex nesting with loops, switches, and multiple levels of conditionals. The specific line in question is part of a do-while loop inside the for loop. The original condition in the Source might have been something else, but the diff shows a change in the condition's structure.\n\nLooking at the original Source code, the line in question is part of a do-while loop. The original code in the Source might have had a condition that checks if (type)-id < 0. But in the diff, Candidate A has that condition, while Candidate B flips the comparison to 0 < (type)id. \n\nWait, but the problem is that the Ground Truth is the Source AST. The diff is between two versions (A and B) of the code. The user wants to know which of these two candidates (A or B) mirrors the Source's AST topology. However, the provided Ground Truth is the original code, and the diff shows a change between A and B. But the original Source code's line might be different. Wait, the Ground Truth is the Source AST, and the diff is between two versions (A and B) that are being compared against that Source.\n\nWait, the user says: \"Determine which version in the Diff (A or B) mirrors the Source AST topology.\" So the Source is the original, and the Diff shows changes between A and B. So, the question is, which of A or B is closer to the original Source's structure.\n\nBut the problem is that the Ground Truth (Source AST) code provided is the original. The diff shows a change in a line of code. The original code (Ground Truth) might have a certain structure, and the candidates A and B are modified versions. But how do we know what the original line was?\n\nWait, the diff shows that in the original (Ground Truth), the line was part of the code. But the diff is between A and B. Wait, perhaps the Ground Truth is the original code, and the diff is between two versions (A and B) that are being compared to see which is closer to the original. But the diff shows a change in a specific line. However, the original code (Ground Truth) might have a different line here. Wait, the user provided the Ground Truth code, which includes the line in question. Let me check.\n\nLooking at the Ground Truth code, the line in question is part of the do-while loop. Let me find the exact line. The diff is around line 41. The Ground Truth code's line 41 would be part of the do-while loop. Let me check the Ground Truth code:\n\nIn the Ground Truth code, there's a do-while loop inside the for loop. The code snippet in the Ground Truth around that area is:\n\n...\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      ...\n    }\n  }\n  lbl:\n  call(str, id);\n  ...\n\nWait, but the diff is about a line that's part of a do-while loop. Wait, the diff shows:\n\nIn the Ground Truth, the code is:\n\ndo{\n  id = *id;\n  id = -id;\n  if((type)-id < 0){\n    id = id;\n  }\n  if(id <= id){\n...\n\nBut the diff shows that in Candidate A, the line is if((type)-id < 0), and in Candidate B, it's if(0 < (type)id). So the original code (Ground Truth) must have had the line as in Candidate A or B? Wait, the user says that the Ground Truth is the Source AST, and the diff is between A and B. So the original code (Ground Truth) is the one that's being compared against. But how do we know which of A or B is closer to the original?\n\nWait, the problem is that the user hasn't provided the original code's exact line here. Wait, the Ground Truth code is provided, but the diff is between A and B. So the original code (Ground Truth) must have a line that's either A or B. But the user hasn't given the original code's line here. Wait, the user says that the Ground Truth is the Source AST, and the diff is between A and B. So the original code (Ground Truth) is the one that's being compared against. However, the diff shows that the original code (Ground Truth) has a line that's different from both A and B? Or is the Ground Truth the original code, and the diff shows that A and B are modified versions of that original code?\n\nWait, the way the problem is structured: the user is comparing two versions (A and B) of a code snippet against the original (Ground Truth). The diff shows the changes between A and B. The user wants to know which of A or B is closer to the original Source's AST structure.\n\nBut the original code (Ground Truth) is provided. So the original code's line in question is the one that's in the Ground Truth. However, the diff shows that in the original code, the line was part of the code. But the user hasn't provided the original code's exact line here. Wait, the Ground Truth code includes the entire function, so the line in question is part of that function.\n\nLooking at the Ground Truth code, the line in question is part of a do-while loop. Let me find that part in the Ground Truth code. The Ground Truth code has:\n\n...\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        ...\n    }\n  }\n  lbl:\n  call(str, id);\n  ...\n\nWait, but where is the do-while loop? The diff is at line 41. Let me check the Ground Truth code again. The Ground Truth code has a do-while loop? Wait, the Ground Truth code as provided doesn't have a do-while loop. Wait, the diff shows a do-while loop in the code. Let me re-examine the Ground Truth code.\n\nWait, the Ground Truth code provided by the user includes the following lines:\n\n...\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      ...\n    }\n  }\n  ...\n\nWait, there's no do-while loop here. The diff mentions a do-while loop. But the Ground Truth code provided by the user doesn't have a do-while loop. Hmm, this is confusing. Maybe the Ground Truth code has a do-while loop that's not shown in the provided code? Or perhaps there's a mistake in the problem setup.\n\nAlternatively, perhaps the Ground Truth code's line in question is part of a do-while loop that's not shown in the provided code. But the user provided the entire Ground Truth code, so I need to check again.\n\nWait, the diff is between lines 41 in the Ground Truth. Let me count the lines in the Ground Truth code. But since the code is provided as a single block, it's hard to count. However, the diff shows that the line in question is part of a do-while loop. Let's assume that in the Ground Truth code, there's a do-while loop that includes the line in question.\n\nAssuming that the original code (Ground Truth) has the line: if((type)-id < 0), which is Candidate A's line. But the diff shows that Candidate B changes it to if(0 < (type)id). So the question is, which of these two lines (A or B) is closer to the original Source's structure.\n\nBut how can we determine that without knowing the original code's line? Wait, the user says that the Ground Truth is the Source AST. Therefore, the original code's line is the one that's in the Ground Truth. However, the diff shows that the original code (Ground Truth) has a line that is different from both A and B? Or perhaps the Ground Truth code's line is the same as one of the candidates.\n\nWait, the user's input includes the Ground Truth code, which is the original. The diff is between two versions (A and B) of that code. The user wants to know which of A or B is closer to the original.\n\nBut the problem is that the Ground Truth code is the original, and the diff shows that A and B are modified versions. However, the user hasn't provided the original code's line here. Wait, the diff shows that in the original code (Ground Truth), the line is part of the code. But the user hasn't provided the exact line from the Ground Truth code. Therefore, I need to infer based on the diff.\n\nThe diff shows that in Candidate A, the line is if((type)-id < 0), and in Candidate B, it's if(0 < (type)id). The original code (Ground Truth) must have had one of these lines. But the user hasn't provided the original code's line. Wait, the user provided the entire Ground Truth code, so I need to check if the line in question is present in the Ground Truth code.\n\nLooking back at the Ground Truth code, the line in question is part of a do-while loop. Let me search for the line in the Ground Truth code. The Ground Truth code has:\n\n...\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}\n\nWait, I don't see a do-while loop in the Ground Truth code. The diff mentions a do-while loop, but the Ground Truth code provided doesn't have one. This is confusing. Maybe the Ground Truth code has a do-while loop that's not shown here, or there's a mistake in the problem setup.\n\nAlternatively, perhaps the line in question is part of a for loop or another structure. Given the confusion, perhaps I should focus on the criteria given: Topology Match and Complexity.\n\nThe first criterion is whether Candidate B restores a node type present in the Source but missing in Candidate A. However, both A and B have if statements. So this criterion may not apply here.\n\nThe second criterion is Complexity: Does Candidate B match the nesting depth of the Source? The original code's line may have a certain nesting level. For example, if the original code had a more complex condition, like involving a cast and a comparison, then Candidate B's condition (0 < (type)id) might be more similar in structure.\n\nAlternatively, the original code's line might be similar to Candidate A's condition. Without knowing the original code's exact line, it's hard to say. However, the user provided the Ground Truth code, which is the original. So perhaps the original code's line is the same as Candidate A or B.\n\nWait, the diff shows that in the Ground Truth code, the line is part of the code. The diff is between A and B. The user's instruction says that the Ground Truth is the Source AST. Therefore, the original code (Ground Truth) has the line that is either A or B. But how?\n\nWait, the diff is presented as a patch between A and B. The lines - are Candidate A, + are Candidate B. The original code (Ground Truth) is the one that's being compared. But the user hasn't provided the original code's line here. Therefore, the user must have provided the original code's line in the Ground Truth, and the diff shows that A and B are modified versions. But without seeing the original line, it's impossible to compare.\n\nThis seems like a problem with the input data. However, given the information provided, I need to make an educated guess.\n\nAssuming that the original code's line is the same as Candidate A (since the diff shows that Candidate A has the line with (type)-id < 0), and Candidate B changes it. But the user wants to know which of A or B matches the Source's structure.\n\nAlternatively, perhaps the original code's line is the same as Candidate B. But without knowing, this is tricky.\n\nAlternatively, looking at the structure of the condition. The original condition in the Source might have been checking if (type)-id is negative, which is equivalent to checking if id is positive. Because (type)-id < 0 would be true when -id is negative, which means id is positive. Similarly, 0 < (type)id would check if id is positive. So both conditions are logically equivalent. However, the structure of the condition might differ in terms of AST nodes.\n\nThe original condition in the Source might have been (type)-id < 0. If that's the case, then Candidate A matches the Source, and Candidate B is a change. But the user is asking which of A or B mirrors the Source's topology.\n\nBut the problem is that the user hasn't provided the original code's line. Therefore, this is a critical missing piece. However, given the information, perhaps the answer is based on the fact that Candidate B's condition (0 < (type)id) is a more straightforward comparison, which might align with the Source's structure if the original code had that condition. But without knowing the original, it's hard.\n\nAlternatively, the user might have made a mistake in the input, and the Ground Truth code's line is actually the same as Candidate B. But without that information, I can't proceed.\n\nGiven the ambiguity, perhaps the answer is that Candidate B is the winner because it uses a more standard comparison structure (0 < (type)id) which might align with"
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id = 0;\n  type id = id;\n  type *id = id->id;\n  type *id = call(1, (id));\n  type *id = call(1, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > 0)id->id = id->id;\n  if(call(id, id->id) == -1){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(0, id, id->id)) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(0, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() ^ id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? 8 : 4);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == null){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == null){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != 0){\n    type id = call(id->id, id->id);\n    if(id == (id) - 1){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, 0)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), str, call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = *(type)((type)id + 0x40);\n  id = id;\n  id = id;\n  id = id;\n  id = call(1, 0xdd0);\n  id = call(1, 0x180);\n  call(id, id, 0x40);\n  *(type)((type)id + 0x120) = *(type)((type)id + 0x48);\n  *(type)((type)id + 0x128) = *(type)((type)id + 0x50);\n  *(type)((type)id + 0x58) = id;\n  *(type)((type)id + 0x60) = *(type)((type)id + 0x40);\n  *(type)((type)id + 0x80) = (type)*(type)((type)id + 0x58);\n  if(0 < *(type)((type)id + 0x60)){\n    *(type)((type)id + 0x84) = (type)*(type)((type)id + 0x60);\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n  }else{\n    id = call(0, 2, id[5]);\n    *(type)((type)id + 0x40) = id;\n    if(id == -1){\n      id = 0xf;\n      if(*(type)((type)id + 0x30) != 0){\n        call((type)((type)id + 0x5ce), 0x800, str);\n        call((type)id + 0x5ce, *(type)((type)id + 0x58));\n      }\n    }else{\n      id = call(0, 0, id[5]);\n      if(id == -1){\n        id = 0xf;\n        if(*(type)((type)id + 0x30) != 0){\n          call((type)((type)id + 0x5ce), 0x800, str);\n          call((type)id + 0x5ce, *(type)((type)id + 0x58));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id + 0x30), id);\n        if(id == 0){\n          *(type)((type)id + 0x4c) = id[1];\n          *(type)((type)id + 0x48) = *id;\n          *(type)((type)id + 0x50) = id[2];\n          id = call();\n          *(type)((type)id + 0x68) = id ^ *id;\n          *(type)((type)id + 0x88) = *(type)(id + 0x10);\n          *(type)((type)id + 0x90) = *(type)(id + 0xe);\n          *(type)((type)id + 0x98) = *(type)(id + 8);\n          *(type)((type)id + 0xb0) = *(type)(id + 10);\n          *(type)((type)id + 0xc0) = *(type)(id + 0xc);\n          id = 4;\n          if(*(type)((type)id + 0x4c) != 0){\n            id = 8;\n          }\n          *(type)((type)id + 0xb8) = (type)id;\n          *(type)((type)id + 0x138) = *(type)(id + 0x12);\n          *(type)((type)id + 0x140) = *(type)(id + 0x14);\n          *(type)((type)id + 0x148) = id[3];\n          if(*(type)((type)id + 0x120) == 0){\n            *(type)((type)id + 0x120) = *(type)(id + 0x5e);\n          }\n          id = call(*(type)((type)id + 0x98));\n          *(type)((type)id + 0xa0) = id;\n          if(id == 0){\n            id = 3;\n          }else{\n            if(((*(type)((type)id + 0x120) != 0) && (*(type)((type)id + 0x128) != 0)) && (id = call(*(type)((type)id + 0x120), *(type)((type)id + 0x128))id != 0)){\n              id = call(*(type)((type)id + 0x128), *(type)((type)id + 0x120));\n              if(id == (type)0xffffffffffffffff){\n                id = 7;\n                goto lbl;\n              }\n              *(type)((type)id + 0x130) = id;\n            }\n            id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, *(type)((type)id + 0x130));\n            if(((id == 0) && (id = call(id, &id)id == 0)) && (id = call(id, id)id == 0)){\n              id = call(*(type)((type)id + 0x88), 0, id[5]);\n              if(id == -1){\n                id = 0xf;\n                if(*(type)((type)id + 0x30) != 0){\n                  call((type)((type)id + 0x5ce), 0x800, str, *(type)((type)id + 0x88));\n                  call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                }\n              }else{\n                id = call(id);\n                if((id == 0) && (id = call(id, 0)id == 0)){\n                  if((*(type)((type)id + 0x20) == 0) || (*(type)((type)id + 0x78) == *(type)((type)id + 0x80))){\n                    id = call(id);\n                  }else{\n                    id = 9;\n                    if(*(type)((type)id + 0x30) != 0){\n                      call((type)((type)id + 0x5ce), 0x800, str, (id) * (type)((type)id + 0x80), (id) * (type)((type)id + 0x78));\n                      call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[5]);\n  if((((id == 1) || (id == 2)) || (id == 0xf)) && (*(type)((type)id + 0x30) != 0)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id + 0x5ce), 0x800, str, id, (type)id, id, *id);\n    call((type)id + 0x5ce, id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = *(type)((type)id + 0x40);\n  id = id;\n  id = id;\n  id = id;\n  id = call(1, 0xdd0);\n  id = (type)call(1, 0x180);\n  call(id, id, 0x40);\n  *(type)((type)id + 0x120) = *(type)((type)id + 0x48);\n  *(type)((type)id + 0x128) = *(type)((type)id + 0x50);\n  *(type)((type)id + 0x58) = id;\n  *(type)((type)id + 0x60) = *(type)((type)id + 0x40);\n  *(type)((type)id + 0x80) = (type)*(type)((type)id + 0x58);\n  if(0 < *(type)((type)id + 0x60)){\n    *(type)((type)id + 0x84) = (type)*(type)((type)id + 0x60);\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n  }else{\n    id = call(0, 2, id[5]);\n    *(type)((type)id + 0x40) = id;\n    if(id == -1){\n      id = 0xf;\n      if(*(type)((type)id + 0x30) != 0){\n        call((type)((type)id + 0x5ce), 0x800, str);\n        call((type)id + 0x5ce, *(type)((type)id + 0x58));\n      }\n    }else{\n      id = call(0, 0, id[5]);\n      if(id == -1){\n        id = 0xf;\n        if(*(type)((type)id + 0x30) != 0){\n          call((type)((type)id + 0x5ce), 0x800, str);\n          call((type)id + 0x5ce, *(type)((type)id + 0x58));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id + 0x30), id);\n        if(id == 0){\n          *(type)((type)id + 0x4c) = id[1];\n          *(type)((type)id + 0x48) = *id;\n          *(type)((type)id + 0x50) = id[2];\n          id = call();\n          *(type)((type)id + 0x68) = id ^ *id;\n          *(type)((type)id + 0x88) = *(type)(id + 0x10);\n          *(type)((type)id + 0x90) = *(type)(id + 0xe);\n          *(type)((type)id + 0x98) = *(type)(id + 8);\n          *(type)((type)id + 0xb0) = *(type)(id + 10);\n          *(type)((type)id + 0xc0) = *(type)(id + 0xc);\n          id = 4;\n          if(*(type)((type)id + 0x4c) != 0){\n            id = 8;\n          }\n          *(type)((type)id + 0xb8) = (type)id;\n          *(type)((type)id + 0x138) = *(type)(id + 0x12);\n          *(type)((type)id + 0x140) = *(type)(id + 0x14);\n          *(type)((type)id + 0x148) = id[3];\n          if(*(type)((type)id + 0x120) == 0){\n            *(type)((type)id + 0x120) = *(type)(id + 0x5e);\n          }\n          id = call(*(type)((type)id + 0x98));\n          *(type)((type)id + 0xa0) = id;\n          if(id == 0){\n            id = 3;\n          }else{\n            if(((*(type)((type)id + 0x120) != 0) && (*(type)((type)id + 0x128) != 0)) && (id = call(*(type)((type)id + 0x120), *(type)((type)id + 0x128))id != 0)){\n              id = call(*(type)((type)id + 0x128), *(type)((type)id + 0x120));\n              if(id == (type)0xffffffffffffffff){\n                id = 7;\n                goto lbl;\n              }\n              *(type)((type)id + 0x130) = id;\n            }\n            id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, *(type)((type)id + 0x130));\n            if(((id == 0) && (id = call(id, &id)id == 0)) && (id = call(id, id)id == 0)){\n              id = call(*(type)((type)id + 0x88), 0, id[5]);\n              if(id == -1){\n                id = 0xf;\n                if(*(type)((type)id + 0x30) != 0){\n                  call((type)((type)id + 0x5ce), 0x800, str, *(type)((type)id + 0x88));\n                  call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                }\n              }else{\n                id = call(id);\n                if((id == 0) && (id = call(id, 0)id == 0)){\n                  if((*(type)((type)id + 0x20) == 0) || (*(type)((type)id + 0x78) == *(type)((type)id + 0x80))){\n                    id = call(id);\n                  }else{\n                    id = 9;\n                    if(*(type)((type)id + 0x30) != 0){\n                      call((type)((type)id + 0x5ce), 0x800, str, (id) * (type)((type)id + 0x80), (id) * (type)((type)id + 0x78));\n                      call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[5]);\n  if((((id == 1) || (id == 2)) || (id == 0xf)) && (*(type)((type)id + 0x30) != 0)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id + 0x5ce), 0x800, str, id, (type)id, id, *id);\n    call((type)id + 0x5ce, id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.25,
          "base_ppl": 1.875,
          "pr_ppl": 1.890625,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 1.9921875,
          "pr_ast_ppl": 1.9921875,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns with the Source Code structure by allocating 'hinfo' without an unnecessary cast. The Source Code uses 'calloc' directly for struct pointers without typecasting, while Candidate B introduces a '(uint *)' cast that diverges from the original code's type handling.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O2.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      param_3 = __src;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      param_3 = __src + sVar2;\n      if (pbVar3 < param_3) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    param_3 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    if (pbVar3 <= param_3) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    pbVar7 = __src;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = __src + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    pbVar7 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id){\n  type *id = (type)id;\n  type *id = id;\n  type id = 0;\n  type *id = (type)id;\n  while(id < (type)id + id){\n    type id = *id++;\n    type id = (id & 0xF0) >> 4;\n    type id = (id & 0x0F);\n    type id = 0;\n    type id = 0;\n    type id = str;\n    if(id + id[id] > (type)id + id){\n      return -1;\n    }\n    switch(id){\n      case id:\n        id = (*id++) + 64 + id * 256;\n        break;\n      case id:\n        id = (*id++) + 64 + id * 256 + 4096;\n        break;\n      case id:\n        id = id + 96;\n        break;\n      case id:\n        id = (*id++) + 18 + id * 256;\n        id = *id++;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = id + 1;\n        break;\n      case id:\n        id = id + 17;\n        break;\n      case id:\n        id = id + 33;\n        break;\n      case id:\n        id = id + 49;\n        break;\n      case id:\n        id = *id++;\n        id = id + 3;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id + id > id){\n        return -1;\n      }\n      if(id + id > (type)id + id){\n        return -1;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id + id > id){\n        return -1;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id( id, type id, type *id,  id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  if(id < 1){\n    return 0;\n  }\n  id = id + id;\n  id = 0;\n  do{\n    id = id + 1;\n    id = *id >> 4;\n    if(id < id + *(type)(id + (type)(type)id * 8)){\n      return 0xffffffffffffffff;\n    }\n    if(0xf < id){\n      lbl:\n      id = id;\n      id = id;\n      goto lbl;\n    }\n    id = *id & 0xf;\n    switch((type)id){\n      case 0:\n        id = (type)id[1] + call(id << 8) + 0x40;\n        goto lbl;\n      case 1:\n        id = (type)id[1] + call(id << 8) + 0x1040;\n        lbl:\n        id = id + 2;\n        goto lbl;\n      case 2:\n        id = id + 0x60;\n        goto lbl;\n      case 3:\n        goto lbl;\n      case 4:\n        id = (type)id[1] + call(id << 8) + 0x12;\n        id = id[2];\n        id = id + 3;\n        break;\n      case 5:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x40;\n        break;\n      case 6:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x20;\n        break;\n      case 7:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0;\n        break;\n      case 8:\n        id = id + 1;\n        goto lbl;\n      case 9:\n        id = id + 0x11;\n        goto lbl;\n      case 10:\n        id = id + 0x21;\n        goto lbl;\n      case 0xb:\n        id = id + 0x31;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        if(id != 0){\n          call((type)(id + id), id, id);\n        }\n        goto lbl;\n      case 0xc:\n        id = id[1];\n        id = id + 2;\n        id = (type)(id + 3);\n        break;\n      case 0xd:\n        id = (type)(id + 2);\n        id = 0x40;\n        break;\n      case 0xe:\n        id = (type)(id + 2);\n        id = 0x20;\n        break;\n      case 0xf:\n        id = (type)(id + 2);\n        id = 0;\n    }\n    id = id + id;\n    if(id < id){\n      return 0xffffffffffffffff;\n    }\n    id = id;\n    if(id != 0){\n      call((type)(id + id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id( id, type id, type *id,  id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  if(id < 1){\n    return 0;\n  }\n  id = id + id;\n  id = 0;\n  do{\n    id = id + 1;\n    id = *id >> 4;\n    if(id < id + *(type)(id + (type)(type)id * 8)){\n      return 0xffffffffffffffff;\n    }\n    id = id;\n    id = id;\n    if(0xf < id)goto lbl;\n    id = *id & 0xf;\n    switch((type)id){\n      case 0:\n        id = (type)id[1] + call(id << 8) + 0x40;\n        goto lbl;\n      case 1:\n        id = (type)id[1] + call(id << 8) + 0x1040;\n        lbl:\n        id = id + 2;\n        goto lbl;\n      case 2:\n        id = id + 0x60;\n        goto lbl;\n      case 3:\n        goto lbl;\n      case 4:\n        id = (type)id[1] + call(id << 8) + 0x12;\n        id = id[2];\n        id = id + 3;\n        break;\n      case 5:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x40;\n        break;\n      case 6:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x20;\n        break;\n      case 7:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0;\n        break;\n      case 8:\n        id = id + 1;\n        goto lbl;\n      case 9:\n        id = id + 0x11;\n        goto lbl;\n      case 10:\n        id = id + 0x21;\n        goto lbl;\n      case 0xb:\n        id = id + 0x31;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        if(id != 0){\n          call((type)(id + id), id, id);\n        }\n        goto lbl;\n      case 0xc:\n        id = id[1];\n        id = id + 2;\n        id = (type)(id + 3);\n        break;\n      case 0xd:\n        id = (type)(id + 2);\n        id = 0x40;\n        break;\n      case 0xe:\n        id = (type)(id + 2);\n        id = 0x20;\n        break;\n      case 0xf:\n        id = (type)(id + 2);\n        id = 0;\n    }\n    id = id + id;\n    if(id < id){\n      return 0xffffffffffffffff;\n    }\n    id = id;\n    if(id != 0){\n      call((type)(id + id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8828125,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.7265625,
          "source_ast_ppl": 2.109375,
          "base_ast_ppl": 2.3125,
          "pr_ast_ppl": 2.28125,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "motivation": "Candidate B avoids nested `goto` within a `switch` statement, replacing it with a direct jump to a label outside the switch. This reduces spaghetti control flow and improves readability by using a consistent pointer variable (`pbVar7`) instead of reassigning `param_3` repeatedly. The restructuring aligns with semantic control flow over graph artifacts, making the logic more linear and easier to follow.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B preserves the switch statement structure present in the Source Code, which is critical for command handling. The original code uses a switch on 'command', and Candidate B's switch on (uint)bVar5 aligns with this control flow pattern. Candidate A's use of goto and lack of explicit switch cases deviates from the structured approach of the Source Code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE.",
          "raw_response": ""
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O3.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id){\n  type *id = (type)id;\n  type *id = id;\n  type id = 0;\n  type *id = (type)id;\n  while(id < (type)id + id){\n    type id = *id++;\n    type id = (id & 0xF0) >> 4;\n    type id = (id & 0x0F);\n    type id = 0;\n    type id = 0;\n    type id = str;\n    if(id + id[id] > (type)id + id){\n      return -1;\n    }\n    switch(id){\n      case id:\n        id = (*id++) + 64 + id * 256;\n        break;\n      case id:\n        id = (*id++) + 64 + id * 256 + 4096;\n        break;\n      case id:\n        id = id + 96;\n        break;\n      case id:\n        id = (*id++) + 18 + id * 256;\n        id = *id++;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = id + 1;\n        break;\n      case id:\n        id = id + 17;\n        break;\n      case id:\n        id = id + 33;\n        break;\n      case id:\n        id = id + 49;\n        break;\n      case id:\n        id = *id++;\n        id = id + 3;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id + id > id){\n        return -1;\n      }\n      if(id + id > (type)id + id){\n        return -1;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id + id > id){\n        return -1;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id( id, type id, type *id,  id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  if(id < 1){\n    return 0;\n  }\n  id = id + id;\n  id = 0;\n  do{\n    id = id + 1;\n    id = *id >> 4;\n    if(id < id + *(type)(id + (type)(type)id * 8)){\n      return 0xffffffffffffffff;\n    }\n    if(0xf < id){\n      lbl:\n      id = id;\n      goto lbl;\n    }\n    id = *id & 0xf;\n    switch((type)id){\n      case 0:\n        id = (type)id[1] + call(id << 8) + 0x40;\n        goto lbl;\n      case 1:\n        id = (type)id[1] + call(id << 8) + 0x1040;\n        lbl:\n        id = id + 2;\n        goto lbl;\n      case 2:\n        id = id + 0x60;\n        goto lbl;\n      case 3:\n        goto lbl;\n      case 4:\n        id = (type)id[1] + call(id << 8) + 0x12;\n        id = id[2];\n        id = id + 3;\n        break;\n      case 5:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x40;\n        break;\n      case 6:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x20;\n        break;\n      case 7:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0;\n        break;\n      case 8:\n        id = id + 1;\n        goto lbl;\n      case 9:\n        id = id + 0x11;\n        goto lbl;\n      case 10:\n        id = id + 0x21;\n        goto lbl;\n      case 0xb:\n        id = id + 0x31;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        if(id != 0){\n          call((type)(id + id), id, id);\n        }\n        goto lbl;\n      case 0xc:\n        id = id[1];\n        id = id + 2;\n        id = (type)(id + 3);\n        break;\n      case 0xd:\n        id = (type)(id + 2);\n        id = 0x40;\n        break;\n      case 0xe:\n        id = (type)(id + 2);\n        id = 0x20;\n        break;\n      case 0xf:\n        id = (type)(id + 2);\n        id = 0;\n    }\n    id = id + id;\n    if(id < id){\n      return 0xffffffffffffffff;\n    }\n    if(id != 0){\n      call((type)(id + id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id( id, type id, type *id,  id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  if(id < 1){\n    return 0;\n  }\n  id = id + id;\n  id = 0;\n  do{\n    id = id + 1;\n    id = *id >> 4;\n    if(id < id + *(type)(id + (type)(type)id * 8)){\n      return 0xffffffffffffffff;\n    }\n    id = id;\n    if(0xf < id)goto lbl;\n    id = *id & 0xf;\n    switch((type)id){\n      case 0:\n        id = (type)id[1] + call(id << 8) + 0x40;\n        goto lbl;\n      case 1:\n        id = (type)id[1] + call(id << 8) + 0x1040;\n        lbl:\n        id = id + 2;\n        goto lbl;\n      case 2:\n        id = id + 0x60;\n        goto lbl;\n      case 3:\n        goto lbl;\n      case 4:\n        id = (type)id[1] + call(id << 8) + 0x12;\n        id = id[2];\n        id = id + 3;\n        break;\n      case 5:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x40;\n        break;\n      case 6:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x20;\n        break;\n      case 7:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0;\n        break;\n      case 8:\n        id = id + 1;\n        goto lbl;\n      case 9:\n        id = id + 0x11;\n        goto lbl;\n      case 10:\n        id = id + 0x21;\n        goto lbl;\n      case 0xb:\n        id = id + 0x31;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        if(id != 0){\n          call((type)(id + id), id, id);\n        }\n        goto lbl;\n      case 0xc:\n        id = id[1];\n        id = id + 2;\n        id = (type)(id + 3);\n        break;\n      case 0xd:\n        id = (type)(id + 2);\n        id = 0x40;\n        break;\n      case 0xe:\n        id = (type)(id + 2);\n        id = 0x20;\n        break;\n      case 0xf:\n        id = (type)(id + 2);\n        id = 0;\n    }\n    id = id + id;\n    if(id < id){\n      return 0xffffffffffffffff;\n    }\n    if(id != 0){\n      call((type)(id + id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8828125,
          "base_ppl": 1.765625,
          "pr_ppl": 1.7265625,
          "source_ast_ppl": 2.109375,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.296875,
          "delta_ppl": -0.0390625
        },
        "llm_qualitative": {
          "motivation": "Candidate B removes redundant conditional checks and labels, streamlining the control flow. By eliminating the nested `if` and `switch` label, it reduces artificial nesting and aligns with cleaner, more linear logic. The direct `goto` in B avoids the complexity of intermediate labels, improving readability while maintaining the same logical outcome.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A retains the explicit `switch` structure with labeled cases, which directly mirrors the Source Code's control flow. Candidate B replaces this with `goto` jumps and removes the `switch` construct, diverging from the original structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate B eliminates the labeled `goto` loop (a graph artifact) and reduces artificial nesting by removing redundant block structure. While both use `goto`, B's version is more concise and avoids the explicit infinite loop syntax, aligning closer with human-like control flow by minimizing machine-oriented constructs.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "<think>\nOkay, let's tackle this problem. So, the task is to determine whether Candidate A or B in the AST diff matches the original source AST topology. The criteria given are Topology Match and Complexity, specifically looking at node types and nesting depth.\n\nFirst, I need to understand the Ground Truth (Source AST) code. The original code has a function with a while loop, inside which there's a switch statement with multiple case labels. The switch has various cases, each with different assignments to 'id'. The structure seems to have a switch statement with multiple case blocks.\n\nLooking at the AST Diff, the difference is in a part of the code. In Candidate A, there's an if statement checking if 0xf < id, followed by a label 'lbl' and a goto. Then, after that, id is assigned and a switch is done on (type)id. In Candidate B, the same if statement is present but the code is rewritten: instead of the label and goto, it's just 'id = id;' and then the if condition uses 'goto lbl' directly.\n\nThe key here is the presence of a SwitchStatement in the original code. The Ground Truth has a switch(id) with multiple case labels. Now, looking at the diff, both A and B have a switch statement. But the question is about whether the '+' (Candidate B) restores a node type present in the Source but missing in '-' (Candidate A). Wait, the original code has a switch statement. Let me check the diff again.\n\nIn the diff, the original code (Ground Truth) has a switch(id) with multiple cases. The diff shows that in the original code (the part being compared), there's a switch statement. Now, looking at the candidates: in Candidate A, the code after the if statement is:\n\n-    if(0xf < id){\n-      lbl:\n-      id = id;\n-      goto lbl;\n-    }\n+    id = id;\n+    if(0xf < id)goto lbl;\n\nSo Candidate A has a label and a goto, which is a loop construct. But the original code (Ground Truth) has a switch statement. However, the diff here is about a part of the code. Wait, the Ground Truth code has a switch statement in the original code. The question is whether Candidate B (the '+') restores a node type present in the Source but missing in Candidate A.\n\nWait, the original code (Ground Truth) has a switch statement. Let me check the diff's context. The diff is showing a part of the code where in the original (Ground Truth), there's a switch statement. But in the diff, the code being compared is part of the while loop. Let me check the exact lines.\n\nIn the Ground Truth, the code inside the while loop includes a switch(id) with multiple cases. The diff provided is about a different part of the code. Wait, the diff shows:\n\nIn the Ground Truth (the original code), the code in the diff is part of the function. The diff is comparing a section where in Candidate A, there's an if statement with a label and goto, and in Candidate B, that's replaced with a different structure.\n\nBut the original code (Ground Truth) has a switch statement. However, the diff here is not about the switch statement in the original code. Wait, maybe I'm misunderstanding the diff's context. Let me re-examine the input.\n\nThe Ground Truth code provided includes a switch(id) with multiple cases. The AST Diff (A vs B) shows a part of the code where the original (Ground Truth) has a switch statement. However, the diff is about a different part of the code. Wait, the diff shows:\n\nIn the Ground Truth (the original code), the code in the diff is part of the function. The diff is comparing a section where in Candidate A, there's an if statement with a label and goto, and in Candidate B, that's replaced with a different structure. However, the original code (Ground Truth) in this part does not have a switch statement here. Wait, maybe I'm getting confused.\n\nWait, the Ground Truth code provided has a switch statement inside the while loop. The diff is about a different part of the code. The diff shows a part where the original code (Ground Truth) has an if statement with a label and goto, and the candidates A and B have different versions of that code. The original code (Ground Truth) in this part is the code that's being compared. Wait, the Ground Truth here is the original code, and the diff is between Candidate A and B. So the original code (Ground Truth) for this part is the code that's being compared. But the problem says that the Ground Truth is the Source AST, and the diff is between A and B. So the question is, which of A or B matches the Source AST's topology.\n\nWait, the user says: \"Determine which version in the Diff (A or B) mirrors the Source AST topology.\"\n\nSo the Source AST is the Ground Truth code provided. The diff is between two candidates (A and B) that are different versions of the code. The task is to see which of A or B is closer to the Source AST's structure.\n\nLooking at the diff, the lines in the Ground Truth (the original code) are:\n\n-    if(0xf < id){\n-      lbl:\n-      id = id;\n-      goto lbl;\n-    }\n+    id = id;\n+    if(0xf < id)goto lbl;\n\nSo the original code (Ground Truth) has this if statement with a label and a goto. But the candidates A and B are different versions. Wait, no. Wait, the diff is between Candidate A and B. The lines with '-' are Candidate A, and '+' are Candidate B. So the original code (Ground Truth) is not part of the diff. Wait, no. The user says:\n\nThe Ground Truth is the Source AST. The diff is between A and B. The question is which of A or B matches the Source AST's structure.\n\nWait, the user provided the Ground Truth code (the Source AST), and then the diff between A and B. The task is to compare A and B against the Source AST to see which one matches better.\n\nSo, the original code (Source AST) has a certain structure. The diff shows that in a certain part of the code, Candidate A has a certain code, and Candidate B has another. The question is, which of A or B is closer to the Source AST's structure.\n\nBut the Ground Truth code provided is the original code. So, for example, if in the Ground Truth code, there's a switch statement, and in the diff, Candidate A doesn't have it, but Candidate B does, then B would be the winner.\n\nBut looking at the diff provided, the code in the diff is part of the function. Let me check the exact code in the Ground Truth. The Ground Truth code has a switch statement inside the while loop. However, the diff is about a different part of the code. The diff is about a part where the original code (Ground Truth) has an if statement with a label and goto. So the question is, in this part of the code, which candidate (A or B) matches the original code's structure.\n\nWait, the Ground Truth code (the Source AST) is the code provided. The diff is between two candidates (A and B) that are different versions of that code. The user wants to know which of A or B is closer to the Source AST's structure.\n\nSo, for example, if the Source AST has a switch statement, and in Candidate A that switch is missing, but in Candidate B it's present, then B would be the winner. However, the diff here is about a different part of the code. The diff shows that in the Source AST, there's an if statement with a label and goto. But the candidates A and B have different versions of that code.\n\nWait, the diff is between A and B. The lines with '-' are Candidate A's code, and '+' are Candidate B's. The original code (Ground Truth) is not part of the diff. Wait, no. The user says that the Ground Truth is the Source AST. So the diff is between two candidates (A and B), and the user wants to know which one matches the Source AST's structure.\n\nBut the Ground Truth code is provided. So the user is saying that the Ground Truth is the original code, and the diff is between two versions (A and B) of that code. So, for example, if the original code has a switch statement, and in Candidate A that switch is missing, but in Candidate B it's present, then B would be the winner.\n\nBut in the given diff, the code being compared is part of the function. The Ground Truth code (the original) has a switch statement in the while loop. However, the diff is about a different part of the code. Let me look again.\n\nThe Ground Truth code provided includes a switch statement inside the while loop. The diff is about a part of the code that's not the switch statement. The diff shows a part where the original code (Ground Truth) has an if statement with a label and goto. The candidates A and B have different versions of that code.\n\nSo, the question is, in this specific part of the code (the if statement with label and goto), which candidate (A or B) matches the Source AST's structure. But the Source AST's structure here is the original code. Wait, the user says that the Ground Truth is the Source AST. So the original code is the Source AST, and the diff is between A and B, which are different versions. The user wants to know which of A or B matches the Source AST's structure.\n\nBut the diff is showing that in the original code (Ground Truth), there's an if statement with a label and goto. However, the candidates A and B are different versions. Wait, no. The diff is between Candidate A and B. The lines with '-' are Candidate A's code, and '+' are Candidate B's code. The original code (Ground Truth) is not part of the diff. Wait, this is confusing.\n\nWait, the user says:\n\n\"Your goal: Determine which version in the Diff (A or B) mirrors the Source AST topology.\"\n\nSo the Source AST is the Ground Truth code. The diff is between two versions (A and B) of the code. The user wants to know which of A or B is closer to the Source AST's structure.\n\nBut the diff is showing that in the Source AST, there's a certain code, and the candidates A and B have different versions. Wait, perhaps the Ground Truth is the original code, and the diff is between A and B, which are modified versions. The user wants to know which of A or B is closer to the original code's structure.\n\nBut the diff is presented as a code diff between A and B. So the original code (Ground Truth) is not part of the diff. Wait, perhaps the user made a mistake in the input. Let me recheck the input.\n\nThe input has:\n\n--- GROUND TRUTH (SOURCE AST) ---\n[... code ...]\n\n--- AST DIFF (A vs B) ---\n--- Candidate A\n+++ Candidate B\n@@ -17,11 +17,8 @@\n     if(id < id + *(type)(id + (type)(type)id * 8)){\n       return 0xffffffffffffffff;\n     }\n-    if(0xf < id){\n-      lbl:\n-      id = id;\n-      goto lbl;\n-    }\n+    id = id;\n+    if(0xf < id)goto lbl;\n     id = *id & 0xf;\n     switch((type)id){\n       case 0:\n\nSo the Ground Truth is the original code, and the diff is between Candidate A and B. The lines in the diff show that in the original code (Ground Truth), there's a section where Candidate A has a certain code, and Candidate B has another. Wait, no. The diff is between Candidate A and B. The lines with '-' are Candidate A's code, and '+' are Candidate B's code. The original code (Ground Truth) is not part of the diff. Wait, but the user says that the Ground Truth is the Source AST. So perhaps the diff is between the original code (Ground Truth) and the candidates? No, the user says that the diff is between A and B, and the Ground Truth is the Source AST.\n\nThis is confusing. Let me try to rephrase.\n\nThe user wants to compare Candidate A and B against the Ground Truth (Source AST) to see which one matches better. The diff shows the differences between A and B. The Ground Truth is the original code. So, for example, if the original code has a switch statement, and Candidate B has that switch while Candidate A doesn't, then B would be the winner.\n\nBut in the diff provided, the code in question is part of the function. The Ground Truth code has a switch statement inside the while loop. However, the diff is about a different part of the code. The diff shows that in the Ground Truth, there's an if statement with a label and goto. The candidates A and B have different versions of that code.\n\nWait, perhaps the user made a mistake in the input. Alternatively, maybe the diff is between the original code (Ground Truth) and Candidate A, and Candidate B is another version. But the way the diff is presented is as a comparison between A and B. So the original code (Ground Truth) is not part of the diff. Therefore, the user's question is to compare A and B against the Ground Truth, which is the original code.\n\nBut how can we compare A and B against the Ground Truth if the diff is between A and B? Unless the Ground Truth is the original code, and the diff is between A and B, which are both different from the original code. But that's not clear.\n\nAlternatively, perhaps the Ground Truth is the original code, and the diff is between the original code and the candidates. But the way the diff is presented is as a comparison between A and B. This is confusing.\n\nAlternatively, perhaps the Ground Truth is the original code, and the diff is between A and B, where one of them is the original code. But the user hasn't specified that. \n\nGiven the ambiguity, perhaps the key is to look at the criteria. The first criterion is Topology Match: Does the '+' code (Candidate B) restore a node type present in the Source but missing in '-' (Candidate A)?\n\nIn the diff, the code in the Ground Truth (Source AST) has a switch statement. But the diff is about a different part of the code. However, the code in the diff's section (the if statement with label and goto) doesn't involve a switch statement. The switch statement is elsewhere in the Ground Truth code.\n\nWait, the Ground Truth code has a switch statement inside the while loop. The diff is about a different part of the code. Therefore, the question is about whether Candidate B has a switch statement that's present in the Source AST but missing in Candidate A. But in the diff, the code being compared is not the switch statement. Therefore, this might not be applicable.\n\nAlternatively, perhaps the diff is about the switch statement. Let me check the diff again.\n\nThe diff shows that in the code, after the if statement, there's a switch((type)id) with case 0. So the Ground Truth code (Source AST) has this switch statement. Now, the candidates A and B are different versions of this code. But the diff shows that in the original code (Ground Truth), there's a switch statement. However, the diff is between Candidate A and B, which are different versions. So, if the Ground Truth has a switch statement, and Candidate A doesn't have it, but Candidate B does, then B would be the winner.\n\nBut looking at the diff, the code in the Ground Truth (Source AST) has the switch statement. The diff is between Candidate A and B. The lines with '-' are Candidate A's code, and '+' are Candidate B's code. However, the code in the diff is part of the switch statement. Let me look at the diff again.\n\nThe diff starts with:\n\n@@ -17,11 +17,8 @@\n     if(id < id + *(type)(id + (type)(type)id * 8)){\n       return 0xffffffffffffffff;\n     }\n-    if(0xf < id){\n-      lbl:\n-      id = id;\n-      goto lbl;\n-    }\n+    id = id;\n+    if(0xf < id)goto lbl;\n     id = *id & 0xf;\n     switch((type)id){\n       case 0:\n\nSo the original code (Ground Truth) has this switch statement. The candidates A and B have different versions of the code before the switch. The switch statement is present in both A and B, since the diff is about the code before the switch. Therefore, the switch statement is present in both A and B, as it's not part of the diff.\n\nWait, the code after the if statement (the part that's changed) is the switch statement. But the diff shows that the code before the switch is different between A and B. However, the switch statement itself is present in both versions. Therefore, the presence of the switch statement is not the issue here.\n\nThe criteria are:\n\n1. Topology Match: Does the '+' code restore a node type present in the Source but missing in '-'?\n\nIn this case, the Source (Ground Truth) has a switch statement. Both A and B have the switch statement, as it's not part of the diff. So this criterion might not apply here.\n\nThe second criterion is Complexity: Does the '+' code match the nesting depth of the Source?\n\nThe nesting depth here refers to how deeply nested the code is. The original code's structure in this part is: after the if statement, there's an assignment to id and then a switch.\n\nIn Candidate A, the code is:\n\n-    if(0xf < id){\n-      lbl:\n-      id = id;\n-      goto lbl;\n-    }\n\nThis is an if statement with a label and a goto, which creates a loop. The nesting depth here is one level (the if statement).\n\nIn Candidate B, the code is:\n\n+    id = id;\n+    if(0xf < id)goto lbl;\n\nThis is a simple assignment followed by an if statement with a goto. The nesting depth here is also one level (the if statement). However, the structure is different: Candidate A uses a label and goto to create a loop, while Candidate B uses a direct goto without a label. However, the original code (Ground Truth) has a different structure here. Wait, the Ground Truth code in this part is the code that's being compared. But the Ground Truth code is not part of the diff. Wait, I'm getting stuck here.\n\nAlternatively, perhaps the Ground Truth code has a certain structure in this part, and the candidates A and B have different versions. The user wants to know which of A or B matches the Ground Truth's structure.\n\nBut without knowing what the Ground Truth's code is in this part, it's hard to say. However, the user provided the Ground Truth code, which includes this part. Let me check the Ground Truth code again.\n\nThe Ground Truth code provided has, in the while loop:\n\n  while(id < (type)id + id){\n    type id = *id++;\n    type id = (id & 0xF0) >> 4;\n   "
        }
      }
    ],
    "deepseek-r1": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)*(type)(id + 1));\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = (type)call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = (id) * (type)id;\n            *(type)((type)id + 0xd) = *(type)id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (id) * (type)(id + 5));\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (id) * (type)(id + 6));\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (id) * (type)(id + id * 2 + 1), (id) * (type)((type)id + id * 4 + 3), (id) * (type)(id + id * 2 + 2));\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (id) * (type)(id + 1));\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.0625,
          "base_ppl": 2.453125,
          "pr_ppl": 2.421875,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate A maintains higher-level constructs like array access, which are more idiomatic and reflect human-like thinking. Candidate B replaces these with pointer arithmetic, making the code more machine-like and less abstract.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)*(type)(id + 1));\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = (type)call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = (id) * (type)id;\n            *(type)((type)id + 0xd) = *(type)id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (id) * (type)(id + 5));\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (id) * (type)(id + 6));\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (id) * (type)(id + id * 2 + 1), (id) * (type)((type)id + id * 4 + 3), (id) * (type)(id + id * 2 + 2));\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (id) * (type)(id + 1));\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.0625,
          "base_ppl": 2.453125,
          "pr_ppl": 2.421875,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch(*(undefined *)(param_2 + 3)) {\n    case 1:\n      local_28 = (long)(char)param_3;\n      break;\n    case 2:\n    case 7:\n    case 10:\n      local_28 = (long)(short)param_3;\n      break;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x29:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      local_28 = (long)(int)param_3;\n      break;\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",*(undefined *)(param_2 + 3));\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type id){\n  if(!(id->id & id)){\n    switch(id->id){\n      case id:\n        id = call(id, id, id);\n        break;\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        break;\n      case def:\n        if(id->id & id)call(id, str, id->id);\n        return id;\n    }\n  }\n  return id;\n}",
        "base_ast": " id( id, type *id,  id){\n  type id;\n  id = id;\n  if((*id & 8) == 0){\n    switch((type)id[3]){\n      case str:\n        id = (type)(type)id;\n        break;\n      case str:\n      case str:\n      case str:\n        id = (type)(type)id;\n        break;\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n        break;\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n        id = (type)(type)id;\n        break;\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n        break;\n      case def:\n        if((*(type)(id + 0x44) & 0x40) != 0){\n          call(id, str, (type)id[3]);\n        }\n        return -1;\n    }\n  }\n  return id;\n}",
        "pr_ast": " id( id, type *id,  id){\n  type id;\n  id = id;\n  if((*id & 8) == 0){\n    switch(*(type)(id + 3)){\n      case 1:\n        id = (type)(type)id;\n        break;\n      case 2:\n      case 7:\n      case 10:\n        id = (type)(type)id;\n        break;\n      case 3:\n      case 5:\n      case 0xd:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x29:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x3b:\n        break;\n      case 4:\n      case 6:\n      case 8:\n      case 9:\n      case 0xb:\n      case 0xc:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x21:\n      case 0x22:\n      case 0x23:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n        id = (type)(type)id;\n        break;\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n      case 0x24:\n      case 0x25:\n      case 0x26:\n      case 0x2a:\n      case 0x2b:\n      case 0x2c:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n        break;\n      case def:\n        if((*(type)(id + 0x44) & 0x40) != 0){\n          call(id, str, *(type)(id + 3));\n        }\n        return -1;\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.6875,
          "base_ppl": 2.46875,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.015625,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.015625,
          "delta_ppl": -0.453125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Could not detect potential bias in LLM response declaring TIE.",
          "raw_response": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar3 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(local_18 + 1));\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = *(byte *)local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(local_28 + 5));\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(local_28 + 6));\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar3) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)*(byte *)local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              bVar1 = *(byte *)local_28;\n              bVar2 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)bVar1 + (uint)bVar2 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)*(byte *)local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)*(byte *)(local_78 + 1));\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(local_28 + 1));\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)*(byte *)local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 !=\n                       0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)*(byte *)(local_28 + 1) +\n                       (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar3 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = id;\n    call(&id, 0, 4);\n    call(&id, 0, 4);\n    id = (type)0x0;\n    id = bool;\n    id = 0;\n    call(str);\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        call(str, (id) * (type)(*id + 8), *(type)(*id + 0x10) & 0xffffffff, *(type)(*id + 0x20) & 0xffffffff, *(type)(*id + 0x28) & 0xffffffff);\n      }\n      id = call(&id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(&id);\n      if(*(type)id != 0){\n        call(&id);\n      }\n      if(id.id != 0){\n        id = call(id, (type)id.id);\n        if(id == (type)0x0){\n          if(*(type)id != 0){\n            call(*(type)id, str, (type)id.id);\n          }\n          id = 5;\n          break;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != 0){\n            call(*(type)id, str);\n          }\n          id = 3;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      id = id & 0xffff;\n      if(id != 10){\n        if(id == 0x18){\n          if(*(type)id != 0){\n            call(str);\n            for(id = 0;  id < (type)(id >> 0x10); id = id + 1){\n              call(str, (id) * (type)((type)id + (type)id));\n            }\n            call(str);\n          }\n        }elseif(id == 0x22){\n          *(type)((type)id + 0xd) = (id) * id;\n          if(*(type)id != 0){\n            call(str, (id) * (type)((type)id + 0xd));\n          }\n        }else{\n          if(id == 0x2f){\n            id = 6;\n            break;\n          }\n          if(id == 0x31){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n          }elseif(id == 0x3c){\n            if(id){\n              if(((type)id == 0xfc) && (id = call(id, id, id.id)id != 0))break;\n              id = id;\n            }\n          }elseif(id == 0x3d){\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, (id) * id / 0x14, (id) * id % 0x14);\n              call(str, (type)id[1] / 0x14, (type)id[1] % 0x14);\n              call(str, (type)id[2] / 0x14, (type)id[2] % 0x14);\n              call(str, (type)id[3] / 0x14, (type)id[3] % 0x14);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              call(str, (type)id[8]);\n            }\n          }elseif(id == 0x42){\n            *(type)((type)id + 0x12) = call(id) * id + (id) * (type)((type)id + 1) * 0x100;\n            if(*(type)id != 0){\n              call(str, (id) * (type)((type)id + 0x12));\n            }\n          }elseif(id == 0x85){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != 0)break;\n          }elseif(id == 0x92){\n            if(10 < *(type)id){\n              id = id + 1;\n              id = *id;\n              id = *(type)((type)id + 1);\n              for(id = 0;  id < (type)((type)(type)id + (type)id * 0x100); id = id + 1){\n                call(str, call(id + 8), call(id) * id, (id) * (type)((type)id + 1), (type)(type)id[1]);\n                id = id + 2;\n              }\n            }\n          }elseif(id == 0xe0){\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(str, (id) * id);\n                call(str, (type)id[1]);\n                call(str, (type)id[2]);\n                call(str, (type)id[3]);\n                call(str, (type)id[4]);\n                call(str, (type)id[5]);\n                call(str, (type)id[6]);\n                call(str, (type)id[7]);\n              }\n            }\n          }else{\n            if(id == 0xfc){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != 0xff){\n              if(id == 0x231)goto lbl;\n              if(id == 0x293){\n                if(*(type)id != 0){\n                  call(str, call(*id & 0x7ff));\n                  if((*id & 0x8000) == 0){\n                    id = (type)call(id + 1, (type)(type)((id >> 0x10) - 2), 1, id);\n                    call(str, id);\n                    call(id);\n                  }else{\n                    call(str, (type)(type)id[1]);\n                    call(str, (id) * (type)((type)id + 3));\n                  }\n                }\n              }else{\n                if(id == 0x41e){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == 0x809){\n                  *(type)((type)id + 0xc) = call(id) * id + (id) * (type)((type)id + 1) * 0x100 != 0x600;\n                  *(type)((type)id + 0xe) = (type)(type)id[1] + (id) * (type)((type)id + 3) * 0x100;\n                  if(*(type)id != 0){\n                    id = str;\n                    if(*(type)((type)id + 0xc) != str){\n                      id = str;\n                    }\n                    call(str, id);\n                    call(str, (id) * (type)((type)id + 0xe));\n                  }\n                }elseif(*(type)id != 0){\n                  call(str, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id + 0x3c) == str){\n        id = (type)id != 10;\n      }\n    }while(id);\n    if(id != (type)0x0){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = id;\n    call(&id, 0, 4);\n    call(&id, 0, 4);\n    id = (type)0x0;\n    id = bool;\n    id = 0;\n    call(str);\n    do{\n      if(10 < *(type)id){\n        call(str, (type)*(type)(id + 1));\n        call(str, (id) * (type)(*id + 8), *(type)(*id + 0x10) & 0xffffffff, *(type)(*id + 0x20) & 0xffffffff, *(type)(*id + 0x28) & 0xffffffff);\n      }\n      id = call(&id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(&id);\n      if(*(type)id != 0){\n        call(&id);\n      }\n      if(id.id != 0){\n        id = (type)call(id, (type)id.id);\n        if(id == (type)0x0){\n          if(*(type)id != 0){\n            call(*(type)id, str, (type)id.id);\n          }\n          id = 5;\n          break;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != 0){\n            call(*(type)id, str);\n          }\n          id = 3;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      id = id & 0xffff;\n      if(id != 10){\n        if(id == 0x18){\n          if(*(type)id != 0){\n            call(str);\n            for(id = 0;  id < (type)(id >> 0x10); id = id + 1){\n              call(str, (id) * (type)((type)id + (type)id));\n            }\n            call(str);\n          }\n        }elseif(id == 0x22){\n          *(type)((type)id + 0xd) = *(type)id;\n          if(*(type)id != 0){\n            call(str, (id) * (type)((type)id + 0xd));\n          }\n        }else{\n          if(id == 0x2f){\n            id = 6;\n            break;\n          }\n          if(id == 0x31){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (id) * (type)(id + 5));\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (id) * (type)(id + 6));\n              if(id != 0){\n                call(str, id);\n              }\n            }\n          }elseif(id == 0x3c){\n            if(id){\n              if(((type)id == 0xfc) && (id = call(id, id, id.id)id != 0))break;\n              id = id;\n            }\n          }elseif(id == 0x3d){\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, (id) * id / 0x14, (id) * id % 0x14);\n              call(str, (type)id[1] / 0x14, (type)id[1] % 0x14);\n              call(str, (type)id[2] / 0x14, (type)id[2] % 0x14);\n              call(str, (type)id[3] / 0x14, (type)id[3] % 0x14);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              call(str, (type)id[8]);\n            }\n          }elseif(id == 0x42){\n            *(type)((type)id + 0x12) = (id) * (type)id + (id) * (type)((type)id + 1) * 0x100;\n            if(*(type)id != 0){\n              call(str, (id) * (type)((type)id + 0x12));\n            }\n          }elseif(id == 0x85){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != 0)break;\n          }elseif(id == 0x92){\n            if(10 < *(type)id){\n              id = id + 1;\n              id = *(type)id;\n              id = *(type)((type)id + 1);\n              for(id = 0;  id < (type)((type)id + (type)id * 0x100); id = id + 1){\n                call(str, call(id + 8), (id) * (type)id, (id) * (type)((type)id + 1), (id) * (type)(id + 1));\n                id = id + 2;\n              }\n            }\n          }elseif(id == 0xe0){\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(str, (id) * id);\n                call(str, (type)id[1]);\n                call(str, (type)id[2]);\n                call(str, (type)id[3]);\n                call(str, (type)id[4]);\n                call(str, (type)id[5]);\n                call(str, (type)id[6]);\n                call(str, (type)id[7]);\n              }\n            }\n          }else{\n            if(id == 0xfc){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != 0xff){\n              if(id == 0x231)goto lbl;\n              if(id == 0x293){\n                if(*(type)id != 0){\n                  call(str, call(*id & 0x7ff));\n                  if((*id & 0x8000) == 0){\n                    id = (type)call(id + 1, (type)(type)((id >> 0x10) - 2), 1, id);\n                    call(str, id);\n                    call(id);\n                  }else{\n                    call(str, (id) * (type)(id + 1));\n                    call(str, (id) * (type)((type)id + 3));\n                  }\n                }\n              }else{\n                if(id == 0x41e){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == 0x809){\n                  *(type)((type)id + 0xc) = (id) * (type)id + (id) * (type)((type)id + 1) * 0x100 != 0x600;\n                  *(type)((type)id + 0xe) = (id) * (type)(id + 1) + (id) * (type)((type)id + 3) * 0x100;\n                  if(*(type)id != 0){\n                    id = str;\n                    if(*(type)((type)id + 0xc) != str){\n                      id = str;\n                    }\n                    call(str, id);\n                    call(str, (id) * (type)((type)id + 0xe));\n                  }\n                }elseif(*(type)id != 0){\n                  call(str, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id + 0x3c) == str){\n        id = (type)id != 10;\n      }\n    }while(id);\n    if(id != (type)0x0){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.0625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.453125,
          "pr_ast_ppl": 2.4375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = (type)call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = (type)call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.296875,
          "pr_ast_ppl": 2.28125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = (type)call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = (type)call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.296875,
          "pr_ast_ppl": 2.28125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A matches the source code structure more closely as it does not include unnecessary type casting. The source code does not cast the result of bsearch to char*, so adding this cast in Candidate B introduces noise without improving the logic.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = (type)call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.671875,
          "base_ppl": 2.28125,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 2.640625,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A matches the Source Code's structure without unnecessary type casting, whereas B introduces casts that are not present in the Source. This makes A structurally closer to the Source.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A maintains a cleaner structure with less nesting and more straightforward control flow, which better reflects high-level human thinking. Candidate B introduces more complex nesting and redundant assignments, making the code harder to follow and more machine-like.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A maintains the original AST structure without adding extra nodes, ensuring both topology and nesting depth match the Source.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = (type)call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.671875,
          "base_ppl": 2.296875,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.640625,
          "base_ast_ppl": 2.546875,
          "pr_ast_ppl": 2.546875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces an unnecessary cast to `char *` in the `bsearch` calls, which does not match the Source Code's structure. This change adds noise without improving the logic, making it less faithful to the original code.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A is cleaner with less redundant code and artificial nesting, making it more human-like.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[8192];\n  type id;\n  type *id;\n  type id[79];\n  type id[9];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + (type)id;\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)*(type)(id + (type)id * 2);\n    id = (id) * (type)(id + (type)id * 2);\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] + 0x2c];\n      id = &id + (type)(type)id[id];\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id == (type)0x0){\n              call(id, 0x2000, str, id);\n              if(*(type)(id + 0x30) != 0){\n                call(id, *(type)(id + 0x50));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id + -0x28;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id;\n              }\n            }\n            break;\n          case 4:\n            call(id, id, id);\n            id[id] = 0;\n            break;\n          case 5:\n            id = id;\n            break;\n          case 6:\n            id = (type)id - (type)id;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] + 0x2c];\n    id = &id + (type)(type)id[id];\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, 0x28, id);\n        id = id;\n        if(id == (type)0x0){\n          call(id, 0x2000, str, id);\n          if(*(type)(id + 0x30) != 0){\n            call(id, *(type)(id + 0x50));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id + -0x28;\n          }\n          while(bool){\n            id = id + 0x28;\n            id = bool;\n            if(((type)id - (type)id) / 0x28 < (type)id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = 0;\n      }elseif(id == str){\n        id = (type)id - (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, (type)id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[8192];\n  type id;\n  type *id;\n  type id[79];\n  type id[9];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + (type)id;\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)*(type)(id + (type)id * 2);\n    id = (id) * (type)(id + (type)id * 2);\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] + 0x2c];\n      id = &id + (type)(type)id[id];\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = (type)call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id == (type)0x0){\n              call(id, 0x2000, str, id);\n              if(*(type)(id + 0x30) != 0){\n                call(id, *(type)(id + 0x50));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id + -0x28;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id;\n              }\n            }\n            break;\n          case 4:\n            call(id, id, id);\n            id[id] = 0;\n            break;\n          case 5:\n            id = id;\n            break;\n          case 6:\n            id = (type)id - (type)id;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] + 0x2c];\n    id = &id + (type)(type)id[id];\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = (type)call(id, id, (type)id, 0x28, id);\n        id = id;\n        if(id == (type)0x0){\n          call(id, 0x2000, str, id);\n          if(*(type)(id + 0x30) != 0){\n            call(id, *(type)(id + 0x50));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id + -0x28;\n          }\n          while(bool){\n            id = id + 0x28;\n            id = bool;\n            if(((type)id - (type)id) / 0x28 < (type)id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = 0;\n      }elseif(id == str){\n        id = (type)id - (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, (type)id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 1.9921875,
          "pr_ppl": 1.9765625,
          "source_ast_ppl": 2.421875,
          "base_ast_ppl": 2.21875,
          "pr_ast_ppl": 2.203125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A maintains the original structure without unnecessary type casting and clearer variable declarations, aligning better with the Source Code.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate A mirrors the Source AST topology without adding unnecessary type casts, preserving the original structure and nesting depth.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + 0x400;\n  id = id + id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id + (type)(type)(type)id[id] + 1;\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id != (type)0x0){\n              while(bool){\n                id = id + -0x28;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id + 0x28){\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n              }\n            }\n            break;\n          case 4:\n            if(*id != 0){\n              if((-call(*id - 0x30) - 1) / 10 < id){\n                id = id + 1;\n                goto lbl;\n              }\n              id = id * 10 + call(*id - 0x30);\n            }\n            break;\n          case 5:\n            id = 0;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id + (type)(type)(type)id[id] + 1;\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        while(bool){\n          id = id + -0x28;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id + 0x28;\n          id = bool;\n          if(((type)id - (type)id) / 0x28 < (type)id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id + 0x28){\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)id, str, (type)id - (type)id, (type)id - (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + 0x400;\n  id = id + id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id + (type)(type)(type)id[id] + 1;\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = (type)call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id != (type)0x0){\n              while(bool){\n                id = id + -0x28;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id + 0x28){\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n              }\n            }\n            break;\n          case 4:\n            if(*id != 0){\n              if((-call(*id - 0x30) - 1) / 10 < id){\n                id = id + 1;\n                goto lbl;\n              }\n              id = id * 10 + call(*id - 0x30);\n            }\n            break;\n          case 5:\n            id = 0;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id + (type)(type)(type)id[id] + 1;\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        while(bool){\n          id = id + -0x28;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id + 0x28;\n          id = bool;\n          if(((type)id - (type)id) / 0x28 < (type)id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id + 0x28){\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)id, str, (type)id - (type)id, (type)id - (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.671875,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.640625,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate A is cleaner and avoids unnecessary type casting, making it more abstract and human-like. It adheres to semantic structures without adding low-level artifacts.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = id - 1900;\n              }\n              break;\n            }\n          case 16:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 17:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 44)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  44;\n  id != id\n  {\n    type id[1024];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.78125,
          "pr_ast_ppl": 2.796875,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B introduces a logical error by assigning a pointer instead of a char, which breaks the intended functionality. This makes the code less correct and harder to understand, whereas Candidate A maintains the correct logic and data types, aligning better with human engineering practices that prioritize correctness and readability.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the original Source AST structure without unnecessary modifications, ensuring the node types and nesting depth match the Source.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = id - 1900;\n              }\n              break;\n            }\n          case 16:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 17:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 44)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  44;\n  id != id\n  {\n    type id[1024];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 2.328125,
          "base_ast_ppl": 2.78125,
          "pr_ast_ppl": 2.796875,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is cleaner and avoids unnecessary use of the address operator, adhering to idiomatic C practices and improving readability.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A matches the Source Code structure better as it uses direct array access without unnecessary address-of operators, which were not present in the Source. Candidate B introduces noise by adding & operators, deviating from the Source.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "The changes do not improve the idiomatic design as they do not alter the control flow's semantic structure. The original code (A) maintains higher-level constructs without introducing unnecessary pointer operations that make the code more machine-like.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                type id = ((((*(id)))) - str);\n                if(id >= 0 && id <= 9){\n                  id = 10 * id + id;\n                }\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                if(id < 70){\n                  id->id = 100 + id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 47)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  47;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.015625,
          "base_ppl": 2.609375,
          "pr_ppl": 2.609375,
          "source_ast_ppl": 2.390625,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.9375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A directly accesses the arrays without using unnecessary pointer operations, making the code more readable and aligning better with human engineering practices by avoiding artificial constructs.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns more closely with the Source Code structure by avoiding unnecessary parentheses and maintaining the original array access pattern. Candidate B introduces stylistic changes that do not improve the code's fidelity to the Source.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A avoids unnecessary artificial constructs, maintaining clean and logical code structure that reflects human-like thinking without adding redundant layers.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A aligns with the Source AST's structure by maintaining the correct node type (assignment with a single cast) and nesting depth, whereas Candidate B introduces an unnecessary double cast and modifies the indexing method, deviating from the Source.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                type id = ((((*(id)))) - str);\n                if(id >= 0 && id <= 9){\n                  id = 10 * id + id;\n                }\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                if(id < 70){\n                  id->id = 100 + id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 47)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  47;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.015625,
          "base_ppl": 2.609375,
          "pr_ppl": 2.609375,
          "source_ast_ppl": 2.390625,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.9375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate A maintains a cleaner control flow without unnecessary pointer operations, making it more aligned with high-level human thinking.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A directly mirrors the Source's array access without adding unnecessary complexity, better matching the Source AST topology.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = id + 2;\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if((id != (type)0x0) && (id = *idid != -1)){\n    id = id + 2;\n    id = 0;\n    id = 0;\n    id = 8;\n    id = bool;\n    do{\n      id = 1;\n      id = bool;\n      switch(id){\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          id = bool;\n          id = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto lbl;\n        case 0x21:\n          break;\n        case def:\n          id = 1;\n          id = bool;\n          if(1 < id + 0xbfffffffffffffffU){\n            return 8;\n          }\n      }\n      if(!id){\n        return 8;\n      }\n      id = id + id;\n      id = id + 1;\n      id = *id;\n      id = id + 2;\n      id = id;\n    }while(id != -1);\n    if((id == 1 && id < 5) && (id < 4)){\n      *id = id;\n      id = 0;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 2.140625,
          "pr_ppl": 2.15625,
          "source_ast_ppl": 7.09375,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.78125,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate A avoids the use of `goto`, which is a graph artifact, and uses breaks within the switch statement, promoting cleaner semantic structure. This makes the code more readable and follows idiomatic control flow better.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A maintains the original loop structure and conditional checks closer to the Source, without introducing unnecessary complexity like the switch statement which isn't present in the Source. Candidate B adds a switch that complicates the code, moving it away from the Source structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A has a cleaner structure with clear nesting and uses semantic constructs like do-while loops and switch statements effectively. It avoids unnecessary nesting and artificial constructs, making it more human-like and easier to follow.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate B restores the switch cases present in the Source, maintaining the original structure's complexity and nesting depth.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = id + 2;\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if((id != (type)0x0) && (id = *idid != -1)){\n    id = id + 2;\n    id = 0;\n    id = 0;\n    id = 8;\n    id = bool;\n    do{\n      id = 1;\n      id = bool;\n      switch(id){\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          id = bool;\n          id = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto lbl;\n        case 0x21:\n          break;\n        case def:\n          id = 1;\n          id = bool;\n          if(1 < id + 0xbfffffffffffffffU){\n            return 8;\n          }\n      }\n      if(!id){\n        return 8;\n      }\n      id = id + id;\n      id = id + 1;\n      id = *id;\n      id = id + 2;\n      id = id;\n    }while(id != -1);\n    if((id == 1 && id < 5) && (id < 4)){\n      *id = id;\n      id = 0;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 2.140625,
          "pr_ppl": 2.15625,
          "source_ast_ppl": 7.09375,
          "base_ast_ppl": 2.671875,
          "pr_ast_ppl": 2.78125,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Okay, I need to figure out which version, A or B, better mirrors the Source AST topology. Let me start by understanding the problem.\n\nFirst, the Source AST has certain structures. Looking at the code, I see a function with a do-while loop, a switch statement inside it, and some if conditions. The AST would have nodes like SwitchStatement, IfStatement, assignments, etc.\n\nNow, looking at the Diff. Candidate A is the original code, and Candidate B has some changes. The lines with '-' are from A, and '+' are from B.\n\nLet me compare the structures. In the Source, there's a do-while loop with a switch inside. In Candidate A, the code inside the loop has a switch statement with multiple cases. In Candidate B, the switch is modified, and some new cases are added, like case def and more case statements.\n\nLooking at the topology match: The Source has a SwitchStatement. In Candidate A, that's present. In B, they added more cases, including case def, which wasn't there before. But the main structure of the switch is still present, so both have the SwitchStatement.\n\nNow, complexity and nesting depth. The Source's switch is nested within the do-while loop. In Candidate A, the structure seems to match the nesting. In B, they added more lines inside the switch, but does that change the nesting depth? The switch is still inside the do-while, so the nesting depth remains the same.\n\nWait, but in Candidate B, the code inside the switch is more complex. They added more cases and some goto statements. Does that affect the AST topology? The switch node still exists, but the number of children (cases) increased. The Source's switch has several cases, and B adds more, but the structure is still similar.\n\nHowever, in the Source, after the switch, there are if statements and assignments. In B, they added more assignments and a goto lbl. Does that change the nesting? The goto might introduce a different control flow, but the main structure of the loop and switch remains.\n\nLooking at the criteria, the key is whether the + code restores a node type present in the Source. Both A and B have the switch, but B adds more cases. But the Source doesn't have all those cases; they might be optimizations or additional logic. So, does B add nodes that weren't in the Source? It seems like it, but the main switch node is still there.\n\nWait, the Source's switch has cases like 3,4,5,... up to 0xb. In B, they added more cases beyond 0xb, like 0xc to 0x20, and case def. These weren't in the Source. So, does that mean B is adding nodes that weren't in the Source? Or is it just expanding the cases, which is allowed?\n\nThe first criterion is whether the + code restores a node type present in the Source. The switch is present in both, so that's a match. But the additional cases in B might not be in the Source. However, the switch node itself is correctly restored.\n\nThe second criterion is nesting depth. Both versions have the same nesting: switch inside do-while. So, both satisfy the complexity.\n\nBut wait, in the Source, after the switch, there's an if statement and some assignments. In B, after the switch, there are more assignments and a goto. Does that change the nesting? The structure remains a loop with a switch and then some code, so nesting depth is same.\n\nHmm, maybe I need to look at other parts. In Candidate A, the code after the switch has an if statement that returns 8. In B, they added more lines, but the main structure is preserved.\n\nWait, looking at the assignments: in B, after the switch, they have more assignments like id = id + 2, id = 0, etc. These are additional nodes but don't change the overall structure.\n\nSo, both A and B have the necessary nodes, but B adds more. Since the Source doesn't have those extra cases, does that mean B is adding extra nodes that aren't in the Source? Or is it allowed because the switch node is present?\n\nThe first criterion is about restoring a node type present in the Source. The switch is present, so that's good. The additional cases are part of the same switch node, so the topology is maintained.\n\nBut the Source's switch has certain cases, and B adds more. So, the structure is more complex in B, but the main node types are preserved.\n\nWait, but the Source's switch doesn't have case def or the higher hex cases. So, in B, they added more cases, which might not be in the Source. Does that mean B is adding nodes that weren't in the Source, thus not matching the topology?\n\nAlternatively, maybe the Source's switch had those cases, but in the provided code, they are not shown. Wait, looking back at the Source code:\n\nThe Source has:\n\ndo{\n  type id;\n  for(id = 0; id[id].id != id[id].id; ++id)if(id[id].id == id) return id;\n  if(!id) return id;\n  id = id[id].id;\n  id = id[id].id;\n  id = id[id].id;\n} while(id[++id].id != id);\n\nThen, after that, some if conditions.\n\nWait, the Source doesn't have a switch statement. Oh! Wait a minute, I think I made a mistake earlier. The Source code provided doesn't have a switch statement. Let me check again.\n\nLooking at the Source code:\n\nIt's a function with a do-while loop, some if statements, assignments, but no switch statement. So the Source AST doesn't have a SwitchStatement node.\n\nWait, that changes everything. So the Source doesn't have a switch. Therefore, in the Diff, both A and B have a switch, which is not present in the Source. So, according to the first criterion, the + code (B) should restore a node present in the Source. But the Source doesn't have a switch. So, both A and B are adding a switch, which isn't in the Source.\n\nWait, that can't be right. Let me re-examine the Source code.\n\nLooking again:\n\nThe Source code is:\n\ntype id(type *id, type *id){\n  if(id == null || id[0].id == id) return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0; id[id].id != id[id].id; ++id) if(id[id].id == id) return id;\n    if(!id) return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  } while(id[++id].id != id);\n  if(id > id || !id || id > 3) return id;\n  *id = id;\n  return id;\n}\n\nNo switch statement here. So the Source AST doesn't have a SwitchStatement node. Therefore, in the Diff, both A and B have a switch, which is not in the Source. So, according to the first criterion, neither A nor B is restoring a node present in the Source because the Source doesn't have a switch.\n\nWait, but the Diff shows that in Candidate A, the code has a switch. So the Source doesn't have it, but the Diff shows that in A, the switch is present. So, the Source's AST doesn't have a switch, but A does. So, according to the first criterion, the + code (B) should restore a node present in the Source. But the Source doesn't have a switch, so B is adding a switch which isn't in the Source.\n\nWait, but the Diff is between A and B. So, the Source is the original, and the Diff is between two versions (A and B). So, the Source is the original, and the Diff is showing changes from A to B.\n\nWait, no, the problem says: the Diff is between Candidate A and B, and the Source is the Ground Truth. So, the Source is the original, and the Diff shows the changes between two versions (A and B) of the code, comparing against the Source.\n\nSo, the Source doesn't have a switch. So, in the Diff, if Candidate A has a switch, that's a change from the Source. Similarly, Candidate B has a switch as well, which is also a change from the Source.\n\nBut the first criterion is: Does the + code (B) restore a node type present in the Source? Since the Source doesn't have a switch, adding a switch in B would not restore a node present in the Source. So, the switch in B is adding a new node not present in the Source.\n\nWait, but the problem says: \"Does the + code restore a node type (e.g., SwitchStatement) present in the Source but missing in -?\"\n\nSo, if the Source has a SwitchStatement, and in -, it's missing, then + should restore it. But in this case, the Source doesn't have a SwitchStatement. So, the + code (B) is adding a SwitchStatement which wasn't in the Source. Therefore, it doesn't satisfy the first criterion.\n\nBut wait, looking back, maybe I'm misunderstanding. The Source is the Ground Truth, and the Diff is between two versions (A and B). So, the Source is the original, and the Diff shows the changes from A to B. So, the Source is the original code, and the Diff shows the changes in A and B compared to the Source.\n\nWait, no, the problem says: the Diff is between Candidate A and B, and the Source is the Ground Truth. So, the Source is the original AST, and the Diff shows the differences between A and B. So, we need to see which of A or B better mirrors the Source.\n\nWait, perhaps I'm getting confused. Let me clarify:\n\nThe problem is that we have a Source AST (Ground Truth), and two candidates (A and B) which are different versions. The Diff shows the differences between A and B. We need to determine which candidate (A or B) better mirrors the Source AST.\n\nSo, the Source is the original, and A and B are two versions. The Diff shows the changes between A and B. So, the question is, which of A or B is more similar to the Source.\n\nIn this case, the Source doesn't have a switch statement. So, if A has a switch, that's a deviation from the Source. If B doesn't have a switch, that would be better. But looking at the Diff, both A and B have a switch.\n\nWait, looking at the Diff:\n\nIn the Diff, lines starting with '-' are from A, and '+' are from B.\n\nLooking at the code:\n\nIn A (Candidate A), the code has a switch statement inside the do-while loop.\n\nIn B (Candidate B), the code also has a switch statement, but with more cases.\n\nSo, both A and B have a switch, which is not present in the Source. Therefore, neither A nor B matches the Source's AST topology because the Source doesn't have a switch.\n\nBut that can't be right because the problem expects us to choose between A and B. So perhaps I'm misunderstanding the Source.\n\nWait, looking again at the Source code:\n\nThe Source code is:\n\ntype id(type *id, type *id){\n  if(id == null || id[0].id == id) return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0; id[id].id != id[id].id; ++id) if(id[id].id == id) return id;\n    if(!id) return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  } while(id[++id].id != id);\n  if(id > id || !id || id > 3) return id;\n  *id = id;\n  return id;\n}\n\nNo switch statement here. So, the Source AST doesn't have a SwitchStatement node.\n\nIn the Diff, both A and B have a switch. So, both are adding a switch which is not in the Source. Therefore, neither A nor B matches the Source's topology.\n\nBut that can't be the case because the problem expects us to choose between A and B. So perhaps I'm missing something.\n\nWait, maybe the Source does have a switch, but it's not visible in the provided code. Or perhaps I'm misreading the code.\n\nLooking again, the Source code doesn't have a switch. So, the Source's AST doesn't have a SwitchStatement. Therefore, any version (A or B) that includes a switch is deviating from the Source.\n\nBut the problem is to choose between A and B, which one better mirrors the Source. So, perhaps the Source didn't have a switch, but one of A or B removed it, thus restoring the Source's structure.\n\nWait, no. The Diff is between A and B. So, the Source is the original, and the Diff shows the changes between A and B. So, if the Source didn't have a switch, and A has a switch, and B doesn't, then B would be better.\n\nBut looking at the Diff, both A and B have a switch. So, both have added a switch compared to the Source. Therefore, neither is better.\n\nBut that can't be the case. So perhaps I'm misunderstanding the problem.\n\nWait, perhaps the Source does have a switch, but it's not visible in the provided code. Let me check again.\n\nNo, the Source code provided doesn't have a switch. So, the Source's AST doesn't have a SwitchStatement.\n\nTherefore, in the Diff, if A has a switch, it's adding a node not present in the Source. If B has a switch, same thing. So, neither A nor B matches the Source's topology.\n\nBut the problem says to choose between A and B. So, perhaps I'm missing something else.\n\nWait, looking at the code in the Diff, in Candidate A, the switch is present, but in Candidate B, the switch is modified. So, perhaps the Source didn't have a switch, but A added it, and B modified it further.\n\nBut the problem is to determine which version mirrors the Source. Since the Source doesn't have a switch, the version that doesn't have a switch would be better. But both A and B have a switch.\n\nWait, perhaps I'm misreading the Diff. Let me look at the lines.\n\nIn the Diff, the code for A and B is shown. The lines with '-' are from A, and '+' are from B.\n\nLooking at the code:\n\nIn A, the code has a switch inside the do-while loop.\n\nIn B, the switch is modified, with more cases and some goto statements.\n\nSo, both A and B have a switch, which is not in the Source. Therefore, neither is better.\n\nBut the problem expects us to choose between A and B. So, perhaps the Source's AST does have a switch, but it's not visible in the provided code. Or perhaps I'm misunderstanding the problem.\n\nAlternatively, maybe the Source's AST has a switch, and the Diff shows that A removed it, while B added it back. So, B would be better because it restores the switch.\n\nBut in the provided Source code, there's no switch. So, I'm confused.\n\nWait, perhaps the Source code is in the Ground Truth, and the Diff is between two versions (A and B) of the code, and we need to see which version matches the Source.\n\nSo, the Source is the original, and the Diff shows the changes between A and B. So, the Source doesn't have a switch, but A and B do. So, the version that is closer to the Source would be the one without the switch. But both A and B have the switch.\n\nWait, perhaps the Source does have a switch, but it's not in the provided code. Or perhaps the provided code is incomplete.\n\nAlternatively, perhaps I'm overcomplicating. Let me try to approach it differently.\n\nThe problem is to determine which version (A or B) mirrors the Source AST topology better.\n\nThe Source AST doesn't have a SwitchStatement. So, any version that doesn't have a switch would be better. But both A and B have a switch.\n\nTherefore, neither A nor B matches the Source. But since the problem expects us to choose between them, perhaps the answer is that neither does, but since we have to choose, perhaps B is worse because it adds more cases, making it more complex and diverging further.\n\nAlternatively, perhaps the Source does have a switch, and the provided code is incomplete. But I don't think so.\n\nWait, perhaps the Source code is the original, and the Diff is between two versions (A and B) of the code. So, the Source is the original, and the Diff shows the changes between A and B. So, the Source doesn't have a switch, but A and B do. Therefore, the version that is closer to the Source would be the one that doesn't have the switch. But both have it.\n\nAlternatively, perhaps the Source does have a switch, and the Diff is showing that A removed it, while B added it back. So, B would be better.\n\nBut in the provided Source code, there's no switch. So, I'm stuck.\n\nWait, perhaps the Source code is the original, and the Diff is showing the changes from the Source to A and B. So, the Source is the original, and the Diff is between A and B. So, the Source doesn't have a switch, but A and B do. Therefore, the version that is closer to the Source would be the one that doesn't have the switch. But both have it.\n\nAlternatively, perhaps the Source does have a switch, but it's not in the provided code. Or perhaps I'm misunderstanding the problem.\n\nGiven the confusion, perhaps I should proceed with the assumption that the Source doesn't have a switch, and both A and B have a switch, which is a deviation. Therefore, neither is perfect, but perhaps B is worse because it adds more complexity.\n\nBut the problem says to choose between A and B. So, perhaps the answer is that B is worse because it adds more nodes not present in the Source, thus not matching the topology.\n\nAlternatively, perhaps the Source does have a switch, and the Diff shows that A removed it, while B added it back. So, B would be better.\n\nBut without the Source having a switch, I'm not sure.\n\nWait, perhaps I should look at the structure of the code in the Diff.\n\nIn the Source, after the do-while loop, there are some if statements and assignments. In Candidate A, the code inside the loop has a switch. In Candidate B, the switch is more complex.\n\nBut the Source doesn't have a switch, so adding a switch is a deviation.\n\nTherefore, the version that doesn't have the switch would be better. But both A and B have it.\n\nWait, perhaps the Source does have a switch, but it's not in the provided code. Or perhaps the provided code is incomplete.\n\nAlternatively, perhaps the Source's AST does have a switch, and the Diff shows that A and B are two versions,"
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013e6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013e6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id)++] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = 0;\n        id->id = (id->id == 0 ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = 0;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (--id->id == 0 ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(4) - call(id->id.id, id->id.id)) & 3;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > 0){\n        --id->id;\n        if(id[(*id)++] != 0x00)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != 0)return id;\n      id->id = call(id + id, *id - id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id >> (id->id * 8)) & 0xFF) != id[(*id)++]){\n          idreturn id;\n        }\n      }while(++id->id < 4);\n      return id;\n    case def:\n      call(0);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id - id;\n    if(id > 0)id->id = call(id + id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return 10;\n  }\n  id = (type)(id + 0x4c);\n  id = (type)(id + 0x46);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case 0:\n        *id = id + 1;\n        id = 1;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        break;\n      case 1:\n        id = call(id, id, id, id, id);\n        if(id != 1){\n          lbl:\n          id = *id - id;\n          if(id == 0){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id + 0x46) != *(type)(id + 6)){\n          return 9;\n        }\n        *id = 0;\n        id = call(*(type)(id + 0x46) == 0) * 2 + 2;\n        break;\n      case 2:\n      case 3:\n        id = id + 0x48;\n        if(id != 2){\n          id = id + 0x4a;\n        }\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        id[0x4c] = 0;\n        id[0x4d] = 0;\n        if(*id == 2){\n          id = 3;\n          if(*(type)(id + 0x48) + 0x8000000000000003U < 0x8000000000000008){\n            return 9;\n          }\n        }else{\n          call(id + 0x24, *(type)(id + 0x48), *(type)(id + 0x4a));\n          if(*(type)(id + 2) < *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) < *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) < *(type)(id + 0x2a)){\n            return 9;\n          }\n          *id = *id + -1;\n          id = call(*id == 0) * 2 + 2;\n        }\n        break;\n      case 4:\n        id = call(*(type)(id + 0x28), *(type)(id + 0x2a));\n        id = call(-id & 3);\n        *(type)(id + 0x4c) = id;\n        *id = 5;\n        goto lbl;\n      case 5:\n        id = *id;\n        lbl:\n        if(id == 0){\n          if(*(type)(id + 2) != *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) != *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) != *(type)(id + 0x2a)){\n            return 9;\n          }\n          call(id + 10, 10);\n          call(id + 0x2c, 10);\n          id = call(10);\n          id = call(id + 10, id + 0x2c, (type)id);\n          if(id != 0){\n            return 9;\n          }\n          id = call(id + id, *id - id, id[0x4e]);\n          id[0x4e] = id;\n          *id = 6;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return 0;\n            }\n            id = id[0x4c];\n            id = id[0x4e];\n            *id = id + 1;\n            if(*(type)(id + id) != (type)(id >> (call(id << 3) & 0x1f)))break;\n            id = *id;\n            *id = id + 1;\n            if(3 < id + 1){\n              return 1;\n            }\n          }\n          return 9;\n        }\n        *id = id - 1;\n        id = *id;\n        *id = id + 1;\n        id = 5;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        goto lbl;\n      case 6:\n        goto lbl;\n      case def:\n        return 0xb;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = 0;\n  id = *id - id;\n  if(id == 0){\n    return 0;\n  }\n  lbl:\n  id = call(id + id, id, id[0x4e]);\n  id[0x4e] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return 10;\n  }\n  id = (type)(id + 0x4c);\n  id = (type)(id + 0x46);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case 0:\n        *id = id + 1;\n        id = 1;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        break;\n      case 1:\n        id = call(id, id, id, id, id);\n        if(id != 1){\n          lbl:\n          id = *id - id;\n          if(id == 0){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id + 0x46) != *(type)(id + 6)){\n          return 9;\n        }\n        *id = 0;\n        id = call(*(type)(id + 0x46) == 0) * 2 + 2;\n        break;\n      case 2:\n      case 3:\n        id = id + 0x48;\n        if(id != 2){\n          id = id + 0x4a;\n        }\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        id[0x4c] = 0;\n        id[0x4d] = 0;\n        if(*id == 2){\n          id = 3;\n          if(*(type)(id + 0x48) + 0x8000000000000003U < 0x8000000000000008){\n            return 9;\n          }\n        }else{\n          call(id + 0x24, *(type)(id + 0x48), *(type)(id + 0x4a));\n          if(*(type)(id + 2) < *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) < *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) < *(type)(id + 0x2a)){\n            return 9;\n          }\n          *id = *id + -1;\n          id = call(*id == 0) * 2 + 2;\n        }\n        break;\n      case 4:\n        id = call(*(type)(id + 0x28), *(type)(id + 0x2a));\n        id = call(-id & 3);\n        *(type)(id + 0x4c) = id;\n        *id = 5;\n        if(id == 0)goto lbl;\n        lbl:\n        *id = id - 1;\n        id = *id;\n        *id = id + 1;\n        id = 5;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        goto lbl;\n      case 5:\n        id = *id;\n        if(id != 0)goto lbl;\n        lbl:\n        if(*(type)(id + 2) != *(type)(id + 0x24)){\n          return 9;\n        }\n        if(*(type)(id + 4) != *(type)(id + 0x26)){\n          return 9;\n        }\n        if(*(type)(id + 8) != *(type)(id + 0x2a)){\n          return 9;\n        }\n        call(id + 10, 10);\n        call(id + 0x2c, 10);\n        id = call(10);\n        id = call(id + 10, id + 0x2c, (type)id);\n        if(id != 0){\n          return 9;\n        }\n        id = call(id + id, *id - id, id[0x4e]);\n        id[0x4e] = id;\n        *id = 6;\n      case 6:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return 0;\n          }\n          id = id[0x4c];\n          id = id[0x4e];\n          *id = id + 1;\n          if(*(type)(id + id) != (type)(id >> (call(id << 3) & 0x1f)))break;\n          id = *id;\n          *id = id + 1;\n          if(3 < id + 1){\n            return 1;\n          }\n        }\n        return 9;\n      case def:\n        return 0xb;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = 0;\n  id = *id - id;\n  if(id == 0){\n    return 0;\n  }\n  lbl:\n  id = call(id + id, id, id[0x4e]);\n  id[0x4e] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.359375,
          "base_ppl": 2.359375,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 2.796875,
          "pr_ast_ppl": 2.796875,
          "delta_ppl": -0.078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B reorganizes the switch structure with clearer labels and less goto usage, aligning more closely with the Source's control flow. It reduces complexity and improves readability without introducing new logic errors.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013d6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013d6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id)++] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = 0;\n        id->id = (id->id == 0 ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = 0;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (--id->id == 0 ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(4) - call(id->id.id, id->id.id)) & 3;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > 0){\n        --id->id;\n        if(id[(*id)++] != 0x00)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != 0)return id;\n      id->id = call(id + id, *id - id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id >> (id->id * 8)) & 0xFF) != id[(*id)++]){\n          idreturn id;\n        }\n      }while(++id->id < 4);\n      return id;\n    case def:\n      call(0);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id - id;\n    if(id > 0)id->id = call(id + id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return 10;\n  }\n  id = (type)(id + 0x4c);\n  id = (type)(id + 0x46);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case 0:\n        *id = id + 1;\n        id = 1;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        break;\n      case 1:\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        if(*(type)(id + 0x46) != *(type)(id + 6)){\n          return 9;\n        }\n        *id = 0;\n        id = call(*(type)(id + 0x46) == 0) * 2 + 2;\n        break;\n      case 2:\n      case 3:\n        id = id + 0x48;\n        if(id != 2){\n          id = id + 0x4a;\n        }\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        id[0x4c] = 0;\n        id[0x4d] = 0;\n        if(*id == 2){\n          id = 3;\n          if(*(type)(id + 0x48) + 0x8000000000000003U < 0x8000000000000008){\n            return 9;\n          }\n        }else{\n          call(id + 0x24, *(type)(id + 0x48), *(type)(id + 0x4a));\n          if(*(type)(id + 2) < *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) < *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) < *(type)(id + 0x2a)){\n            return 9;\n          }\n          *id = *id + -1;\n          id = call(*id == 0) * 2 + 2;\n        }\n        break;\n      case 4:\n        id = call(*(type)(id + 0x28), *(type)(id + 0x2a));\n        id = call(-id & 3);\n        *(type)(id + 0x4c) = id;\n        *id = 5;\n        goto lbl;\n      case 5:\n        id = *id;\n        lbl:\n        if(id == 0){\n          if(*(type)(id + 2) != *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) != *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) != *(type)(id + 0x2a)){\n            return 9;\n          }\n          call(id + 10, 10);\n          call(id + 0x2c, 10);\n          id = call(10);\n          id = call(id + 10, id + 0x2c, (type)id);\n          if(id != 0){\n            return 9;\n          }\n          id = call(id + id, *id - id, id[0x4e]);\n          id[0x4e] = id;\n          *id = 6;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return 0;\n            }\n            id = id[0x4c];\n            id = id[0x4e];\n            *id = id + 1;\n            if(*(type)(id + id) != (type)(id >> (call(id << 3) & 0x1f)))break;\n            id = *id;\n            *id = id + 1;\n            if(3 < id + 1){\n              return 1;\n            }\n          }\n          return 9;\n        }\n        *id = id - 1;\n        id = *id;\n        *id = id + 1;\n        id = 5;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        goto lbl;\n      case 6:\n        goto lbl;\n      case def:\n        return 0xb;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = 0;\n  lbl:\n  if(*id - id == 0){\n    return id;\n  }\n  id = call(id + id, *id - id, id[0x4e]);\n  id[0x4e] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return 10;\n  }\n  id = (type)(id + 0x4c);\n  id = (type)(id + 0x46);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case 0:\n        *id = id + 1;\n        id = 1;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        break;\n      case 1:\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        if(*(type)(id + 0x46) != *(type)(id + 6)){\n          return 9;\n        }\n        *id = 0;\n        id = call(*(type)(id + 0x46) == 0) * 2 + 2;\n        break;\n      case 2:\n      case 3:\n        id = id + 0x48;\n        if(id != 2){\n          id = id + 0x4a;\n        }\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        id[0x4c] = 0;\n        id[0x4d] = 0;\n        if(*id == 2){\n          id = 3;\n          if(*(type)(id + 0x48) + 0x8000000000000003U < 0x8000000000000008){\n            return 9;\n          }\n        }else{\n          call(id + 0x24, *(type)(id + 0x48), *(type)(id + 0x4a));\n          if(*(type)(id + 2) < *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) < *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) < *(type)(id + 0x2a)){\n            return 9;\n          }\n          *id = *id + -1;\n          id = call(*id == 0) * 2 + 2;\n        }\n        break;\n      case 4:\n        id = call(*(type)(id + 0x28), *(type)(id + 0x2a));\n        id = call(-id & 3);\n        *(type)(id + 0x4c) = id;\n        *id = 5;\n        if(id == 0)goto lbl;\n        lbl:\n        *id = id - 1;\n        id = *id;\n        *id = id + 1;\n        id = 5;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        goto lbl;\n      case 5:\n        id = *id;\n        if(id != 0)goto lbl;\n        lbl:\n        if(*(type)(id + 2) != *(type)(id + 0x24)){\n          return 9;\n        }\n        if(*(type)(id + 4) != *(type)(id + 0x26)){\n          return 9;\n        }\n        if(*(type)(id + 8) != *(type)(id + 0x2a)){\n          return 9;\n        }\n        call(id + 10, 10);\n        call(id + 0x2c, 10);\n        id = call(10);\n        id = call(id + 10, id + 0x2c, (type)id);\n        if(id != 0){\n          return 9;\n        }\n        id = call(id + id, *id - id, id[0x4e]);\n        id[0x4e] = id;\n        *id = 6;\n      case 6:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return 0;\n          }\n          id = id[0x4c];\n          id = id[0x4e];\n          *id = id + 1;\n          if(*(type)(id + id) != (type)(id >> (call(id << 3) & 0x1f)))break;\n          id = *id;\n          *id = id + 1;\n          if(3 < id + 1){\n            return 1;\n          }\n        }\n        return 9;\n      case def:\n        return 0xb;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = 0;\n  lbl:\n  if(*id - id == 0){\n    return id;\n  }\n  id = call(id + id, *id - id, id[0x4e]);\n  id[0x4e] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.359375,
          "base_ppl": 2.40625,
          "pr_ppl": 2.296875,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 2.828125,
          "pr_ast_ppl": 2.828125,
          "delta_ppl": -0.109375
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B restructures the switch cases more closely to the Source, using direct case handling without excessive goto statements, thus better matching the Source's control flow.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = (((*(id)))) - str;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 12)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  12;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.734375,
          "pr_ppl": 2.765625,
          "source_ast_ppl": 3.03125,
          "base_ast_ppl": 3.65625,
          "pr_ast_ppl": 3.6875,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A maintains the same pointer type as the Source Code, ensuring structural fidelity. Candidate B introduces a different pointer type, which, while functionally similar, is less faithful to the Source's structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate A uses a cleaner, higher-level construct for array access, which is more idiomatic. Candidate B introduces an unnecessary pointer dereference, making it less clean and more machine-like.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A preserves the node type and structure from the source, while Candidate B introduces a different structure that doesn't match the source's AST.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = (((*(id)))) - str;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 12)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  12;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 2.765625,
          "base_ppl": 2.734375,
          "pr_ppl": 2.765625,
          "source_ast_ppl": 3.03125,
          "base_ast_ppl": 3.65625,
          "pr_ast_ppl": 3.6875,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more readable as it directly accesses the array without unnecessary pointer operations, adhering to clean and straightforward code structure.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate A avoids unnecessary complexity by not adding an artificial `&` operator, making the code cleaner and more straightforward. It adheres to the principle of writing code that is more human-like and less machine-like by being concise and clear.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "motivation": "Candidate A matches the Source AST's node structure without adding unnecessary address operators, thus preserving the original topology.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < 0){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(0 < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.28125,
          "base_ppl": 3.03125,
          "pr_ppl": 3.015625,
          "source_ast_ppl": 4.59375,
          "base_ast_ppl": 3.59375,
          "pr_ast_ppl": 3.578125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B simplifies the condition to 0 < (int)uVar1, which is clearer and more direct, improving readability and following better human engineering practices by avoiding unnecessary complexity.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate B's condition is more readable and aligns with typical coding practices, making it more idiomatic.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "Error",
          "motivation": "Okay, so I'm trying to figure out which version, A or B, in the given diff better mirrors the Source AST topology. Let me start by understanding the problem.\n\nThe task is to compare two candidates, A and B, based on two criteria: topology match and complexity. The Source AST is provided, and the diff shows the changes between Candidate A and B.\n\nFirst, I need to look at the diff. The lines starting with '-' are Candidate A, and '+' are Candidate B. The specific lines in question are around line 41.\n\nLooking at the diff:\n\nCandidate A has:\n-      if((type)-id < 0){\n+      if(0 < (type)id){\n\nSo, the change is in the condition of the if statement. In A, the condition is checking if (type)-id is less than 0. In B, it's checking if 0 is less than (type)id.\n\nNow, I need to check the Source AST to see what the original code does. The Source has a section where it's handling some type of id and conditions. Specifically, in the loop, there's a part where it does:\n\ntype id = id->id & id;\n...\nif((id->id & id) == 0) return 0;\n\nThen, in the for loop, there's a part where it does:\n\nif(id < call(id, call(id[id].id))) continue;\n\nBut more importantly, in the loop body, there's a part where it does:\n\nif(id < call(id, call(id[id].id))) continue;\n\nAnd later, in the if statements, there's a condition:\n\nif(id < call(id, call(id[id].id))) continue;\n\nWait, but looking back, the specific part in the diff is in the for loop's body. The Source has:\n\nfor(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    ...\n}\n\nSo, the condition in the for loop is id < id, which seems a bit odd, but that's the Source.\n\nNow, looking at the diff, the change is in the if condition inside the loop. In Candidate A, the condition is (type)-id < 0, and in B, it's 0 < (type)id.\n\nI need to see which condition aligns better with the Source's structure.\n\nIn the Source, after the for loop, there's a part where it does:\n\nif(id < call(id, call(id[id].id))) continue;\n\nSo, the condition is based on id being less than a function call. But in the diff, the condition is about the type of id.\n\nWait, the diff is in a part where it's checking some condition after assigning id = *id and id = -id.\n\nSo, in the Source, after id = -id, there's a check:\n\nif((id->id & id) != 0) goto lbl;\n\nBut in the diff, the code is:\n\ndo{\n  id = *id;\n  id = -id;\n  if((type)-id < 0){\n    id = id;\n  }\n  if(id <= id){\n    ...\n  }\n}\n\nSo, the condition in the diff is checking whether (type)-id is less than 0. But in the Source, after id = -id, there's a check if (id->id & id) != 0, which is different.\n\nWait, maybe I'm getting confused. Let me look again.\n\nThe Source has:\n\ntype id = id->id & id;\n...\nif((id->id & id) == 0) return 0;\n\nThen, in the for loop:\n\nfor(id = 0; id < id; id++){\n  type id;\n  if(id < call(id, call(id[id].id))) continue;\n  ...\n}\n\nBut the diff is in a part that's not directly in the for loop. It's in a do-while loop inside the for loop's body.\n\nWait, looking at the diff, the code is:\n\ndo{\n  id = *id;\n  id = -id;\n-      if((type)-id < 0){\n+      if(0 < (type)id){\n        id = id;\n      }\n  if(id <= id){\n    ...\n  }\n}\n\nSo, the condition is whether (type)-id is less than 0 in A, and 0 < (type)id in B.\n\nIn the Source, after id = -id, the next step is to check if (id->id & id) != 0, which would be a bitwise operation, not a comparison. So, the condition in the diff is a comparison, not a bitwise check.\n\nWait, but the Source has:\n\nif((id->id & id) != 0) goto lbl;\n\nWhich is a bitwise AND, not a comparison. So, the condition in the diff is a comparison, which doesn't directly match the Source's bitwise check.\n\nBut in the diff, the condition is about the type of id. So, in A, it's checking if (type)-id is less than 0, which would be checking if the value is negative. In B, it's checking if 0 is less than (type)id, which is the same as id > 0.\n\nNow, looking back at the Source, after id = -id, the next step is to check if (id->id & id) != 0. That's a bitwise operation, not a comparison. So, the condition in the diff is a comparison, which doesn't directly align with the Source's bitwise check.\n\nBut perhaps the Source's condition is being translated into a comparison in the diff. Let me think about the original code.\n\nIn the Source, after id = -id, the code does:\n\nif((id->id & id) != 0) goto lbl;\n\nBut in the diff, the code is:\n\nid = -id;\nif(condition) id = id;\n\nSo, perhaps the condition is meant to check if the value is negative, which would be equivalent to (type)-id < 0.\n\nIn Candidate A, the condition is (type)-id < 0, which would correctly check if the value is negative. In Candidate B, it's 0 < (type)id, which checks if id is positive.\n\nBut in the Source, the condition is a bitwise check, not a comparison. So, neither A nor B directly matches the Source's condition. However, the Source's condition is a bitwise check, while the diff is a comparison.\n\nWait, but perhaps the code in the diff is a different part. Let me see.\n\nWait, the Source has a part where it does:\n\ntype id = id->id & id;\n\nWhich is a bitwise AND. Then, in the for loop, it has:\n\nif(id < call(id, call(id[id].id))) continue;\n\nWhich is a comparison. So, in that part, it's a comparison, not a bitwise operation.\n\nBut in the diff, the condition is after id = -id, which is part of a do-while loop inside the for loop's body.\n\nSo, the Source has:\n\ndo{\n  id = *id;\n  id = -id;\n  if((id->id & id) != 0) goto lbl;\n  ...\n} while(id != 0);\n\nWait, no, in the Source, after id = -id, the condition is (id->id & id) != 0, which is a bitwise check, not a comparison.\n\nBut in the diff, the condition is a comparison. So, perhaps the correct condition should be the bitwise check, but in the diff, it's a comparison.\n\nWait, but the diff shows that in Candidate A, the condition is (type)-id < 0, which is a comparison, and in B, it's 0 < (type)id, which is also a comparison.\n\nBut the Source has a bitwise check, not a comparison. So, neither A nor B matches the Source's condition.\n\nWait, but perhaps the code in the diff is in a different part. Let me check the line numbers.\n\nThe diff is at line 41, and the Source has:\n\nif((id->id & id) == 0) return 0;\n\nWhich is a bitwise check. But the diff is in a different part, perhaps in the for loop's body.\n\nWait, perhaps I'm getting confused. Let me try to map the code.\n\nIn the Source, after the for loop starts, it does:\n\ntype id;\nif(id < call(id, call(id[id].id))) continue;\n\nWhich is a comparison. So, in that part, it's a comparison.\n\nBut in the diff, the code is inside a do-while loop inside the for loop's body. So, the condition in the diff is a separate condition.\n\nSo, in the Source, after id = -id, the next condition is a bitwise check, but in the diff, it's a comparison.\n\nSo, the Source has a bitwise check, but the diff is using a comparison. So, neither A nor B matches the Source's condition.\n\nBut wait, the Source's condition is (id->id & id) != 0, which is a bitwise operation. The diff's condition is a comparison, so neither matches.\n\nBut perhaps the code in the diff is trying to replicate the Source's condition in a different way.\n\nWait, in the Source, after id = -id, the condition is (id->id & id) != 0. So, if that's true, it goes to lbl.\n\nIn the diff, the code is:\n\nid = *id;\nid = -id;\nif(condition) id = id;\n\nSo, the condition is checking something about id.\n\nIn Candidate A, the condition is (type)-id < 0, which would be true if -id is negative, i.e., if id was positive. So, if id was positive, -id is negative, so (type)-id < 0 would be true.\n\nIn Candidate B, the condition is 0 < (type)id, which is true if id is positive.\n\nSo, both conditions are checking if id is positive, but in different ways.\n\nBut in the Source, the condition is a bitwise check, not a comparison. So, perhaps the correct condition should be the bitwise check, but the diff doesn't show that.\n\nWait, but the diff is only showing a part of the code. Maybe the rest of the code in the diff is trying to replicate the Source's structure.\n\nAlternatively, perhaps the condition in the diff is meant to handle the case where id is negative, which would correspond to the Source's condition.\n\nBut I'm getting a bit stuck. Let me think about the criteria.\n\nThe first criterion is topology match: does the '+' code restore a node type present in the Source but missing in '-'.\n\nIn this case, both A and B are changing the condition. So, the node type is the same (if statement), but the condition is different.\n\nThe second criterion is complexity: does the '+' code match the nesting depth of the Source.\n\nIn this case, both A and B have the same nesting depth, as the change is only in the condition.\n\nBut the key is to see which condition better mirrors the Source's structure.\n\nThe Source has a bitwise check after id = -id. So, the condition in the diff should be a bitwise check, but it's a comparison.\n\nWait, but in the Source, the condition is (id->id & id) != 0, which is a bitwise AND. So, the condition is checking if any bit is set.\n\nIn the diff, the condition is a comparison, which is different.\n\nBut perhaps the code in the diff is a simplified version. Alternatively, maybe the Source's condition is being transformed into a comparison in the diff.\n\nAlternatively, perhaps the condition in the Source is being replaced by a comparison in the diff, which is a different approach.\n\nBut the question is which version, A or B, better mirrors the Source's AST.\n\nIn the Source, the condition is a bitwise check, but in the diff, it's a comparison. So, neither A nor B matches exactly.\n\nBut looking at the options, A uses (type)-id < 0, which is equivalent to checking if id is positive (since -id < 0 implies id > 0). B uses 0 < (type)id, which is the same as id > 0.\n\nSo, both conditions are checking if id is positive, but in different ways.\n\nBut the Source's condition is a bitwise check, which is different. So, neither A nor B matches the Source's condition.\n\nBut perhaps the code in the diff is a different part. Let me check the line numbers again.\n\nThe diff is at line 41, which in the Source corresponds to:\n\nif((id->id & id) == 0) return 0;\n\nWhich is a bitwise check. So, the diff is modifying a part that's after that.\n\nWait, perhaps the code in the diff is part of the for loop's body, where the condition is a comparison, not a bitwise check.\n\nSo, in the Source, the for loop has:\n\nif(id < call(id, call(id[id].id))) continue;\n\nWhich is a comparison.\n\nSo, the code in the diff is modifying a part inside the for loop's body, which in the Source is a comparison.\n\nSo, in the Source, the condition is a comparison, and in the diff, the condition is also a comparison.\n\nSo, the condition in the diff is part of the for loop's body, which is a comparison.\n\nSo, the condition in the diff is a comparison, which matches the Source's structure in that part.\n\nNow, the question is which condition, A or B, better mirrors the Source's structure.\n\nIn the Source, the condition is id < call(...), which is a comparison.\n\nIn the diff, the condition is after id = -id, which is part of a do-while loop.\n\nSo, the condition in the diff is checking whether (type)-id < 0 in A, or 0 < (type)id in B.\n\nBut in the Source, the condition is id < call(...), which is a comparison based on the value of id.\n\nSo, in the diff, the condition is checking whether id is positive or negative.\n\nBut in the Source, the condition is based on a function call.\n\nWait, perhaps the code in the diff is a different part. Let me think again.\n\nThe Source has:\n\nfor(id = 0; id < id; id++){\n  type id;\n  if(id < call(id, call(id[id].id))) continue;\n  ...\n}\n\nSo, the condition is id < call(...), which is a comparison.\n\nIn the diff, the code is inside the for loop's body, in a do-while loop.\n\nSo, the condition in the diff is a separate check, not part of the for loop's condition.\n\nSo, the condition in the diff is a separate if statement, checking whether (type)-id < 0 or 0 < (type)id.\n\nBut in the Source, after the for loop's condition, there's an if statement that does a comparison.\n\nSo, the condition in the diff is a comparison, which matches the Source's structure.\n\nNow, the question is which condition, A or B, better mirrors the Source's structure.\n\nIn the Source, the condition is id < call(...), which is a comparison based on the value of id.\n\nIn the diff, the condition is checking whether (type)-id < 0 (A) or 0 < (type)id (B).\n\nBoth are comparisons, but the logic is different.\n\nBut the Source's condition is id < call(...), which is a comparison based on the result of a function call.\n\nIn the diff, the condition is based on the value of id after being negated.\n\nSo, perhaps the condition in the diff is meant to handle a similar logic.\n\nBut I'm not sure. Let me think about the nesting depth.\n\nThe second criterion is complexity: does the '+' code match the nesting depth of the Source.\n\nIn the Source, the condition is at the same nesting level as the for loop's body.\n\nIn the diff, the condition is inside the do-while loop, which is inside the for loop's body.\n\nSo, the nesting depth is similar.\n\nBut the key is the topology match.\n\nThe Source has a condition that is a comparison, and the diff also has a comparison.\n\nBut the exact condition in the Source is id < call(...), which is a function call-based comparison.\n\nIn the diff, the condition is based on the value of id after being negated.\n\nSo, perhaps neither A nor B perfectly matches, but we have to choose between them.\n\nAlternatively, perhaps the condition in the Source is being simplified or transformed in the diff.\n\nWait, in the Source, after the for loop's condition, the code does:\n\nif(id < call(id, call(id[id].id))) continue;\n\nWhich is a comparison.\n\nIn the diff, the code is:\n\ndo{\n  id = *id;\n  id = -id;\n  if((type)-id < 0){\n    id = id;\n  }\n  if(id <= id){\n    ...\n  }\n}\n\nSo, the condition is checking whether (type)-id < 0, which is equivalent to id > 0.\n\nIn the Source, the condition is id < call(...), which is a function call.\n\nSo, the condition in the diff is a simpler check based on id's value.\n\nBut the Source's condition is more complex, involving a function call.\n\nSo, in terms of topology, the condition in the diff is a comparison, which matches the Source's structure in that part.\n\nBut the exact condition is different.\n\nSo, perhaps the correct approach is to choose the version that better reflects the Source's structure in terms of the type of condition.\n\nSince the Source uses a comparison, both A and B are comparisons, but the exact condition differs.\n\nBut looking at the code, in the Source, the condition is id < call(...), which is a comparison, and in the diff, the condition is a comparison based on id's value after being negated.\n\nSo, perhaps the condition in the diff should be checking if id is positive, which would correspond to the Source's condition if the function call returns a value that depends on id's positivity.\n\nBut I'm not sure.\n\nAlternatively, perhaps the condition in the Source is id < call(...), which is a comparison, and in the diff, the condition is checking if id is positive, which is a similar comparison.\n\nSo, in that case, both A and B are checking if id is positive, but in different ways.\n\nBut the Source's condition is more about the result of a function call, not directly about id's value.\n\nHmm, this is getting a bit confusing.\n\nLet me try to summarize:\n\n- The Source has a condition that is a comparison involving a function call.\n- The diff is modifying a condition that is a comparison based on id's value after being negated.\n\nSo, the condition in the diff is a simpler comparison, while the Source's condition is more complex, involving a function call.\n\nIn terms of topology match, the condition in the diff is a comparison, which matches the Source's structure in that part.\n\nBut the exact condition is different.\n\nSo, perhaps the correct version is the one that better reflects the Source's condition in terms of the type of check.\n\nBut since both A and B are comparisons, perhaps the choice is based on which condition is more accurate.\n\nWait, in the Source, after id = -id, the condition is (id->id & id) != 0, which is"
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < 0){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(0 < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 5.28125,
          "base_ppl": 3.03125,
          "pr_ppl": 3.015625,
          "source_ast_ppl": 4.59375,
          "base_ast_ppl": 3.59375,
          "pr_ast_ppl": 3.578125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B's conditional is more readable and direct, using a clear comparison without unnecessary negation, aligning with idiomatic control flow for better human understanding.",
          "winner": "PR"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B's conditional simplifies the logic without changing functionality, aligning better with typical coding practices and improving readability.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id = 0;\n  type id = id;\n  type *id = id->id;\n  type *id = call(1, (id));\n  type *id = call(1, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > 0)id->id = id->id;\n  if(call(id, id->id) == -1){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(0, id, id->id)) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(0, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() ^ id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? 8 : 4);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == null){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == null){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != 0){\n    type id = call(id->id, id->id);\n    if(id == (id) - 1){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, 0)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), str, call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = *(type)((type)id + 0x40);\n  id = id;\n  id = id;\n  id = id;\n  id = call(1, 0xdd0);\n  id = call(1, 0x180);\n  call(id, id, 0x40);\n  *(type)((type)id + 0x120) = *(type)((type)id + 0x48);\n  *(type)((type)id + 0x128) = *(type)((type)id + 0x50);\n  *(type)((type)id + 0x58) = id;\n  *(type)((type)id + 0x60) = *(type)((type)id + 0x40);\n  *(type)((type)id + 0x80) = (type)*(type)((type)id + 0x58);\n  if(0 < *(type)((type)id + 0x60)){\n    *(type)((type)id + 0x84) = (type)*(type)((type)id + 0x60);\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n  }else{\n    id = call(0, 2, id[5]);\n    *(type)((type)id + 0x40) = id;\n    if(id == -1){\n      id = 0xf;\n      if(*(type)((type)id + 0x30) != 0){\n        call((type)((type)id + 0x5ce), 0x800, str);\n        call((type)id + 0x5ce, *(type)((type)id + 0x58));\n      }\n    }else{\n      id = call(0, 0, id[5]);\n      if(id == -1){\n        id = 0xf;\n        if(*(type)((type)id + 0x30) != 0){\n          call((type)((type)id + 0x5ce), 0x800, str);\n          call((type)id + 0x5ce, *(type)((type)id + 0x58));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id + 0x30), id);\n        if(id == 0){\n          *(type)((type)id + 0x4c) = id[1];\n          *(type)((type)id + 0x48) = *id;\n          *(type)((type)id + 0x50) = id[2];\n          id = call();\n          *(type)((type)id + 0x68) = id ^ *id;\n          *(type)((type)id + 0x88) = *(type)(id + 0x10);\n          *(type)((type)id + 0x90) = *(type)(id + 0xe);\n          *(type)((type)id + 0x98) = *(type)(id + 8);\n          *(type)((type)id + 0xb0) = *(type)(id + 10);\n          *(type)((type)id + 0xc0) = *(type)(id + 0xc);\n          id = 4;\n          if(*(type)((type)id + 0x4c) != 0){\n            id = 8;\n          }\n          *(type)((type)id + 0xb8) = (type)id;\n          *(type)((type)id + 0x138) = *(type)(id + 0x12);\n          *(type)((type)id + 0x140) = *(type)(id + 0x14);\n          *(type)((type)id + 0x148) = id[3];\n          if(*(type)((type)id + 0x120) == 0){\n            *(type)((type)id + 0x120) = *(type)(id + 0x5e);\n          }\n          id = call(*(type)((type)id + 0x98));\n          *(type)((type)id + 0xa0) = id;\n          if(id == 0){\n            id = 3;\n          }else{\n            if(((*(type)((type)id + 0x120) != 0) && (*(type)((type)id + 0x128) != 0)) && (id = call(*(type)((type)id + 0x120), *(type)((type)id + 0x128))id != 0)){\n              id = call(*(type)((type)id + 0x128), *(type)((type)id + 0x120));\n              if(id == (type)0xffffffffffffffff){\n                id = 7;\n                goto lbl;\n              }\n              *(type)((type)id + 0x130) = id;\n            }\n            id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, *(type)((type)id + 0x130));\n            if(((id == 0) && (id = call(id, &id)id == 0)) && (id = call(id, id)id == 0)){\n              id = call(*(type)((type)id + 0x88), 0, id[5]);\n              if(id == -1){\n                id = 0xf;\n                if(*(type)((type)id + 0x30) != 0){\n                  call((type)((type)id + 0x5ce), 0x800, str, *(type)((type)id + 0x88));\n                  call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                }\n              }else{\n                id = call(id);\n                if((id == 0) && (id = call(id, 0)id == 0)){\n                  if((*(type)((type)id + 0x20) == 0) || (*(type)((type)id + 0x78) == *(type)((type)id + 0x80))){\n                    id = call(id);\n                  }else{\n                    id = 9;\n                    if(*(type)((type)id + 0x30) != 0){\n                      call((type)((type)id + 0x5ce), 0x800, str, (id) * (type)((type)id + 0x80), (id) * (type)((type)id + 0x78));\n                      call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[5]);\n  if((((id == 1) || (id == 2)) || (id == 0xf)) && (*(type)((type)id + 0x30) != 0)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id + 0x5ce), 0x800, str, id, (type)id, id, *id);\n    call((type)id + 0x5ce, id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = *(type)((type)id + 0x40);\n  id = id;\n  id = id;\n  id = id;\n  id = call(1, 0xdd0);\n  id = (type)call(1, 0x180);\n  call(id, id, 0x40);\n  *(type)((type)id + 0x120) = *(type)((type)id + 0x48);\n  *(type)((type)id + 0x128) = *(type)((type)id + 0x50);\n  *(type)((type)id + 0x58) = id;\n  *(type)((type)id + 0x60) = *(type)((type)id + 0x40);\n  *(type)((type)id + 0x80) = (type)*(type)((type)id + 0x58);\n  if(0 < *(type)((type)id + 0x60)){\n    *(type)((type)id + 0x84) = (type)*(type)((type)id + 0x60);\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n  }else{\n    id = call(0, 2, id[5]);\n    *(type)((type)id + 0x40) = id;\n    if(id == -1){\n      id = 0xf;\n      if(*(type)((type)id + 0x30) != 0){\n        call((type)((type)id + 0x5ce), 0x800, str);\n        call((type)id + 0x5ce, *(type)((type)id + 0x58));\n      }\n    }else{\n      id = call(0, 0, id[5]);\n      if(id == -1){\n        id = 0xf;\n        if(*(type)((type)id + 0x30) != 0){\n          call((type)((type)id + 0x5ce), 0x800, str);\n          call((type)id + 0x5ce, *(type)((type)id + 0x58));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id + 0x30), id);\n        if(id == 0){\n          *(type)((type)id + 0x4c) = id[1];\n          *(type)((type)id + 0x48) = *id;\n          *(type)((type)id + 0x50) = id[2];\n          id = call();\n          *(type)((type)id + 0x68) = id ^ *id;\n          *(type)((type)id + 0x88) = *(type)(id + 0x10);\n          *(type)((type)id + 0x90) = *(type)(id + 0xe);\n          *(type)((type)id + 0x98) = *(type)(id + 8);\n          *(type)((type)id + 0xb0) = *(type)(id + 10);\n          *(type)((type)id + 0xc0) = *(type)(id + 0xc);\n          id = 4;\n          if(*(type)((type)id + 0x4c) != 0){\n            id = 8;\n          }\n          *(type)((type)id + 0xb8) = (type)id;\n          *(type)((type)id + 0x138) = *(type)(id + 0x12);\n          *(type)((type)id + 0x140) = *(type)(id + 0x14);\n          *(type)((type)id + 0x148) = id[3];\n          if(*(type)((type)id + 0x120) == 0){\n            *(type)((type)id + 0x120) = *(type)(id + 0x5e);\n          }\n          id = call(*(type)((type)id + 0x98));\n          *(type)((type)id + 0xa0) = id;\n          if(id == 0){\n            id = 3;\n          }else{\n            if(((*(type)((type)id + 0x120) != 0) && (*(type)((type)id + 0x128) != 0)) && (id = call(*(type)((type)id + 0x120), *(type)((type)id + 0x128))id != 0)){\n              id = call(*(type)((type)id + 0x128), *(type)((type)id + 0x120));\n              if(id == (type)0xffffffffffffffff){\n                id = 7;\n                goto lbl;\n              }\n              *(type)((type)id + 0x130) = id;\n            }\n            id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, *(type)((type)id + 0x130));\n            if(((id == 0) && (id = call(id, &id)id == 0)) && (id = call(id, id)id == 0)){\n              id = call(*(type)((type)id + 0x88), 0, id[5]);\n              if(id == -1){\n                id = 0xf;\n                if(*(type)((type)id + 0x30) != 0){\n                  call((type)((type)id + 0x5ce), 0x800, str, *(type)((type)id + 0x88));\n                  call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                }\n              }else{\n                id = call(id);\n                if((id == 0) && (id = call(id, 0)id == 0)){\n                  if((*(type)((type)id + 0x20) == 0) || (*(type)((type)id + 0x78) == *(type)((type)id + 0x80))){\n                    id = call(id);\n                  }else{\n                    id = 9;\n                    if(*(type)((type)id + 0x30) != 0){\n                      call((type)((type)id + 0x5ce), 0x800, str, (id) * (type)((type)id + 0x80), (id) * (type)((type)id + 0x78));\n                      call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[5]);\n  if((((id == 1) || (id == 2)) || (id == 0xf)) && (*(type)((type)id + 0x30) != 0)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id + 0x5ce), 0x800, str, id, (type)id, id, *id);\n    call((type)id + 0x5ce, id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 2.140625,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate A aligns with the Source Code as it correctly assigns the return value of calloc without an unnecessary cast, maintaining the correct pointer type. Candidate B introduces an explicit cast to uint*, which may cause type mismatches and does not reflect the Source's structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "motivation": "Candidate A matches the Source AST as it doesn't introduce unnecessary type casting, preserving the original node structure and nesting depth.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O2.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      param_3 = __src;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      param_3 = __src + sVar2;\n      if (pbVar3 < param_3) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    param_3 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    if (pbVar3 <= param_3) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    pbVar7 = __src;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = __src + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    pbVar7 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id){\n  type *id = (type)id;\n  type *id = id;\n  type id = 0;\n  type *id = (type)id;\n  while(id < (type)id + id){\n    type id = *id++;\n    type id = (id & 0xF0) >> 4;\n    type id = (id & 0x0F);\n    type id = 0;\n    type id = 0;\n    type id = str;\n    if(id + id[id] > (type)id + id){\n      return -1;\n    }\n    switch(id){\n      case id:\n        id = (*id++) + 64 + id * 256;\n        break;\n      case id:\n        id = (*id++) + 64 + id * 256 + 4096;\n        break;\n      case id:\n        id = id + 96;\n        break;\n      case id:\n        id = (*id++) + 18 + id * 256;\n        id = *id++;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = id + 1;\n        break;\n      case id:\n        id = id + 17;\n        break;\n      case id:\n        id = id + 33;\n        break;\n      case id:\n        id = id + 49;\n        break;\n      case id:\n        id = *id++;\n        id = id + 3;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id + id > id){\n        return -1;\n      }\n      if(id + id > (type)id + id){\n        return -1;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id + id > id){\n        return -1;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id( id, type id, type *id,  id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  if(id < 1){\n    return 0;\n  }\n  id = id + id;\n  id = 0;\n  do{\n    id = id + 1;\n    id = *id >> 4;\n    if(id < id + *(type)(id + (type)(type)id * 8)){\n      return 0xffffffffffffffff;\n    }\n    if(0xf < id){\n      lbl:\n      id = id;\n      id = id;\n      goto lbl;\n    }\n    id = *id & 0xf;\n    switch((type)id){\n      case 0:\n        id = (type)id[1] + call(id << 8) + 0x40;\n        goto lbl;\n      case 1:\n        id = (type)id[1] + call(id << 8) + 0x1040;\n        lbl:\n        id = id + 2;\n        goto lbl;\n      case 2:\n        id = id + 0x60;\n        goto lbl;\n      case 3:\n        goto lbl;\n      case 4:\n        id = (type)id[1] + call(id << 8) + 0x12;\n        id = id[2];\n        id = id + 3;\n        break;\n      case 5:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x40;\n        break;\n      case 6:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x20;\n        break;\n      case 7:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0;\n        break;\n      case 8:\n        id = id + 1;\n        goto lbl;\n      case 9:\n        id = id + 0x11;\n        goto lbl;\n      case 10:\n        id = id + 0x21;\n        goto lbl;\n      case 0xb:\n        id = id + 0x31;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        if(id != 0){\n          call((type)(id + id), id, id);\n        }\n        goto lbl;\n      case 0xc:\n        id = id[1];\n        id = id + 2;\n        id = (type)(id + 3);\n        break;\n      case 0xd:\n        id = (type)(id + 2);\n        id = 0x40;\n        break;\n      case 0xe:\n        id = (type)(id + 2);\n        id = 0x20;\n        break;\n      case 0xf:\n        id = (type)(id + 2);\n        id = 0;\n    }\n    id = id + id;\n    if(id < id){\n      return 0xffffffffffffffff;\n    }\n    id = id;\n    if(id != 0){\n      call((type)(id + id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id( id, type id, type *id,  id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  if(id < 1){\n    return 0;\n  }\n  id = id + id;\n  id = 0;\n  do{\n    id = id + 1;\n    id = *id >> 4;\n    if(id < id + *(type)(id + (type)(type)id * 8)){\n      return 0xffffffffffffffff;\n    }\n    id = id;\n    id = id;\n    if(0xf < id)goto lbl;\n    id = *id & 0xf;\n    switch((type)id){\n      case 0:\n        id = (type)id[1] + call(id << 8) + 0x40;\n        goto lbl;\n      case 1:\n        id = (type)id[1] + call(id << 8) + 0x1040;\n        lbl:\n        id = id + 2;\n        goto lbl;\n      case 2:\n        id = id + 0x60;\n        goto lbl;\n      case 3:\n        goto lbl;\n      case 4:\n        id = (type)id[1] + call(id << 8) + 0x12;\n        id = id[2];\n        id = id + 3;\n        break;\n      case 5:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x40;\n        break;\n      case 6:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x20;\n        break;\n      case 7:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0;\n        break;\n      case 8:\n        id = id + 1;\n        goto lbl;\n      case 9:\n        id = id + 0x11;\n        goto lbl;\n      case 10:\n        id = id + 0x21;\n        goto lbl;\n      case 0xb:\n        id = id + 0x31;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        if(id != 0){\n          call((type)(id + id), id, id);\n        }\n        goto lbl;\n      case 0xc:\n        id = id[1];\n        id = id + 2;\n        id = (type)(id + 3);\n        break;\n      case 0xd:\n        id = (type)(id + 2);\n        id = 0x40;\n        break;\n      case 0xe:\n        id = (type)(id + 2);\n        id = 0x20;\n        break;\n      case 0xf:\n        id = (type)(id + 2);\n        id = 0;\n    }\n    id = id + id;\n    if(id < id){\n      return 0xffffffffffffffff;\n    }\n    id = id;\n    if(id != 0){\n      call((type)(id + id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.9375,
          "base_ppl": 2.0,
          "pr_ppl": 1.921875,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.46875,
          "delta_ppl": -0.078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O3.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id){\n  type *id = (type)id;\n  type *id = id;\n  type id = 0;\n  type *id = (type)id;\n  while(id < (type)id + id){\n    type id = *id++;\n    type id = (id & 0xF0) >> 4;\n    type id = (id & 0x0F);\n    type id = 0;\n    type id = 0;\n    type id = str;\n    if(id + id[id] > (type)id + id){\n      return -1;\n    }\n    switch(id){\n      case id:\n        id = (*id++) + 64 + id * 256;\n        break;\n      case id:\n        id = (*id++) + 64 + id * 256 + 4096;\n        break;\n      case id:\n        id = id + 96;\n        break;\n      case id:\n        id = (*id++) + 18 + id * 256;\n        id = *id++;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = id + 1;\n        break;\n      case id:\n        id = id + 17;\n        break;\n      case id:\n        id = id + 33;\n        break;\n      case id:\n        id = id + 49;\n        break;\n      case id:\n        id = *id++;\n        id = id + 3;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id + id > id){\n        return -1;\n      }\n      if(id + id > (type)id + id){\n        return -1;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id + id > id){\n        return -1;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id( id, type id, type *id,  id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  if(id < 1){\n    return 0;\n  }\n  id = id + id;\n  id = 0;\n  do{\n    id = id + 1;\n    id = *id >> 4;\n    if(id < id + *(type)(id + (type)(type)id * 8)){\n      return 0xffffffffffffffff;\n    }\n    if(0xf < id){\n      lbl:\n      id = id;\n      goto lbl;\n    }\n    id = *id & 0xf;\n    switch((type)id){\n      case 0:\n        id = (type)id[1] + call(id << 8) + 0x40;\n        goto lbl;\n      case 1:\n        id = (type)id[1] + call(id << 8) + 0x1040;\n        lbl:\n        id = id + 2;\n        goto lbl;\n      case 2:\n        id = id + 0x60;\n        goto lbl;\n      case 3:\n        goto lbl;\n      case 4:\n        id = (type)id[1] + call(id << 8) + 0x12;\n        id = id[2];\n        id = id + 3;\n        break;\n      case 5:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x40;\n        break;\n      case 6:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x20;\n        break;\n      case 7:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0;\n        break;\n      case 8:\n        id = id + 1;\n        goto lbl;\n      case 9:\n        id = id + 0x11;\n        goto lbl;\n      case 10:\n        id = id + 0x21;\n        goto lbl;\n      case 0xb:\n        id = id + 0x31;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        if(id != 0){\n          call((type)(id + id), id, id);\n        }\n        goto lbl;\n      case 0xc:\n        id = id[1];\n        id = id + 2;\n        id = (type)(id + 3);\n        break;\n      case 0xd:\n        id = (type)(id + 2);\n        id = 0x40;\n        break;\n      case 0xe:\n        id = (type)(id + 2);\n        id = 0x20;\n        break;\n      case 0xf:\n        id = (type)(id + 2);\n        id = 0;\n    }\n    id = id + id;\n    if(id < id){\n      return 0xffffffffffffffff;\n    }\n    if(id != 0){\n      call((type)(id + id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id( id, type id, type *id,  id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  if(id < 1){\n    return 0;\n  }\n  id = id + id;\n  id = 0;\n  do{\n    id = id + 1;\n    id = *id >> 4;\n    if(id < id + *(type)(id + (type)(type)id * 8)){\n      return 0xffffffffffffffff;\n    }\n    id = id;\n    if(0xf < id)goto lbl;\n    id = *id & 0xf;\n    switch((type)id){\n      case 0:\n        id = (type)id[1] + call(id << 8) + 0x40;\n        goto lbl;\n      case 1:\n        id = (type)id[1] + call(id << 8) + 0x1040;\n        lbl:\n        id = id + 2;\n        goto lbl;\n      case 2:\n        id = id + 0x60;\n        goto lbl;\n      case 3:\n        goto lbl;\n      case 4:\n        id = (type)id[1] + call(id << 8) + 0x12;\n        id = id[2];\n        id = id + 3;\n        break;\n      case 5:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x40;\n        break;\n      case 6:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x20;\n        break;\n      case 7:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0;\n        break;\n      case 8:\n        id = id + 1;\n        goto lbl;\n      case 9:\n        id = id + 0x11;\n        goto lbl;\n      case 10:\n        id = id + 0x21;\n        goto lbl;\n      case 0xb:\n        id = id + 0x31;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        if(id != 0){\n          call((type)(id + id), id, id);\n        }\n        goto lbl;\n      case 0xc:\n        id = id[1];\n        id = id + 2;\n        id = (type)(id + 3);\n        break;\n      case 0xd:\n        id = (type)(id + 2);\n        id = 0x40;\n        break;\n      case 0xe:\n        id = (type)(id + 2);\n        id = 0x20;\n        break;\n      case 0xf:\n        id = (type)(id + 2);\n        id = 0;\n    }\n    id = id + id;\n    if(id < id){\n      return 0xffffffffffffffff;\n    }\n    if(id != 0){\n      call((type)(id + id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.9375,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.9296875,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.46875,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns better with the Source's structure by simplifying the control flow with direct goto statements, eliminating unnecessary labels and making the code closer to the Source's switch-case structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      }
    ],
    "qwen-2.5": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)*(type)(id + 1));\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = (type)call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = (id) * (type)id;\n            *(type)((type)id + 0xd) = *(type)id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (id) * (type)(id + 5));\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (id) * (type)(id + 6));\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (id) * (type)(id + id * 2 + 1), (id) * (type)((type)id + id * 4 + 3), (id) * (type)(id + id * 2 + 2));\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (id) * (type)(id + 1));\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 1.8203125,
          "pr_ppl": 1.8046875,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.078125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate B introduces more explicit pointer arithmetic and type casting, which can make the code harder to read and understand for humans. It also maintains the complex nested structure, which does not reflect clean logical scopes as seen in Candidate A. Therefore, Candidate A is more human-like in terms of idiomatic design.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(param_1 + 1));\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)*(byte *)__ptr;\n          *(byte *)((long)param_1 + 0xd) = *(byte *)__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(__ptr + 5));\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(__ptr + 6));\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 1),\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)*(byte *)(__ptr + lVar5 * 2 + 2));\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(__ptr + 1));\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = call(id) * id;\n            *(type)((type)id + 0xd) = (id) * id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (type)(type)id[id * 2 + 1], (id) * (type)((type)id + id * 4 + 3), (type)(type)id[id * 2 + 2]);\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (type)(type)id[1]);\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = (type)id;\n    call(str);\n    id = 1;\n    id = (type)&id + 4;\n    id = (type)0x0;\n    id = 0;\n    id = 0;\n    do{\n      if(10 < *(type)id){\n        call(str, (type)*(type)(id + 1));\n        id = *id;\n        call(str, (id) * (type)(id + 8), (id) * (type)(id + 0x10), (id) * (type)(id + 0x20), (id) * (type)(id + 0x28));\n      }\n      id = call(id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(id);\n      if(*(type)id != 0){\n        call(id);\n      }\n      if(id >> 0x30 != 0){\n        id = (type)call(id, id >> 0x30);\n        if(id == (type)0x0){\n          if(*(type)id == 0){\n            return 5;\n          }\n          call(*(type)id, str, (type)id.id);\n          return 5;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id >> 0x30){\n          id = 3;\n          if(*(type)id != 0){\n            call(str, 0x20, 1, *(type)id);\n          }\n          goto lbl;\n        }\n      }\n      id = call(id, id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      if(id.id < 0x92){\n        switch(id.id){\n          case 10:\n            break;\n          case 0xb:\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n          case 0x21:\n          case 0x23:\n          case 0x24:\n          case 0x25:\n          case 0x26:\n          case 0x27:\n          case 0x28:\n          case 0x29:\n          case 0x2a:\n          case 0x2b:\n          case 0x2c:\n          case 0x2d:\n          case 0x2e:\n          case 0x30:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n          case 0x38:\n          case 0x39:\n          case 0x3a:\n          case 0x3b:\n          case 0x3e:\n          case 0x3f:\n          case 0x40:\n          case 0x41:\n            goto lbl;\n          case 0x18:\n            if(*(type)id != 0){\n              call(str);\n              if(id.id != 0){\n                id = 0;\n                do{\n                  call(str, (id) * (type)((type)id + id));\n                  id = id + 1;\n                }while(id < id >> 0x30);\n              }\n              call(10);\n            }\n            break;\n          case 0x22:\n            id = (id) * (type)id;\n            *(type)((type)id + 0xd) = *(type)id;\n            if(*(type)id != 0){\n              id = str;\n              lbl:\n              call(id, id);\n            }\n            break;\n          case 0x2f:\n            id = 6;\n            goto lbl;\n          case 0x31:\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (id) * (type)(id + 5));\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (id) * (type)(id + 6));\n              if(id != 0){\n                call(str, id);\n              }\n            }\n            break;\n          case 0x3c:\n            if(id == 0){\n              if((id == 0xfc) && (id = call(id, id, id.id)id != 0))goto lbl;\n              id = call(id, call(id, (type)id));\n            }\n            break;\n          case 0x3d:\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, call(*id / 0x14));\n              call(str, call(id[1] / 0x14));\n              call(str, call(id[2] / 0x14));\n              call(str, call(id[3] / 0x14));\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              id = (type)id[8];\n              id = str;\n              goto lbl;\n            }\n            break;\n          case 0x42:\n            id = (id) * id;\n            *(type)((type)id + 0x12) = *id;\n            if(*(type)id != 0){\n              id = str;\n              goto lbl;\n            }\n            break;\n          case def:\n            if(id.id == 0x85){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            lbl:\n            if(*(type)id != 0){\n              call(str, (type)id.id, (type)id.id);\n            }\n        }\n      }elseif(id.id < 0x231){\n        if(id.id < 0xfc){\n          if(id.id == 0x92){\n            if((10 < *(type)id) && (id = *idid != 0)){\n              id = 0;\n              do{\n                call(str, call((type)id + 8), (id) * (type)(id + id * 2 + 1), (id) * (type)((type)id + id * 4 + 3), (id) * (type)(id + id * 2 + 2));\n                id = id + 1;\n              }while((type)id != (type)id);\n            }\n          }else{\n            if(id.id != 0xe0)goto lbl;\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id == 0){\n                if(*(type)id != 0){\n                  call(id);\n                }\n                goto lbl;\n              }\n              break;\n            }\n            call(id);\n            id = call(id, id);\n            if(id != 0)break;\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              id = (type)id[7];\n              id = str;\n              goto lbl;\n            }\n          }\n        }elseif(id.id == 0xfc){\n          call(id);\n          id = call(id, id, id.id);\n          lbl:\n          if(id != 0)break;\n        }elseif(id.id != 0xff)goto lbl;\n      }elseif(id.id < 0x41e){\n        if(id.id == 0x231)goto lbl;\n        if(id.id != 0x293)goto lbl;\n        if(*(type)id != 0){\n          call(str, call(*id & 0x7ff));\n          if((type)*id < 0){\n            call(str, (id) * (type)(id + 1));\n            id = (id) * (type)((type)id + 3);\n            id = str;\n            goto lbl;\n          }\n          id = (type)call(id + 1, (id >> 0x30) - 2, 1, id);\n          call(str, id);\n          call(id);\n        }\n      }else{\n        if(id.id == 0x41e){\n          call(id);\n          id = call(id, id, id.id);\n          goto lbl;\n        }\n        if(id.id != 0x809)goto lbl;\n        id = *id;\n        *(type)((type)id + 0xc) = id != 0x600;\n        *(type)((type)id + 0xe) = id[1];\n        if(*(type)id != 0){\n          id = str;\n          if(id != 0x600){\n            id = str;\n          }\n          call(str, id);\n          id = (id) * (type)((type)id + 0xe);\n          id = str;\n          goto lbl;\n        }\n      }\n      lbl:\n      id = 0;\n      if(*(type)(*id + 0x3c) != str)break;\n      id = id.id;\n      id = id.id;\n    }while(id.id != 10);\n    lbl:\n    if(id != (type)0x0){\n      lbl:\n      call(id);\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 1.8203125,
          "pr_ppl": 1.8046875,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.078125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_signextend-O0.so",
        "function": "file_signextend",
        "source_code": "file_protected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = CAST(signed char,  v);\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = CAST(short, v);\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\tcase FILE_MSDOSDATE:\n\t\tcase FILE_BEMSDOSDATE:\n\t\tcase FILE_LEMSDOSDATE:\n\t\tcase FILE_MSDOSTIME:\n\t\tcase FILE_BEMSDOSTIME:\n\t\tcase FILE_LEMSDOSTIME:\n\t\t\tv = CAST(int32_t, v);\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\tcase FILE_OFFSET:\n\t\tcase FILE_BEVARINT:\n\t\tcase FILE_LEVARINT:\n\t\t\tv = CAST(int64_t, v);\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\tcase FILE_DER:\n\t\tcase FILE_GUID:\n\t\tcase FILE_OCTAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn FILE_BADSIZE;\n\t\t}\n\t}\n\treturn v;\n}\n",
        "function_base": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch((char)param_2[3]) {\n    case '\\x01':\n      local_28 = (long)(char)param_3;\n      break;\n    case '\\x02':\n    case '\\a':\n    case '\\n':\n      local_28 = (long)(short)param_3;\n      break;\n    case '\\x03':\n    case '\\x05':\n    case '\\r':\n    case '\\x11':\n    case '\\x12':\n    case '\\x13':\n    case '\\x14':\n    case ')':\n    case '-':\n    case '.':\n    case '/':\n    case '0':\n    case '1':\n    case ';':\n      break;\n    case '\\x04':\n    case '\\x06':\n    case '\\b':\n    case '\\t':\n    case '\\v':\n    case '\\f':\n    case '\\x0e':\n    case '\\x0f':\n    case '\\x10':\n    case '\\x15':\n    case '\\x16':\n    case '\\x17':\n    case '!':\n    case '\\\"':\n    case '#':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case ':':\n      local_28 = (long)(int)param_3;\n      break;\n    case '\\x18':\n    case '\\x19':\n    case '\\x1a':\n    case '\\x1b':\n    case '\\x1c':\n    case '\\x1d':\n    case '\\x1e':\n    case '\\x1f':\n    case ' ':\n    case '$':\n    case '%':\n    case '&':\n    case '*':\n    case '+':\n    case ',':\n    case '2':\n    case '3':\n    case '4':\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",(char)param_2[3]);\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "function_pr": "\nlong file_signextend(long param_1,ushort *param_2,long param_3)\n\n{\n  long local_28;\n  \n  local_28 = param_3;\n  if ((*param_2 & 8) == 0) {\n    switch(*(undefined *)(param_2 + 3)) {\n    case 1:\n      local_28 = (long)(char)param_3;\n      break;\n    case 2:\n    case 7:\n    case 10:\n      local_28 = (long)(short)param_3;\n      break;\n    case 3:\n    case 5:\n    case 0xd:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x29:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x3b:\n      break;\n    case 4:\n    case 6:\n    case 8:\n    case 9:\n    case 0xb:\n    case 0xc:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n      local_28 = (long)(int)param_3;\n      break;\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n      break;\n    default:\n      if ((*(uint *)(param_1 + 0x44) & 0x40) != 0) {\n        file_magwarn(param_1,\"cannot happen: m->type=%d\\n\",*(undefined *)(param_2 + 3));\n      }\n      return -1;\n    }\n  }\n  return local_28;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type id){\n  if(!(id->id & id)){\n    switch(id->id){\n      case id:\n        id = call(id, id, id);\n        break;\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        id = call(id, id);\n        break;\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n      case id:\n        break;\n      case def:\n        if(id->id & id)call(id, str, id->id);\n        return id;\n    }\n  }\n  return id;\n}",
        "base_ast": " id( id, type *id,  id){\n  type id;\n  id = id;\n  if((*id & 8) == 0){\n    switch((type)id[3]){\n      case str:\n        id = (type)(type)id;\n        break;\n      case str:\n      case str:\n      case str:\n        id = (type)(type)id;\n        break;\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n        break;\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n        id = (type)(type)id;\n        break;\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n      case str:\n        break;\n      case def:\n        if((*(type)(id + 0x44) & 0x40) != 0){\n          call(id, str, (type)id[3]);\n        }\n        return -1;\n    }\n  }\n  return id;\n}",
        "pr_ast": " id( id, type *id,  id){\n  type id;\n  id = id;\n  if((*id & 8) == 0){\n    switch(*(type)(id + 3)){\n      case 1:\n        id = (type)(type)id;\n        break;\n      case 2:\n      case 7:\n      case 10:\n        id = (type)(type)id;\n        break;\n      case 3:\n      case 5:\n      case 0xd:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x29:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x3b:\n        break;\n      case 4:\n      case 6:\n      case 8:\n      case 9:\n      case 0xb:\n      case 0xc:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x21:\n      case 0x22:\n      case 0x23:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n        id = (type)(type)id;\n        break;\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n      case 0x24:\n      case 0x25:\n      case 0x26:\n      case 0x2a:\n      case 0x2b:\n      case 0x2c:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n        break;\n      case def:\n        if((*(type)(id + 0x44) & 0x40) != 0){\n          call(id, str, *(type)(id + 3));\n        }\n        return -1;\n    }\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.015625,
          "base_ppl": 1.9921875,
          "pr_ppl": 1.7109375,
          "source_ast_ppl": 1.7578125,
          "base_ast_ppl": 2.109375,
          "pr_ast_ppl": 1.8359375,
          "delta_ppl": -0.28125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar3 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)*(int *)(local_18 + 1));\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = *(byte *)local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)*(byte *)(local_28 + 5));\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)*(byte *)(local_28 + 6));\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar3) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)*(byte *)local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              bVar1 = *(byte *)local_28;\n              bVar2 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)bVar1 + (uint)bVar2 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)*(byte *)local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)*(byte *)(local_78 + 1));\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)*(byte *)(local_28 + 1));\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)*(byte *)local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 !=\n                       0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)*(byte *)(local_28 + 1) +\n                       (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar3 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "type id(type *id){\n  if(!id)return id;\n  type id = id0id0;\n  type id = id0id0;\n  type *id = null;\n  type id = 0;\n  type id = id;\n  call(str);\n  do{\n    if(id > 10){\n      call(str, (type)id->id);\n      call(str, id->id->id, (type)id->id->id, (type)id->id->id, (type)id->id->id);\n    }\n    if(call(&id, 1, 4, id->id) != 4){\n      id = id;\n      goto lbl;\n    }\n    call(&id);\n    if(id)call(&id);\n    if(id.id){\n      if((id = call(id, id.id)) == null){\n        if(id)call(id, str, (type)id.id);\n        id = id;\n        goto lbl;\n      }\n      if(call(id, 1, id.id, id->id) != id.id){\n        if(id)call(id, str);\n        id = id;\n        goto lbl;\n      }\n    }\n    if(call(id, &id, id)){\n      id = id;\n      goto lbl;\n    }\n    switch(id.id){\n      case id:\n        break;\n      case id:\n        id->id = (id[0] + (id[1] << 8) != 0x600);\n        id->id = id[2] + (id[3] << 8);\n        if(id){\n          call(str, (id->id ? str : str));\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id->id = id[0] + (id[1] << 8);\n        if(id)call(str, id->id);\n        break;\n      case id:\n        if(id){\n          if(id.id == id){\n            if((id = call(id, id, id.id)) != id)goto lbl;\n          }\n          id = id;\n        }\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          id->id = id->id;\n          if(id){\n            call(str);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id / 20);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        break;\n      case id:\n        {\n          type *id = (type)id;\n          call(id);\n          if((id = call(id, id, id.id)) != id){\n            goto lbl;\n          }\n        }\n        break;\n      case id:\n        if(id->id){\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n          }\n        }else{\n          type *id;\n          id = (type)id;\n          call(id);\n          if((id = call(id, id)) != id){\n            goto lbl;\n          }\n          if(id){\n            call(id);\n          }\n        }\n        break;\n      case id:\n      case id:\n        {\n          type *id;\n          type *id = (type)id;\n          call(id);\n          id = call(id, id, id.id);\n          if(id){\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            call(str, id->id);\n            if(id)call(str, id);\n          }\n        }\n        break;\n      case id:\n        call((type)id);\n        if((id = call(id, (type)id, id.id)) != id){\n          goto lbl;\n        }\n        break;\n      case id:\n        if(id){\n          type *id;\n          id = (type)id;\n          call(str, id->id & 0x07FF);\n          if(id->id & 0x8000){\n            call(str, id->id);\n            call(str, id->id);\n          }else{\n            type *id = call((type)&id[2], id.id - 2, 1, id);\n            call(str, id);\n            call(id);\n          }\n        }\n        break;\n      case id:\n        if(id > 10){\n          type *id = id + 2;\n          type id, id;\n          id = id[0] + (id[1] << 8);\n          for(id = 0;  id < id; ++id){\n            call(str, id + 8, id[0], id[1], id[2]);\n            id = 4;\n          }\n        }\n        break;\n      case id:\n        id->id = *(type)id;\n        if(id){\n          call(str, id->id);\n        }\n        break;\n      case id:\n        id = id;\n        goto lbl;\n      case id:\n        if(id){\n          type id;\n          call(str);\n          for(id = 0;  id < id.id; ++id)call(str, id[id]);\n          call(str);\n        }\n        break;\n      case def:\n        if(id){\n          call(str, id.id, id.id);\n        }\n        break;\n    }\n    id = id;\n    id = 1;\n  }while((!id->id->id) && (id.id != id));\n  lbl:\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = id;\n    call(&id, 0, 4);\n    call(&id, 0, 4);\n    id = (type)0x0;\n    id = bool;\n    id = 0;\n    call(str);\n    do{\n      if(10 < *(type)id){\n        call(str, (type)(type)id[1]);\n        call(str, (id) * (type)(*id + 8), *(type)(*id + 0x10) & 0xffffffff, *(type)(*id + 0x20) & 0xffffffff, *(type)(*id + 0x28) & 0xffffffff);\n      }\n      id = call(&id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(&id);\n      if(*(type)id != 0){\n        call(&id);\n      }\n      if(id.id != 0){\n        id = call(id, (type)id.id);\n        if(id == (type)0x0){\n          if(*(type)id != 0){\n            call(*(type)id, str, (type)id.id);\n          }\n          id = 5;\n          break;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != 0){\n            call(*(type)id, str);\n          }\n          id = 3;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      id = id & 0xffff;\n      if(id != 10){\n        if(id == 0x18){\n          if(*(type)id != 0){\n            call(str);\n            for(id = 0;  id < (type)(id >> 0x10); id = id + 1){\n              call(str, (id) * (type)((type)id + (type)id));\n            }\n            call(str);\n          }\n        }elseif(id == 0x22){\n          *(type)((type)id + 0xd) = (id) * id;\n          if(*(type)id != 0){\n            call(str, (id) * (type)((type)id + 0xd));\n          }\n        }else{\n          if(id == 0x2f){\n            id = 6;\n            break;\n          }\n          if(id == 0x31){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (type)(type)id[5]);\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (type)(type)id[6]);\n              if(id != 0){\n                call(str, id);\n              }\n            }\n          }elseif(id == 0x3c){\n            if(id){\n              if(((type)id == 0xfc) && (id = call(id, id, id.id)id != 0))break;\n              id = id;\n            }\n          }elseif(id == 0x3d){\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, (id) * id / 0x14, (id) * id % 0x14);\n              call(str, (type)id[1] / 0x14, (type)id[1] % 0x14);\n              call(str, (type)id[2] / 0x14, (type)id[2] % 0x14);\n              call(str, (type)id[3] / 0x14, (type)id[3] % 0x14);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              call(str, (type)id[8]);\n            }\n          }elseif(id == 0x42){\n            *(type)((type)id + 0x12) = call(id) * id + (id) * (type)((type)id + 1) * 0x100;\n            if(*(type)id != 0){\n              call(str, (id) * (type)((type)id + 0x12));\n            }\n          }elseif(id == 0x85){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != 0)break;\n          }elseif(id == 0x92){\n            if(10 < *(type)id){\n              id = id + 1;\n              id = *id;\n              id = *(type)((type)id + 1);\n              for(id = 0;  id < (type)((type)(type)id + (type)id * 0x100); id = id + 1){\n                call(str, call(id + 8), call(id) * id, (id) * (type)((type)id + 1), (type)(type)id[1]);\n                id = id + 2;\n              }\n            }\n          }elseif(id == 0xe0){\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(str, (id) * id);\n                call(str, (type)id[1]);\n                call(str, (type)id[2]);\n                call(str, (type)id[3]);\n                call(str, (type)id[4]);\n                call(str, (type)id[5]);\n                call(str, (type)id[6]);\n                call(str, (type)id[7]);\n              }\n            }\n          }else{\n            if(id == 0xfc){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != 0xff){\n              if(id == 0x231)goto lbl;\n              if(id == 0x293){\n                if(*(type)id != 0){\n                  call(str, call(*id & 0x7ff));\n                  if((*id & 0x8000) == 0){\n                    id = (type)call(id + 1, (type)(type)((id >> 0x10) - 2), 1, id);\n                    call(str, id);\n                    call(id);\n                  }else{\n                    call(str, (type)(type)id[1]);\n                    call(str, (id) * (type)((type)id + 3));\n                  }\n                }\n              }else{\n                if(id == 0x41e){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == 0x809){\n                  *(type)((type)id + 0xc) = call(id) * id + (id) * (type)((type)id + 1) * 0x100 != 0x600;\n                  *(type)((type)id + 0xe) = (type)(type)id[1] + (id) * (type)((type)id + 3) * 0x100;\n                  if(*(type)id != 0){\n                    id = str;\n                    if(*(type)((type)id + 0xc) != str){\n                      id = str;\n                    }\n                    call(str, id);\n                    call(str, (id) * (type)((type)id + 0xe));\n                  }\n                }elseif(*(type)id != 0){\n                  call(str, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id + 0x3c) == str){\n        id = (type)id != 10;\n      }\n    }while(id);\n    if(id != (type)0x0){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  if(id == (type)0x0){\n    id = 7;\n  }else{\n    id = id;\n    call(&id, 0, 4);\n    call(&id, 0, 4);\n    id = (type)0x0;\n    id = bool;\n    id = 0;\n    call(str);\n    do{\n      if(10 < *(type)id){\n        call(str, (type)*(type)(id + 1));\n        call(str, (id) * (type)(*id + 8), *(type)(*id + 0x10) & 0xffffffff, *(type)(*id + 0x20) & 0xffffffff, *(type)(*id + 0x28) & 0xffffffff);\n      }\n      id = call(&id, 1, 4, *id);\n      if(id != 4){\n        id = 3;\n        break;\n      }\n      call(&id);\n      if(*(type)id != 0){\n        call(&id);\n      }\n      if(id.id != 0){\n        id = (type)call(id, (type)id.id);\n        if(id == (type)0x0){\n          if(*(type)id != 0){\n            call(*(type)id, str, (type)id.id);\n          }\n          id = 5;\n          break;\n        }\n        id = call(id, 1, id.id, *id);\n        if(id != id.id){\n          if(*(type)id != 0){\n            call(*(type)id, str);\n          }\n          id = 3;\n          break;\n        }\n      }\n      id = call(id, &id, id);\n      if(id != 0){\n        id = 4;\n        break;\n      }\n      id = id & 0xffff;\n      if(id != 10){\n        if(id == 0x18){\n          if(*(type)id != 0){\n            call(str);\n            for(id = 0;  id < (type)(id >> 0x10); id = id + 1){\n              call(str, (id) * (type)((type)id + (type)id));\n            }\n            call(str);\n          }\n        }elseif(id == 0x22){\n          *(type)((type)id + 0xd) = *(type)id;\n          if(*(type)id != 0){\n            call(str, (id) * (type)((type)id + 0xd));\n          }\n        }else{\n          if(id == 0x2f){\n            id = 6;\n            break;\n          }\n          if(id == 0x31){\n            lbl:\n            call(id);\n            id = call(id, id, id.id);\n            if(*(type)id != 0){\n              call(str, (id) * id);\n              call(str, (type)id[1]);\n              call(str, (type)id[2]);\n              call(str, (type)id[3]);\n              call(str, (type)id[4]);\n              call(str, (id) * (type)(id + 5));\n              call(str, (id) * (type)((type)id + 0xb));\n              call(str, (id) * (type)(id + 6));\n              if(id != 0){\n                call(str, id);\n              }\n            }\n          }elseif(id == 0x3c){\n            if(id){\n              if(((type)id == 0xfc) && (id = call(id, id, id.id)id != 0))break;\n              id = id;\n            }\n          }elseif(id == 0x3d){\n            call(id);\n            *(type)(id + 2) = id[5];\n            if(*(type)id != 0){\n              call(str);\n              call(str, (id) * id / 0x14, (id) * id % 0x14);\n              call(str, (type)id[1] / 0x14, (type)id[1] % 0x14);\n              call(str, (type)id[2] / 0x14, (type)id[2] % 0x14);\n              call(str, (type)id[3] / 0x14, (type)id[3] % 0x14);\n              call(str, (type)id[4]);\n              call(str, (type)id[5]);\n              call(str, (type)id[6]);\n              call(str, (type)id[7]);\n              call(str, (type)id[8]);\n            }\n          }elseif(id == 0x42){\n            *(type)((type)id + 0x12) = (id) * (type)id + (id) * (type)((type)id + 1) * 0x100;\n            if(*(type)id != 0){\n              call(str, (id) * (type)((type)id + 0x12));\n            }\n          }elseif(id == 0x85){\n            call(id);\n            id = call(id, id, id.id);\n            lbl:\n            if(id != 0)break;\n          }elseif(id == 0x92){\n            if(10 < *(type)id){\n              id = id + 1;\n              id = *(type)id;\n              id = *(type)((type)id + 1);\n              for(id = 0;  id < (type)((type)id + (type)id * 0x100); id = id + 1){\n                call(str, call(id + 8), (id) * (type)id, (id) * (type)((type)id + 1), (id) * (type)(id + 1));\n                id = id + 2;\n              }\n            }\n          }elseif(id == 0xe0){\n            if(*(type)((type)id + 0xc) == str){\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(id);\n              }\n            }else{\n              call(id);\n              id = call(id, id);\n              if(id != 0)break;\n              if(*(type)id != 0){\n                call(str, (id) * id);\n                call(str, (type)id[1]);\n                call(str, (type)id[2]);\n                call(str, (type)id[3]);\n                call(str, (type)id[4]);\n                call(str, (type)id[5]);\n                call(str, (type)id[6]);\n                call(str, (type)id[7]);\n              }\n            }\n          }else{\n            if(id == 0xfc){\n              call(id);\n              id = call(id, id, id.id);\n              goto lbl;\n            }\n            if(id != 0xff){\n              if(id == 0x231)goto lbl;\n              if(id == 0x293){\n                if(*(type)id != 0){\n                  call(str, call(*id & 0x7ff));\n                  if((*id & 0x8000) == 0){\n                    id = (type)call(id + 1, (type)(type)((id >> 0x10) - 2), 1, id);\n                    call(str, id);\n                    call(id);\n                  }else{\n                    call(str, (id) * (type)(id + 1));\n                    call(str, (id) * (type)((type)id + 3));\n                  }\n                }\n              }else{\n                if(id == 0x41e){\n                  call(id);\n                  id = call(id, id, id.id);\n                  goto lbl;\n                }\n                if(id == 0x809){\n                  *(type)((type)id + 0xc) = (id) * (type)id + (id) * (type)((type)id + 1) * 0x100 != 0x600;\n                  *(type)((type)id + 0xe) = (id) * (type)(id + 1) + (id) * (type)((type)id + 3) * 0x100;\n                  if(*(type)id != 0){\n                    id = str;\n                    if(*(type)((type)id + 0xc) != str){\n                      id = str;\n                    }\n                    call(str, id);\n                    call(str, (id) * (type)((type)id + 0xe));\n                  }\n                }elseif(*(type)id != 0){\n                  call(str, (type)(type)id, (type)id.id);\n                }\n              }\n            }\n          }\n        }\n      }\n      id = id;\n      id = bool;\n      id = bool;\n      if(*(type)(*id + 0x3c) == str){\n        id = (type)id != 10;\n      }\n    }while(id);\n    if(id != (type)0x0){\n      call(id);\n    }\n    id = id;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.234375,
          "base_ppl": 1.8125,
          "pr_ppl": 1.796875,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.1875,
          "pr_ast_ppl": 2.15625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces more noise and does not match the control flow structures of the Source Code as closely as Candidate A.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = (type)call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = (type)call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.671875,
          "base_ppl": 1.6640625,
          "pr_ppl": 1.6640625,
          "source_ast_ppl": 2.078125,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.0,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id[9];\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[80];\n  type id[8200];\n  id = call(id);\n  id = id + (type)id;\n  id = (type)id;\n  id = (type)call(id, id);\n  id = (type)id;\n  id = id;\n  if(id == 0){\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n  }else{\n    id = 0x50 - (type)id;\n    id = 1;\n    id = (type)0x0;\n    id = (type)0x0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + *(type)(id + id * 2);\n      id = (id) * (type)(id + id * 2);\n      id = (type)(type)id[id];\n      id = id + ((type)id - 1);\n      if(id <= id){\n        id = id;\n        do{\n          while(bool){\n            id = (type)id - (type)id >> 1;\n            id = id + id;\n            if(*id < (type)id[id])break;\n            if(*id <= (type)id[id]){\n              id = (type)id - (type)id;\n              goto lbl;\n            }\n            id = id + 1;\n            if(id < id)goto lbl;\n          }\n          id = id + -1;\n        }while(id <= id);\n      }\n      lbl:\n      id = id + id;\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + id;\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      id = (type)(type)(type)(type)id[id];\n      id = (type)(type)(&id)[id];\n      id = (type)(type)id[id];\n      if((id != 0) && (id = (type)str[id + 0x2c]str[id + 0x2c] != str)){\n        id = str + id + 0x2c;\n        do{\n          id = id;\n          switch(id[1]){\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n              break;\n            case str:\n            case str:\n              id = id;\n              break;\n            case str:\n            case str:\n              id = id + -(type)id;\n              break;\n            case str:\n              id = id;\n              id = (type)call(id, id, id, 0x28, id);\n              id = id;\n              if(id == (type)0x0){\n                call(id, 0x2000, str, id);\n                id = id;\n                if(*(type)(id + 0x30) != (type)0x0){\n                  call(id, *(type)(id + 0x50));\n                  id = id;\n                }\n              }else{\n                id = id;\n                if(id <= id){\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = id + -0x28;\n                  }while(id <= id);\n                }\n                id = id + 0x28;\n                if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n                  id = id + id;\n                  do{\n                    id = call(id, (type)id);\n                    if(id != 0)break;\n                    call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                    id = (type)id >> 3;\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id * -0x3333333333333333 < (type)id);\n                }\n              }\n              break;\n            case str:\n              call(id, id, (type)id);\n              id[(type)id] = 0;\n          }\n          id = id + 1;\n          id = id + -1;\n        }while(id != 0);\n      }\n      id = id;\n      if((type)id == 1)goto lbl;\n      id = id + 1;\n      id = id;\n    }while(id != id);\n  }\n  id = (type)str[(type)(type)id[id] + 0x2c];\n  if(str[(type)(type)id[id] + 0x2c] != str){\n    id = str + (type)(type)id[id] + 0x2c;\n    id = id + -(type)id;\n    id = (type)(0x50 - (type)id);\n    do{\n      id = id;\n      id = id[1];\n      id = id;\n      if(id != str){\n        id = id;\n        if(id == str){\n          call(id, id, (type)id);\n          id[(type)id] = 0;\n        }elseif(id == str){\n          id = (type)call(id, id, id, 0x28, id);\n          if(id == (type)0x0){\n            call(id, 0x2000, str, id);\n            if(*(type)(id + 0x30) != (type)0x0){\n              call(id, *(type)(id + 0x50));\n            }\n          }else{\n            id = id;\n            if(id <= id){\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = id + -0x28;\n              }while(id <= id);\n            }\n            id = id + 0x28;\n            if(((type)id - (type)id >> 3) * -0x3333333333333333 < (type)id){\n              id = id + (type)id;\n              do{\n                id = call(id, (type)id);\n                if(id != 0)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, (type)id & 0xffffffff, id);\n                id = (type)id >> 3;\n                id = id + 0x28;\n                id = id + 0x28;\n              }while(id * -0x3333333333333333 < (type)id);\n            }\n          }\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n      id = id;\n    }while(id != 0);\n  }\n  id = 0;\n  if(id < 0xb){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.671875,
          "base_ppl": 1.6640625,
          "pr_ppl": 1.6640625,
          "source_ast_ppl": 2.078125,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.0,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = (type)call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6796875,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.796875,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 2.265625,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  id = call(id);\n  id = id + id;\n  id = (type)call();\n  id = (type)call(id, id);\n  if(id == 0){\n    id = 1;\n    id = 0;\n  }else{\n    id = 0;\n    id = 1;\n    id = (type)0x0;\n    id = 0;\n    id = id;\n    do{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if(id != 10){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x2dfeUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n      lbl:\n      id = (type)(type)id[id];\n      id = (type)(type)id[id];\n      if((0xc3f6UL >> ((type)(type)id[id] & 0x3fU) & 1) == 0){\n        id = (type)(type)id[(type)id[id]];\n        if(id != 0){\n          id = id + (type)id[id];\n          do{\n            switch(id[1]){\n              case 0:\n                call(id, id, id);\n                id[id] = str;\n                break;\n              case 1:\n                id = id;\n                break;\n              case 2:\n                id = (type)id - (type)id;\n                break;\n              case 3:\n                id = (type)call(id, id, (type)id, 0x28, id);\n                id = id;\n                if(id != (type)0x0){\n                  do{\n                    id = id;\n                    id = id + -0x28;\n                    if(id < id)break;\n                    id = call(id, id);\n                  }while(id == 0);\n                  id = id + (0x28 - (type)id);\n                  do{\n                    id = id;\n                    if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n                    id = call(id + 0x28, id);\n                    id = id + 0x28;\n                    id = id + 0x28;\n                  }while(id == 0);\n                  if(id <= id){\n                    id = *(type)(id + 0x58);\n                    do{\n                      id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n                      *(type)(id + 0x14) = id;\n                      *(type)(id + 0x28) = id;\n                      *(type)(id + 0x1c) = id;\n                      id = id + 0x28;\n                    }while(id <= id);\n                  }\n                }\n                break;\n              case 4:\n                if(*id != 0){\n                  id = *id - 0x30;\n                  if(~(type)id / 10 < id){\n                    id = id + 1;\n                    goto lbl;\n                  }\n                  id = (type)id + id * 10;\n                }\n                break;\n              case 5:\n                id = 0;\n            }\n            id = id + 1;\n            id = id + -1;\n          }while(id != 0);\n        }\n      }\n      if(id == 1)goto lbl;\n      id = id + 1;\n    }while(id != id);\n  }\n  id = (type)(type)id[(type)id[id]];\n  id = id;\n  if(id[(type)id[id]] != str){\n    id = id + (type)id[id];\n    do{\n      if((id[1] == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        do{\n          id = id;\n          id = id + -0x28;\n          if(id < id)break;\n          id = call(id, id);\n        }while(id == 0);\n        id = id + (0x28 - (type)id);\n        do{\n          id = id;\n          if((type)id <= ((type)id >> 3) * -0x3333333333333333)break;\n          id = call(id + 0x28, id);\n          id = id + 0x28;\n          id = id + 0x28;\n        }while(id == 0);\n        if(id <= id){\n          id = *(type)(id + 0x58);\n          do{\n            id = *(type)(id + (type)*(type)(id + 0x24) * 8);\n            *(type)(id + 0x14) = id;\n            *(type)(id + 0x28) = id;\n            *(type)(id + 0x1c) = id;\n            id = id + 0x28;\n          }while(id <= id);\n        }\n      }\n      id = id + 1;\n      id = id + -1;\n    }while(id != 0);\n  }\n  lbl:\n  if((id < 0xb) || (id = 0id != id)){\n    lbl:\n    id = 5;\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)(id + 0x400), str, (type)id - (type)id, (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6796875,
          "base_ppl": 1.796875,
          "pr_ppl": 1.796875,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 2.265625,
          "pr_ast_ppl": 2.265625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 + 1];\n  type id[64 + 1];\n  type *id = null;\n  type id = 0;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = call(id, id);\n  type *id = id;\n  type id;\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(!id){\n            call(id, (id), str, id);\n            if(id->id.id)call(id, id->id);\n          }else{\n            type *id = id;\n            while(id >= id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              type *id = id->id[id->id];\n              call(id->id, (id->id), str, (type)id, id);\n              id++;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 5:\n        {\n          id = id;\n        }\n        break;\n        case 6:\n        {\n          id = id - id;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(!id){\n              call(id, (id), str, id);\n              if(id->id.id)call(id, id->id);\n            }else{\n              type *id = id;\n              while(id >= id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                type *id = id->id[id->id];\n                call(id->id, (id->id), str, (type)id, id);\n                id++;\n              }\n            }\n          }\n          break;\n          case 4:\n          {\n            call(id, id, id);\n            id[id] = str;\n          }\n          break;\n          case 6:\n          {\n            id = id - id;\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, (id), str, id, (type)id, (type)(id - id), id, *id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[8192];\n  type id;\n  type *id;\n  type id[79];\n  type id[9];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + (type)id;\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)*(type)(id + (type)id * 2);\n    id = (id) * (type)(id + (type)id * 2);\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] + 0x2c];\n      id = &id + (type)(type)id[id];\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id == (type)0x0){\n              call(id, 0x2000, str, id);\n              if(*(type)(id + 0x30) != 0){\n                call(id, *(type)(id + 0x50));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id + -0x28;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id;\n              }\n            }\n            break;\n          case 4:\n            call(id, id, id);\n            id[id] = 0;\n            break;\n          case 5:\n            id = id;\n            break;\n          case 6:\n            id = (type)id - (type)id;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] + 0x2c];\n    id = &id + (type)(type)id[id];\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = call(id, id, (type)id, 0x28, id);\n        id = id;\n        if(id == (type)0x0){\n          call(id, 0x2000, str, id);\n          if(*(type)(id + 0x30) != 0){\n            call(id, *(type)(id + 0x50));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id + -0x28;\n          }\n          while(bool){\n            id = id + 0x28;\n            id = bool;\n            if(((type)id - (type)id) / 0x28 < (type)id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = 0;\n      }elseif(id == str){\n        id = (type)id - (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, (type)id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[8192];\n  type id;\n  type *id;\n  type id[79];\n  type id[9];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + (type)id;\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)*(type)(id + (type)id * 2);\n    id = (id) * (type)(id + (type)id * 2);\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)(&id)[id];\n    if(id[id] != str){\n      id = (type)str[(type)(type)(type)id[id] + 0x2c];\n      id = &id + (type)(type)id[id];\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = (type)call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id == (type)0x0){\n              call(id, 0x2000, str, id);\n              if(*(type)(id + 0x30) != 0){\n                call(id, *(type)(id + 0x50));\n              }\n            }else{\n              while(bool){\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id + -0x28;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n                id = id;\n              }\n            }\n            break;\n          case 4:\n            call(id, id, id);\n            id[id] = 0;\n            break;\n          case 5:\n            id = id;\n            break;\n          case 6:\n            id = (type)id - (type)id;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)str[(type)(type)(type)id[id] + 0x2c];\n    id = &id + (type)(type)id[id];\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if(id == str){\n        id = (type)call(id, id, (type)id, 0x28, id);\n        id = id;\n        if(id == (type)0x0){\n          call(id, 0x2000, str, id);\n          if(*(type)(id + 0x30) != 0){\n            call(id, *(type)(id + 0x50));\n          }\n        }else{\n          while(bool){\n            id = bool;\n            if(id <= id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id + -0x28;\n          }\n          while(bool){\n            id = id + 0x28;\n            id = bool;\n            if(((type)id - (type)id) / 0x28 < (type)id){\n              id = call(id, id);\n              id = id == 0;\n            }\n            if(!id)break;\n            call((type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x4c) * 8) + 0xc4), 0x41, str, id & 0xffffffff, id);\n            id = id;\n          }\n        }\n      }elseif(id == str){\n        call(id, id, id);\n        id[id] = 0;\n      }elseif(id == str){\n        id = (type)id - (type)id;\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, 0x2000, str, (type)id, id, (type)id - (type)id, id, (id) * id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.671875,
          "base_ppl": 1.6015625,
          "pr_ppl": 1.6015625,
          "source_ast_ppl": 2.078125,
          "base_ast_ppl": 1.9921875,
          "pr_ast_ppl": 1.984375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id){\n  type *id = (type)id;\n  type id = call(id);\n  type id = id;\n  type id[8 * 4 + 1];\n  type id = 0;\n  type *id = null;\n  type id = 0;\n  type id = 1024 + id;\n  type *id = null;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type *id = null;\n  type id;\n  id = call(id);\n  id = call(id, id);\n  {\n    id = id;\n  }\n  {\n    type id;\n    type id;\n    type *id;\n    type id;\n    type *id;\n    if(id == id)goto lbl;\n    if(id == 0)goto lbl;\n    lbl:\n    id = id + id[id];\n    id = id[id];\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + id - 1;\n      while(1){\n        if(id < id)break;\n        id = id + ((id - id) >> 1);\n        if((*id) < *id)id = id - 1;elseif((*id) > *id)id = id + 1;else{\n          id = (type)(id - id);\n          goto lbl;\n        }\n      }\n      id = id;\n      id = id;\n    }\n    id = id[id];\n    if(id > 0){\n      type *id = id;\n      type *id;\n      type *id = id + (id << 1) - 2;\n      while(1){\n        if(id < id)break;\n        id = id + (((id - id) >> 1) & ~1);\n        if((*id) < id[0])id = id - 2;elseif((*id) > id[1])id = id + 2;else{\n          id = (type)((id - id) >> 1);\n          goto lbl;\n        }\n      }\n      id = id;\n    }\n    lbl:\n    id = id[id];\n    id = id[id];\n    if(id[id] == 0)goto lbl;\n    id = id + id[id];\n    id = (type)*id++;\n    while(id-- > 0){\n      switch(*id++){\n        case 0:\n        {\n          call(id, id, id);\n          id[id] = str;\n        }\n        break;\n        case 1:\n        {\n          id = id;\n        }\n        break;\n        case 2:\n        {\n          id = id - id;\n        }\n        break;\n        case 3:\n        {\n          type *id = call(id, id, id, (id), &id);\n          if(id){\n            type *id = id, *id = id;\n            type *id = id - 1;\n            while(id >= id && call(id->id, id) == 0){\n              id = id;\n              id--;\n            }\n            id = id + 1;\n            while(id - id < id && call(id->id, id) == 0){\n              id = id;\n              id++;\n            }\n            for(id = id;  id <= id; id++){\n              id->id[id->id]->id = id;\n              id->id[id->id]->id.id = id;\n              id->id[id->id]->id.id = id;\n            }\n          }\n        }\n        break;\n        case 4:\n        {\n          if((*id) != str){\n            type id = (*id) - str;\n            if(id <= (id - id) / 10){\n              id = 10 * id + id;\n            }else{\n              {\n                id++;\n                goto lbl;\n              }\n            }\n          }\n        }\n        break;\n        case 5:\n        {\n          id = 0;\n        }\n        break;\n      }\n    }\n    lbl:\n    if(id == 0)goto lbl;\n    if(++id != id)goto lbl;\n    lbl:\n    {\n    }\n    if(id == id){\n      type *id = id + id[id];\n      type id = (type)*id++;\n      while(id-- > 0){\n        switch(*id++){\n          case 3:\n          {\n            type *id = call(id, id, id, (id), &id);\n            if(id){\n              type *id = id, *id = id;\n              type *id = id - 1;\n              while(id >= id && call(id->id, id) == 0){\n                id = id;\n                id--;\n              }\n              id = id + 1;\n              while(id - id < id && call(id->id, id) == 0){\n                id = id;\n                id++;\n              }\n              for(id = id;  id <= id; id++){\n                id->id[id->id]->id = id;\n                id->id[id->id]->id.id = id;\n                id->id[id->id]->id.id = id;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  if(id < 11 || id != id){\n    if(id->id.id){\n      call(id, id, str, (type)(id - id), (type)(id - id), (type)(id - id), id);\n      call(id, id->id);\n    }\n    id = id;\n  }\n  if(id)call(id);\n  if(id)call(id);\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + 0x400;\n  id = id + id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id + (type)(type)(type)id[id] + 1;\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id != (type)0x0){\n              while(bool){\n                id = id + -0x28;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id + 0x28){\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n              }\n            }\n            break;\n          case 4:\n            if(*id != 0){\n              if((-call(*id - 0x30) - 1) / 10 < id){\n                id = id + 1;\n                goto lbl;\n              }\n              id = id * 10 + call(*id - 0x30);\n            }\n            break;\n          case 5:\n            id = 0;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id + (type)(type)(type)id[id] + 1;\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        while(bool){\n          id = id + -0x28;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id + 0x28;\n          id = bool;\n          if(((type)id - (type)id) / 0x28 < (type)id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id + 0x28){\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)id, str, (type)id - (type)id, (type)id - (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id,  id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type id;\n  type id[40];\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  id = id;\n  id = id;\n  id = id;\n  id = id;\n  id = call(id);\n  id = id;\n  id = 0;\n  id = 0;\n  id = (type)0x0;\n  id = 0;\n  id = id + 0x400;\n  id = id + id;\n  id = (type)call((type)id);\n  id = (type)call(id, id);\n  id = 1;\n  for(; id != id; id = id + 1){\n    id = id + (type)(type)id[id];\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id + (type)id + -1;\n      id = id;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1);\n        if(*id < *id){\n          id = id + -1;\n        }else{\n          if(*id <= *id){\n            id = ((type)id - (type)id) + id;\n            goto lbl;\n          }\n          id = id + 1;\n        }\n      }\n      id = id + id;\n      id = id + id;\n    }\n    id = (type)(type)id[id];\n    if(0 < id){\n      id = id;\n      id = id + (type)(id << 1) + -2;\n      while(id <= id){\n        id = id + ((type)id - (type)id >> 1 & 0xfffffffffffffffe);\n        if(*id < *id){\n          id = id + -2;\n        }else{\n          if(*id <= id[1]){\n            id = (type)((type)id - (type)id >> 1) + id;\n            goto lbl;\n          }\n          id = id + 2;\n        }\n      }\n      id = id + id;\n    }\n    lbl:\n    id = (type)(type)id[id];\n    id = (type)(type)id[id];\n    if(id[id] != str){\n      id = (type)(type)id[(type)(type)id[id]];\n      id = id + (type)(type)(type)id[id] + 1;\n      while(id = id + -1id != 0){\n        id = id + 1;\n        id = *id;\n        id = id;\n        id = id;\n        switch(id){\n          case 0:\n            call(id, id, id);\n            id[id] = str;\n            break;\n          case 1:\n            id = id;\n            break;\n          case 2:\n            id = (type)id - (type)id;\n            break;\n          case 3:\n            id = (type)call(id, id, (type)id, 0x28, id);\n            id = id;\n            if(id != (type)0x0){\n              while(bool){\n                id = id + -0x28;\n                id = bool;\n                if(id <= id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              while(bool){\n                id = id + 0x28;\n                id = bool;\n                if(((type)id - (type)id) / 0x28 < (type)id){\n                  id = call(id, id);\n                  id = id == 0;\n                }\n                if(!id)break;\n                id = id;\n              }\n              for(id = id;  id <= id; id = id + 0x28){\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n                *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n              }\n            }\n            break;\n          case 4:\n            if(*id != 0){\n              if((-call(*id - 0x30) - 1) / 10 < id){\n                id = id + 1;\n                goto lbl;\n              }\n              id = id * 10 + call(*id - 0x30);\n            }\n            break;\n          case 5:\n            id = 0;\n        }\n      }\n    }\n    if(id == 0)goto lbl;\n  }\n  if(id == id){\n    id = (type)(type)id[(type)(type)id[id]];\n    id = id + (type)(type)(type)id[id] + 1;\n    while(id = id + -1id != 0){\n      id = id + 1;\n      id = *id;\n      id = id;\n      id = id;\n      if((id == str) && (id = (type)call(id, id, (type)id, 0x28, id)id = idid != (type)0x0)){\n        while(bool){\n          id = id + -0x28;\n          id = bool;\n          if(id <= id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        while(bool){\n          id = id + 0x28;\n          id = bool;\n          if(((type)id - (type)id) / 0x28 < (type)id){\n            id = call(id, id);\n            id = id == 0;\n          }\n          if(!id)break;\n          id = id;\n        }\n        for(id = id;  id <= id; id = id + 0x28){\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x14) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x28) = id;\n          *(type)(*(type)(*(type)(id + 0x58) + (type)*(type)(id + 0x24) * 8) + 0x1c) = id;\n        }\n      }\n    }\n  }\n  lbl:\n  if((id < 0xb) || (id != id)){\n    if(*(type)(id + 0x30) != 0){\n      call(id, (type)id, str, (type)id - (type)id, (type)id - (type)id, call((type)id - (type)id), id);\n      call(id, *(type)(id + 0x50));\n    }\n    id = 5;\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.6796875,
          "base_ppl": 1.6171875,
          "pr_ppl": 1.609375,
          "source_ast_ppl": 2.28125,
          "base_ast_ppl": 1.9296875,
          "pr_ast_ppl": 1.9375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces type mismatches and unnecessary casts, moving away from the Source Code structure. It also removes meaningful comments and renames variables inconsistently, which further deviates from the original code's clarity and intent.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = id - 1900;\n              }\n              break;\n            }\n          case 16:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 17:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 44)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  44;\n  id != id\n  {\n    type id[1024];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.453125,
          "base_ppl": 2.046875,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 2.453125,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces type casting and pointer arithmetic that are not present in the Source Code, which makes it less aligned with the original structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = id - 1900;\n              }\n              break;\n            }\n          case 16:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 17:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 44)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  44;\n  id != id\n  {\n    type id[1024];\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id[1032];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x2d){\n        id = (type)*(type)(id + (type)id * 2) - 1;\n      }\n    }else{\n      id = (type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if((0xfffffffeefaU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      if((0x100000001f0eU >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        switch(*(type)(id + 0x102361 + id)){\n          case 0:\n            id = (type)*id + id * 10 + -0x30;\n            break;\n          case 1:\n            id = 0;\n            break;\n          case 2:\n            *(type)(id + 0xc) = id;\n            break;\n          case 3:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 0xb;\n            break;\n          case 0xf:\n            *(type)(id + 0x14) = id + -0x76c;\n            break;\n          case 0x10:\n            *(type)(id + 8) = id;\n            break;\n          case 0x11:\n            *(type)(id + 4) = id;\n        }\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if((id != id) || (id = 0id < str)){\n        if(id != (type)0x0){\n          call(id, 0x400, str, id & 0xffffffff, id & 0xffffffff, id);\n          call(id, id);\n        }\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.453125,
          "base_ppl": 2.046875,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 2.453125,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces pointer arithmetic and type casting that deviate from the Source Code's straightforward array indexing and switch-case structure. This makes Candidate B less aligned with the Source Code's structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                type id = ((((*(id)))) - str);\n                if(id >= 0 && id <= 9){\n                  id = 10 * id + id;\n                }\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                if(id < 70){\n                  id->id = 100 + id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 47)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  47;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5078125,
          "base_ppl": 2.015625,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.515625,
          "pr_ast_ppl": 2.53125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces unnecessary pointer arithmetic and type casting, which deviates from the clean and straightforward structure of Candidate A. Candidate A maintains the original structure and logic closer to the Source Code.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate B introduces artificial nesting and depth with the use of pointer dereferencing and additional type casting, making it less idiomatic and more machine-like compared to Candidate A.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                type id = ((((*(id)))) - str);\n                if(id >= 0 && id <= 9){\n                  id = 10 * id + id;\n                }\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                if(id < 70){\n                  id->id = 100 + id;\n                }else{\n                  id->id = id;\n                }\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = 0;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = 1;\n              }\n              break;\n            }\n          case 6:\n            {\n              {\n                id->id = 2;\n              }\n              break;\n            }\n          case 7:\n            {\n              {\n                id->id = 3;\n              }\n              break;\n            }\n          case 8:\n            {\n              {\n                id->id = 4;\n              }\n              break;\n            }\n          case 9:\n            {\n              {\n                id->id = 5;\n              }\n              break;\n            }\n          case 10:\n            {\n              {\n                id->id = 6;\n              }\n              break;\n            }\n          case 11:\n            {\n              {\n                id->id = 7;\n              }\n              break;\n            }\n          case 12:\n            {\n              {\n                id->id = 8;\n              }\n              break;\n            }\n          case 13:\n            {\n              {\n                id->id = 9;\n              }\n              break;\n            }\n          case 14:\n            {\n              {\n                id->id = 10;\n              }\n              break;\n            }\n          case 15:\n            {\n              {\n                id->id = 11;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 47)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  47;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = id[id];\n    id = (type)id;\n    id = (type)(type)id[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id[8200];\n  id = id + id;\n  id = 1;\n  id = 0;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0x30){\n        id = (type)*(type)(id + (type)(type)id * 2) - 1;\n      }\n    }else{\n      id = (type)(type)id;\n      id = str + (type)id[id];\n      id = (id) * (type)(id + id * 2);\n      if(id < 0x2f){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < id[id])break;\n              if(*id <= id[id]){\n                id = ((type)id - (type)id) + id;\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)(type)id[id];\n      if(str < (type)id[id]){\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n      }\n    }\n    lbl:\n    id = (&id)[id];\n    id = (type)id;\n    id = (type)(type)(&id)[id];\n    if((id != 0) && (id = id[id]id != str)){\n      id = 0;\n      do{\n        id = id;\n        switch(*(type)(id + 0x102311 + id)){\n          case 0:\n            id = (type)(type)(*id - 0x30U) + id * 10;\n            if(9 < call(*id - 0x30U)){\n              id = id;\n            }\n            break;\n          case 1:\n            if(id < 0x46){\n              *(type)(id + 0x14) = id + 100;\n            }else{\n              *(type)(id + 0x14) = id;\n            }\n            break;\n          case 2:\n            id = 0;\n            break;\n          case 3:\n            *(type)(id + 0xc) = id;\n            break;\n          case 4:\n            *(type)(id + 0x10) = 0;\n            break;\n          case 5:\n            *(type)(id + 0x10) = 1;\n            break;\n          case 6:\n            *(type)(id + 0x10) = 2;\n            break;\n          case 7:\n            *(type)(id + 0x10) = 3;\n            break;\n          case 8:\n            *(type)(id + 0x10) = 4;\n            break;\n          case 9:\n            *(type)(id + 0x10) = 5;\n            break;\n          case 10:\n            *(type)(id + 0x10) = 6;\n            break;\n          case 0xb:\n            *(type)(id + 0x10) = 7;\n            break;\n          case 0xc:\n            *(type)(id + 0x10) = 8;\n            break;\n          case 0xd:\n            *(type)(id + 0x10) = 9;\n            break;\n          case 0xe:\n            *(type)(id + 0x10) = 10;\n            break;\n          case 0xf:\n            *(type)(id + 0x10) = 0xb;\n        }\n        id = id;\n        id = id + 1;\n      }while((type)id != (type)id);\n    }\n    if((id == id) || (id = id + 1id == str)){\n      if(((id != id) || (id = 0id < str)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.5078125,
          "base_ppl": 2.015625,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 2.515625,
          "pr_ast_ppl": 2.53125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces incorrect type casting and pointer arithmetic, which deviates from the Source Code structure. Candidate A maintains the original structure and logic.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = id + 2;\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if((id != (type)0x0) && (id = *idid != -1)){\n    id = id + 2;\n    id = 0;\n    id = 0;\n    id = 8;\n    id = bool;\n    do{\n      id = 1;\n      id = bool;\n      switch(id){\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          id = bool;\n          id = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto lbl;\n        case 0x21:\n          break;\n        case def:\n          id = 1;\n          id = bool;\n          if(1 < id + 0xbfffffffffffffffU){\n            return 8;\n          }\n      }\n      if(!id){\n        return 8;\n      }\n      id = id + id;\n      id = id + 1;\n      id = *id;\n      id = id + 2;\n      id = id;\n    }while(id != -1);\n    if((id == 1 && id < 5) && (id < 4)){\n      *id = id;\n      id = 0;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.609375,
          "base_ppl": 1.6953125,
          "pr_ppl": 1.7265625,
          "source_ast_ppl": 4.40625,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.4375,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if ((param_1 != (long *)0x0) && (lVar7 = *param_1, lVar7 != -1)) {\n    param_1 = param_1 + 2;\n    uVar4 = 0;\n    uVar5 = 0;\n    uVar3 = 8;\n    bVar1 = true;\n    do {\n      bVar6 = 1;\n      bVar2 = false;\n      switch(lVar7) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n        bVar2 = true;\n        bVar6 = 0;\n        break;\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n        goto LAB_001011aa;\n      case 0x21:\n        break;\n      default:\n        bVar6 = 1;\n        bVar2 = false;\n        if (1 < lVar7 + 0xbfffffffffffffffU) {\n          return 8;\n        }\n      }\n      if (!bVar1) {\n        return 8;\n      }\n      uVar4 = uVar4 + bVar6;\n      uVar5 = uVar5 + 1;\n      lVar7 = *param_1;\n      param_1 = param_1 + 2;\n      bVar1 = bVar2;\n    } while (lVar7 != -1);\n    if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n      *param_2 = uVar5;\n      uVar3 = 0;\n    }\n  }\nLAB_001011aa:\n  return uVar3;\n}\n\n",
        "source_ast": "type id(type *id, type *id){\n  if(id == null || id[0].id == id)return id;\n  type id = 0;\n  type id = bool;\n  type id = bool;\n  type id = 0;\n  do{\n    type id;\n    for(id = 0;  id[id].id != id[id].id; ++id)if(id[id].id == id)return id;\n    if(!id)return id;\n    id = id[id].id;\n    id = id[id].id;\n    id = id[id].id;\n  }while(id[++id].id != id);\n  if(id > id || !id || id > 3)return id;\n  *id = id;\n  return id;\n}",
        "base_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if(id != (type)0x0){\n    id = *id;\n    if(id != -1){\n      id = 0;\n      id = 0;\n      id = 8;\n      id = bool;\n      do{\n        id = id + 2;\n        id = 1;\n        id = bool;\n        switch(id){\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 0xb:\n            id = bool;\n            id = 0;\n            break;\n          case 0xc:\n          case 0xd:\n          case 0xe:\n          case 0xf:\n          case 0x10:\n          case 0x11:\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          case 0x15:\n          case 0x16:\n          case 0x17:\n          case 0x18:\n          case 0x19:\n          case 0x1a:\n          case 0x1b:\n          case 0x1c:\n          case 0x1d:\n          case 0x1e:\n          case 0x1f:\n          case 0x20:\n            goto lbl;\n          case 0x21:\n            break;\n          case def:\n            id = 1;\n            id = bool;\n            if(1 < id + 0xbfffffffffffffffU)goto lbl;\n        }\n        if(!id)goto lbl;\n        id = id + id;\n        id = id + 1;\n        id = *id;\n        id = id;\n      }while(id != -1);\n      if((id == 1 && id < 5) && (id < 4)){\n        *id = id;\n        id = 0;\n      }\n    }\n    lbl:\n    ;\n  }\n  return id;\n}",
        "pr_ast": "type id( *id, type *id){\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  id = 0xb;\n  if((id != (type)0x0) && (id = *idid != -1)){\n    id = id + 2;\n    id = 0;\n    id = 0;\n    id = 8;\n    id = bool;\n    do{\n      id = 1;\n      id = bool;\n      switch(id){\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          id = bool;\n          id = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto lbl;\n        case 0x21:\n          break;\n        case def:\n          id = 1;\n          id = bool;\n          if(1 < id + 0xbfffffffffffffffU){\n            return 8;\n          }\n      }\n      if(!id){\n        return 8;\n      }\n      id = id + id;\n      id = id + 1;\n      id = *id;\n      id = id + 2;\n      id = id;\n    }while(id != -1);\n    if((id == 1 && id < 5) && (id < 4)){\n      *id = id;\n      id = 0;\n    }\n  }\n  lbl:\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.609375,
          "base_ppl": 1.6953125,
          "pr_ppl": 1.7265625,
          "source_ast_ppl": 4.40625,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.4375,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces a switch statement which was not present in the original source code. This structural change moves the code further away from the Source Code structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O3.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  long lVar8;\n  int *piVar9;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) {\nLAB_001013b5:\n        lVar8 = *param_3 - uVar3;\n        if (lVar8 == 0) {\n          return iVar6;\n        }\n        goto LAB_001013c8;\n      }\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar9 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar9 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar9,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013b5;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013e6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013e6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\n  lVar8 = *param_3 - uVar3;\n  if (lVar8 == 0) {\n    return 0;\n  }\nLAB_001013c8:\n  iVar4 = lzma_crc32(param_2 + uVar3,lVar8,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id)++] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = 0;\n        id->id = (id->id == 0 ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = 0;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (--id->id == 0 ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(4) - call(id->id.id, id->id.id)) & 3;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > 0){\n        --id->id;\n        if(id[(*id)++] != 0x00)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != 0)return id;\n      id->id = call(id + id, *id - id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id >> (id->id * 8)) & 0xFF) != id[(*id)++]){\n          idreturn id;\n        }\n      }while(++id->id < 4);\n      return id;\n    case def:\n      call(0);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id - id;\n    if(id > 0)id->id = call(id + id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return 10;\n  }\n  id = (type)(id + 0x4c);\n  id = (type)(id + 0x46);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case 0:\n        *id = id + 1;\n        id = 1;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        break;\n      case 1:\n        id = call(id, id, id, id, id);\n        if(id != 1){\n          lbl:\n          id = *id - id;\n          if(id == 0){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id + 0x46) != *(type)(id + 6)){\n          return 9;\n        }\n        *id = 0;\n        id = call(*(type)(id + 0x46) == 0) * 2 + 2;\n        break;\n      case 2:\n      case 3:\n        id = id + 0x48;\n        if(id != 2){\n          id = id + 0x4a;\n        }\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        id[0x4c] = 0;\n        id[0x4d] = 0;\n        if(*id == 2){\n          id = 3;\n          if(*(type)(id + 0x48) + 0x8000000000000003U < 0x8000000000000008){\n            return 9;\n          }\n        }else{\n          call(id + 0x24, *(type)(id + 0x48), *(type)(id + 0x4a));\n          if(*(type)(id + 2) < *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) < *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) < *(type)(id + 0x2a)){\n            return 9;\n          }\n          *id = *id + -1;\n          id = call(*id == 0) * 2 + 2;\n        }\n        break;\n      case 4:\n        id = call(*(type)(id + 0x28), *(type)(id + 0x2a));\n        id = call(-id & 3);\n        *(type)(id + 0x4c) = id;\n        *id = 5;\n        goto lbl;\n      case 5:\n        id = *id;\n        lbl:\n        if(id == 0){\n          if(*(type)(id + 2) != *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) != *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) != *(type)(id + 0x2a)){\n            return 9;\n          }\n          call(id + 10, 10);\n          call(id + 0x2c, 10);\n          id = call(10);\n          id = call(id + 10, id + 0x2c, (type)id);\n          if(id != 0){\n            return 9;\n          }\n          id = call(id + id, *id - id, id[0x4e]);\n          id[0x4e] = id;\n          *id = 6;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return 0;\n            }\n            id = id[0x4c];\n            id = id[0x4e];\n            *id = id + 1;\n            if(*(type)(id + id) != (type)(id >> (call(id << 3) & 0x1f)))break;\n            id = *id;\n            *id = id + 1;\n            if(3 < id + 1){\n              return 1;\n            }\n          }\n          return 9;\n        }\n        *id = id - 1;\n        id = *id;\n        *id = id + 1;\n        id = 5;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        goto lbl;\n      case 6:\n        goto lbl;\n      case def:\n        return 0xb;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = 0;\n  id = *id - id;\n  if(id == 0){\n    return 0;\n  }\n  lbl:\n  id = call(id + id, id, id[0x4e]);\n  id[0x4e] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return 10;\n  }\n  id = (type)(id + 0x4c);\n  id = (type)(id + 0x46);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case 0:\n        *id = id + 1;\n        id = 1;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        break;\n      case 1:\n        id = call(id, id, id, id, id);\n        if(id != 1){\n          lbl:\n          id = *id - id;\n          if(id == 0){\n            return id;\n          }\n          goto lbl;\n        }\n        if(*(type)(id + 0x46) != *(type)(id + 6)){\n          return 9;\n        }\n        *id = 0;\n        id = call(*(type)(id + 0x46) == 0) * 2 + 2;\n        break;\n      case 2:\n      case 3:\n        id = id + 0x48;\n        if(id != 2){\n          id = id + 0x4a;\n        }\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        id[0x4c] = 0;\n        id[0x4d] = 0;\n        if(*id == 2){\n          id = 3;\n          if(*(type)(id + 0x48) + 0x8000000000000003U < 0x8000000000000008){\n            return 9;\n          }\n        }else{\n          call(id + 0x24, *(type)(id + 0x48), *(type)(id + 0x4a));\n          if(*(type)(id + 2) < *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) < *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) < *(type)(id + 0x2a)){\n            return 9;\n          }\n          *id = *id + -1;\n          id = call(*id == 0) * 2 + 2;\n        }\n        break;\n      case 4:\n        id = call(*(type)(id + 0x28), *(type)(id + 0x2a));\n        id = call(-id & 3);\n        *(type)(id + 0x4c) = id;\n        *id = 5;\n        if(id == 0)goto lbl;\n        lbl:\n        *id = id - 1;\n        id = *id;\n        *id = id + 1;\n        id = 5;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        goto lbl;\n      case 5:\n        id = *id;\n        if(id != 0)goto lbl;\n        lbl:\n        if(*(type)(id + 2) != *(type)(id + 0x24)){\n          return 9;\n        }\n        if(*(type)(id + 4) != *(type)(id + 0x26)){\n          return 9;\n        }\n        if(*(type)(id + 8) != *(type)(id + 0x2a)){\n          return 9;\n        }\n        call(id + 10, 10);\n        call(id + 0x2c, 10);\n        id = call(10);\n        id = call(id + 10, id + 0x2c, (type)id);\n        if(id != 0){\n          return 9;\n        }\n        id = call(id + id, *id - id, id[0x4e]);\n        id[0x4e] = id;\n        *id = 6;\n      case 6:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return 0;\n          }\n          id = id[0x4c];\n          id = id[0x4e];\n          *id = id + 1;\n          if(*(type)(id + id) != (type)(id >> (call(id << 3) & 0x1f)))break;\n          id = *id;\n          *id = id + 1;\n          if(3 < id + 1){\n            return 1;\n          }\n        }\n        return 9;\n      case def:\n        return 0xb;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = 0;\n  id = *id - id;\n  if(id == 0){\n    return 0;\n  }\n  lbl:\n  id = call(id + id, id, id[0x4e]);\n  id[0x4e] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.046875,
          "base_ppl": 1.8359375,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 2.96875,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.484375,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B introduces labeled jumps and artificial nesting, making the control flow less intuitive and harder to follow compared to the cleaner structure in Candidate A, which uses a more straightforward loop and conditional logic.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more closely with the Source Code structure by maintaining the original switch-case control flow and reducing unnecessary goto statements. It preserves the logical sequence and readability of the original code.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B introduces a more structured and readable control flow by replacing the goto statement with an if-else condition, which aligns better with idiomatic design principles. The nested while loop is also clearly defined, making the code easier to follow and understand.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-xz_lzma_index_hash_decode-O2.so",
        "function": "lzma_index_hash_decode",
        "source_code": "extern LZMA_API(lzma_ret)\nlzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,\n\t\tsize_t *in_pos, size_t in_size)\n{\n\t// Catch zero input buffer here, because in contrast to Index encoder\n\t// and decoder functions, applications call this function directly\n\t// instead of via lzma_code(), which does the buffer checking.\n\tif (*in_pos >= in_size)\n\t\treturn LZMA_BUF_ERROR;\n\n\t// NOTE: This function has many similarities to index_encode() and\n\t// index_decode() functions found from index_encoder.c and\n\t// index_decoder.c. See the comments especially in index_encoder.c.\n\tconst size_t in_start = *in_pos;\n\tlzma_ret ret = LZMA_OK;\n\n\twhile (*in_pos < in_size)\n\tswitch (index_hash->sequence) {\n\tcase SEQ_BLOCK:\n\t\t// Check the Index Indicator is present.\n\t\tif (in[(*in_pos)++] != INDEX_INDICATOR)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tindex_hash->sequence = SEQ_COUNT;\n\t\tbreak;\n\n\tcase SEQ_COUNT: {\n\t\tret = lzma_vli_decode(&index_hash->remaining,\n\t\t\t\t&index_hash->pos, in, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\t// The count must match the count of the Blocks decoded.\n\t\tif (index_hash->remaining != index_hash->blocks.count)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\t// Handle the special case when there are no Blocks.\n\t\tindex_hash->sequence = index_hash->remaining == 0\n\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\tbreak;\n\t}\n\n\tcase SEQ_UNPADDED:\n\tcase SEQ_UNCOMPRESSED: {\n\t\tlzma_vli *size = index_hash->sequence == SEQ_UNPADDED\n\t\t\t\t? &index_hash->unpadded_size\n\t\t\t\t: &index_hash->uncompressed_size;\n\n\t\tret = lzma_vli_decode(size, &index_hash->pos,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\tgoto out;\n\n\t\tret = LZMA_OK;\n\t\tindex_hash->pos = 0;\n\n\t\tif (index_hash->sequence == SEQ_UNPADDED) {\n\t\t\tif (index_hash->unpadded_size < UNPADDED_SIZE_MIN\n\t\t\t\t\t|| index_hash->unpadded_size\n\t\t\t\t\t\t> UNPADDED_SIZE_MAX)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tindex_hash->sequence = SEQ_UNCOMPRESSED;\n\t\t} else {\n\t\t\t// Update the hash.\n\t\t\thash_append(&index_hash->records,\n\t\t\t\t\tindex_hash->unpadded_size,\n\t\t\t\t\tindex_hash->uncompressed_size);\n\n\t\t\t// Verify that we don't go over the known sizes. Note\n\t\t\t// that this validation is simpler than the one used\n\t\t\t// in lzma_index_hash_append(), because here we know\n\t\t\t// that values in index_hash->blocks are already\n\t\t\t// validated and we are fine as long as we don't\n\t\t\t// exceed them in index_hash->records.\n\t\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t\t< index_hash->records.blocks_size\n\t\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t\t< index_hash->records.uncompressed_size\n\t\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t\t< index_hash->records.index_list_size)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\t// Check if this was the last Record.\n\t\t\tindex_hash->sequence = --index_hash->remaining == 0\n\t\t\t\t\t? SEQ_PADDING_INIT : SEQ_UNPADDED;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase SEQ_PADDING_INIT:\n\t\tindex_hash->pos = (LZMA_VLI_C(4) - index_size_unpadded(\n\t\t\t\tindex_hash->records.count,\n\t\t\t\tindex_hash->records.index_list_size)) & 3;\n\n\t\tindex_hash->sequence = SEQ_PADDING;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_PADDING:\n\t\tif (index_hash->pos > 0) {\n\t\t\t--index_hash->pos;\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// Compare the sizes.\n\t\tif (index_hash->blocks.blocks_size\n\t\t\t\t!= index_hash->records.blocks_size\n\t\t\t\t|| index_hash->blocks.uncompressed_size\n\t\t\t\t!= index_hash->records.uncompressed_size\n\t\t\t\t|| index_hash->blocks.index_list_size\n\t\t\t\t!= index_hash->records.index_list_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the hashes and compare them.\n\t\tlzma_check_finish(&index_hash->blocks.check, LZMA_CHECK_BEST);\n\t\tlzma_check_finish(&index_hash->records.check, LZMA_CHECK_BEST);\n\t\tif (memcmp(index_hash->blocks.check.buffer.u8,\n\t\t\t\tindex_hash->records.check.buffer.u8,\n\t\t\t\tlzma_check_size(LZMA_CHECK_BEST)) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Finish the CRC32 calculation.\n\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t*in_pos - in_start, index_hash->crc32);\n\n\t\tindex_hash->sequence = SEQ_CRC32;\n\t\tFALLTHROUGH;\n\n\tcase SEQ_CRC32:\n\t\tdo {\n\t\t\tif (*in_pos == in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\tif (((index_hash->crc32 >> (index_hash->pos * 8))\n\t\t\t\t\t& 0xFF) != in[(*in_pos)++]) {\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\t\t\t\treturn LZMA_DATA_ERROR;\n#endif\n\t\t\t}\n\n\t\t} while (++index_hash->pos < 4);\n\n\t\treturn LZMA_STREAM_END;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\nout:\n\t// Update the CRC32.\n\t//\n\t// Avoid null pointer + 0 (undefined behavior) in \"in + in_start\".\n\t// In such a case we had no input and thus in_used == 0.\n\t{\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tif (in_used > 0)\n\t\t\tindex_hash->crc32 = lzma_crc32(in + in_start,\n\t\t\t\t\tin_used, index_hash->crc32);\n\t}\n\n\treturn ret;\n}\n",
        "function_base": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      goto joined_r0x0010130f;\n    case 5:\n      uVar7 = *puVar1;\njoined_r0x0010130f:\n      if (uVar7 == 0) {\n        if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        lzma_check_finish(param_1 + 10,10);\n        lzma_check_finish(param_1 + 0x2c,10);\n        uVar5 = lzma_check_size(10);\n        iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n        if (iVar6 != 0) {\n          return 9;\n        }\n        iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n        param_1[0x4e] = iVar6;\n        *param_1 = 6;\nswitchD_0010121f_caseD_6:\n        while( true ) {\n          uVar3 = *param_3;\n          if (uVar3 == param_4) {\n            return 0;\n          }\n          iVar6 = param_1[0x4c];\n          uVar5 = param_1[0x4e];\n          *param_3 = uVar3 + 1;\n          if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n          uVar3 = *puVar1;\n          *puVar1 = uVar3 + 1;\n          if (3 < uVar3 + 1) {\n            return 1;\n          }\n        }\n        return 9;\n      }\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 6:\n      goto switchD_0010121f_caseD_6;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "function_pr": "\nint lzma_index_hash_decode(int *param_1,long param_2,ulong *param_3,ulong param_4)\n\n{\n  ulong *puVar1;\n  long *plVar2;\n  ulong uVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  ulong uVar7;\n  int *piVar8;\n  \n  uVar3 = *param_3;\n  if (param_4 <= uVar3) {\n    return 10;\n  }\n  puVar1 = (ulong *)(param_1 + 0x4c);\n  plVar2 = (long *)(param_1 + 0x46);\n  iVar6 = *param_1;\n  uVar7 = uVar3;\n  do {\n    switch(iVar6) {\n    case 0:\n      *param_3 = uVar7 + 1;\n      iVar6 = 1;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      break;\n    case 1:\n      iVar6 = lzma_vli_decode(plVar2,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      if (*(long *)(param_1 + 0x46) != *(long *)(param_1 + 6)) {\n        return 9;\n      }\n      *puVar1 = 0;\n      iVar6 = (uint)(*(long *)(param_1 + 0x46) == 0) * 2 + 2;\n      break;\n    case 2:\n    case 3:\n      piVar8 = param_1 + 0x48;\n      if (iVar6 != 2) {\n        piVar8 = param_1 + 0x4a;\n      }\n      iVar6 = lzma_vli_decode(piVar8,puVar1,param_2,param_3,param_4);\n      if (iVar6 != 1) goto LAB_001013a7;\n      param_1[0x4c] = 0;\n      param_1[0x4d] = 0;\n      if (*param_1 == 2) {\n        iVar6 = 3;\n        if (*(long *)(param_1 + 0x48) + 0x8000000000000003U < 0x8000000000000008) {\n          return 9;\n        }\n      }\n      else {\n        hash_append(param_1 + 0x24,*(long *)(param_1 + 0x48),*(undefined8 *)(param_1 + 0x4a));\n        if (*(ulong *)(param_1 + 2) < *(ulong *)(param_1 + 0x24)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 4) < *(ulong *)(param_1 + 0x26)) {\n          return 9;\n        }\n        if (*(ulong *)(param_1 + 8) < *(ulong *)(param_1 + 0x2a)) {\n          return 9;\n        }\n        *plVar2 = *plVar2 + -1;\n        iVar6 = (uint)(*plVar2 == 0) * 2 + 2;\n      }\n      break;\n    case 4:\n      iVar6 = index_size_unpadded(*(undefined8 *)(param_1 + 0x28),*(undefined8 *)(param_1 + 0x2a));\n      uVar7 = (ulong)(-iVar6 & 3);\n      *(ulong *)(param_1 + 0x4c) = uVar7;\n      *param_1 = 5;\n      if (uVar7 == 0) goto LAB_001013d6;\nLAB_00101315:\n      *puVar1 = uVar7 - 1;\n      uVar7 = *param_3;\n      *param_3 = uVar7 + 1;\n      iVar6 = 5;\n      if (*(char *)(param_2 + uVar7) != '\\0') {\n        return 9;\n      }\n      goto LAB_00101201;\n    case 5:\n      uVar7 = *puVar1;\n      if (uVar7 != 0) goto LAB_00101315;\nLAB_001013d6:\n      if (*(long *)(param_1 + 2) != *(long *)(param_1 + 0x24)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 4) != *(long *)(param_1 + 0x26)) {\n        return 9;\n      }\n      if (*(long *)(param_1 + 8) != *(long *)(param_1 + 0x2a)) {\n        return 9;\n      }\n      lzma_check_finish(param_1 + 10,10);\n      lzma_check_finish(param_1 + 0x2c,10);\n      uVar5 = lzma_check_size(10);\n      iVar6 = bcmp(param_1 + 10,param_1 + 0x2c,(ulong)uVar5);\n      if (iVar6 != 0) {\n        return 9;\n      }\n      iVar6 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n      param_1[0x4e] = iVar6;\n      *param_1 = 6;\n    case 6:\n      while( true ) {\n        uVar3 = *param_3;\n        if (uVar3 == param_4) {\n          return 0;\n        }\n        iVar6 = param_1[0x4c];\n        uVar5 = param_1[0x4e];\n        *param_3 = uVar3 + 1;\n        if (*(char *)(param_2 + uVar3) != (char)(uVar5 >> ((byte)(iVar6 << 3) & 0x1f))) break;\n        uVar3 = *puVar1;\n        *puVar1 = uVar3 + 1;\n        if (3 < uVar3 + 1) {\n          return 1;\n        }\n      }\n      return 9;\n    default:\n      return 0xb;\n    }\n    *param_1 = iVar6;\nLAB_00101201:\n    uVar7 = *param_3;\n  } while (uVar7 < param_4);\n  iVar6 = 0;\nLAB_001013a7:\n  if (*param_3 - uVar3 == 0) {\n    return iVar6;\n  }\n  iVar4 = lzma_crc32(param_2 + uVar3,*param_3 - uVar3,param_1[0x4e]);\n  param_1[0x4e] = iVar4;\n  return iVar6;\n}\n\n",
        "source_ast": "idtype id(type *id, type *id, type *id, type id){\n  if(*id >= id)return id;\n  type id = *id;\n  type id = id;\n  while(*id < id)switch(id->id){\n    case id:\n      if(id[(*id)++] != id)return id;\n      id->id = id;\n      break;\n    case id:\n      {\n        id = call(&id->id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        if(id->id != id->id.id)return id;\n        id = id;\n        id->id = 0;\n        id->id = (id->id == 0 ? id : id);\n        break;\n      }\n    case id:\n    case id:\n      {\n        type *id = (id->id == id ? &id->id : &id->id);\n        id = call(id, &id->id, id, id, id);\n        if(id != id)goto lbl;\n        id = id;\n        id->id = 0;\n        if(id->id == id){\n          if(id->id < id || id->id > id)return id;\n          id->id = id;\n        }else{\n          call(&id->id, id->id, id->id);\n          if(id->id.id < id->id.id || id->id.id < id->id.id || id->id.id < id->id.id)return id;\n          id->id = (--id->id == 0 ? id : id);\n        }\n        break;\n      }\n    case id:\n      id->id = (call(4) - call(id->id.id, id->id.id)) & 3;\n      id->id = id;\n      id;\n    case id:\n      if(id->id > 0){\n        --id->id;\n        if(id[(*id)++] != 0x00)return id;\n        break;\n      }\n      if(id->id.id != id->id.id || id->id.id != id->id.id || id->id.id != id->id.id)return id;\n      call(&id->id.id, id);\n      call(&id->id.id, id);\n      if(call(id->id.id.id.id, id->id.id.id.id, call(id)) != 0)return id;\n      id->id = call(id + id, *id - id, id->id);\n      id->id = id;\n      id;\n    case id:\n      do{\n        if(*id == id)return id;\n        if(((id->id >> (id->id * 8)) & 0xFF) != id[(*id)++]){\n          idreturn id;\n        }\n      }while(++id->id < 4);\n      return id;\n    case def:\n      call(0);\n      return id;\n  }\n  lbl:\n  {\n    type id = *id - id;\n    if(id > 0)id->id = call(id + id, id, id->id);\n  }\n  return id;\n}",
        "base_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return 10;\n  }\n  id = (type)(id + 0x4c);\n  id = (type)(id + 0x46);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case 0:\n        *id = id + 1;\n        id = 1;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        break;\n      case 1:\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        if(*(type)(id + 0x46) != *(type)(id + 6)){\n          return 9;\n        }\n        *id = 0;\n        id = call(*(type)(id + 0x46) == 0) * 2 + 2;\n        break;\n      case 2:\n      case 3:\n        id = id + 0x48;\n        if(id != 2){\n          id = id + 0x4a;\n        }\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        id[0x4c] = 0;\n        id[0x4d] = 0;\n        if(*id == 2){\n          id = 3;\n          if(*(type)(id + 0x48) + 0x8000000000000003U < 0x8000000000000008){\n            return 9;\n          }\n        }else{\n          call(id + 0x24, *(type)(id + 0x48), *(type)(id + 0x4a));\n          if(*(type)(id + 2) < *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) < *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) < *(type)(id + 0x2a)){\n            return 9;\n          }\n          *id = *id + -1;\n          id = call(*id == 0) * 2 + 2;\n        }\n        break;\n      case 4:\n        id = call(*(type)(id + 0x28), *(type)(id + 0x2a));\n        id = call(-id & 3);\n        *(type)(id + 0x4c) = id;\n        *id = 5;\n        goto lbl;\n      case 5:\n        id = *id;\n        lbl:\n        if(id == 0){\n          if(*(type)(id + 2) != *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) != *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) != *(type)(id + 0x2a)){\n            return 9;\n          }\n          call(id + 10, 10);\n          call(id + 0x2c, 10);\n          id = call(10);\n          id = call(id + 10, id + 0x2c, (type)id);\n          if(id != 0){\n            return 9;\n          }\n          id = call(id + id, *id - id, id[0x4e]);\n          id[0x4e] = id;\n          *id = 6;\n          lbl:\n          while(bool){\n            id = *id;\n            if(id == id){\n              return 0;\n            }\n            id = id[0x4c];\n            id = id[0x4e];\n            *id = id + 1;\n            if(*(type)(id + id) != (type)(id >> (call(id << 3) & 0x1f)))break;\n            id = *id;\n            *id = id + 1;\n            if(3 < id + 1){\n              return 1;\n            }\n          }\n          return 9;\n        }\n        *id = id - 1;\n        id = *id;\n        *id = id + 1;\n        id = 5;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        goto lbl;\n      case 6:\n        goto lbl;\n      case def:\n        return 0xb;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = 0;\n  lbl:\n  if(*id - id == 0){\n    return id;\n  }\n  id = call(id + id, *id - id, id[0x4e]);\n  id[0x4e] = id;\n  return id;\n}",
        "pr_ast": "type id(type *id,  id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = *id;\n  if(id <= id){\n    return 10;\n  }\n  id = (type)(id + 0x4c);\n  id = (type)(id + 0x46);\n  id = *id;\n  id = id;\n  do{\n    switch(id){\n      case 0:\n        *id = id + 1;\n        id = 1;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        break;\n      case 1:\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        if(*(type)(id + 0x46) != *(type)(id + 6)){\n          return 9;\n        }\n        *id = 0;\n        id = call(*(type)(id + 0x46) == 0) * 2 + 2;\n        break;\n      case 2:\n      case 3:\n        id = id + 0x48;\n        if(id != 2){\n          id = id + 0x4a;\n        }\n        id = call(id, id, id, id, id);\n        if(id != 1)goto lbl;\n        id[0x4c] = 0;\n        id[0x4d] = 0;\n        if(*id == 2){\n          id = 3;\n          if(*(type)(id + 0x48) + 0x8000000000000003U < 0x8000000000000008){\n            return 9;\n          }\n        }else{\n          call(id + 0x24, *(type)(id + 0x48), *(type)(id + 0x4a));\n          if(*(type)(id + 2) < *(type)(id + 0x24)){\n            return 9;\n          }\n          if(*(type)(id + 4) < *(type)(id + 0x26)){\n            return 9;\n          }\n          if(*(type)(id + 8) < *(type)(id + 0x2a)){\n            return 9;\n          }\n          *id = *id + -1;\n          id = call(*id == 0) * 2 + 2;\n        }\n        break;\n      case 4:\n        id = call(*(type)(id + 0x28), *(type)(id + 0x2a));\n        id = call(-id & 3);\n        *(type)(id + 0x4c) = id;\n        *id = 5;\n        if(id == 0)goto lbl;\n        lbl:\n        *id = id - 1;\n        id = *id;\n        *id = id + 1;\n        id = 5;\n        if(*(type)(id + id) != str){\n          return 9;\n        }\n        goto lbl;\n      case 5:\n        id = *id;\n        if(id != 0)goto lbl;\n        lbl:\n        if(*(type)(id + 2) != *(type)(id + 0x24)){\n          return 9;\n        }\n        if(*(type)(id + 4) != *(type)(id + 0x26)){\n          return 9;\n        }\n        if(*(type)(id + 8) != *(type)(id + 0x2a)){\n          return 9;\n        }\n        call(id + 10, 10);\n        call(id + 0x2c, 10);\n        id = call(10);\n        id = call(id + 10, id + 0x2c, (type)id);\n        if(id != 0){\n          return 9;\n        }\n        id = call(id + id, *id - id, id[0x4e]);\n        id[0x4e] = id;\n        *id = 6;\n      case 6:\n        while(bool){\n          id = *id;\n          if(id == id){\n            return 0;\n          }\n          id = id[0x4c];\n          id = id[0x4e];\n          *id = id + 1;\n          if(*(type)(id + id) != (type)(id >> (call(id << 3) & 0x1f)))break;\n          id = *id;\n          *id = id + 1;\n          if(3 < id + 1){\n            return 1;\n          }\n        }\n        return 9;\n      case def:\n        return 0xb;\n    }\n    *id = id;\n    lbl:\n    id = *id;\n  }while(id < id);\n  id = 0;\n  lbl:\n  if(*id - id == 0){\n    return id;\n  }\n  id = call(id + id, *id - id, id[0x4e]);\n  id[0x4e] = id;\n  return id;\n}",
        "metrics": {
          "source_ppl": 2.046875,
          "base_ppl": 1.84375,
          "pr_ppl": 1.8359375,
          "source_ast_ppl": 2.96875,
          "base_ast_ppl": 2.5,
          "pr_ast_ppl": 2.5,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B introduces labeled jumps and artificial nesting, which makes the code less readable and more machine-like. The use of goto statements and nested while loops without clear semantic structure can confuse human readers and make the logic harder to follow.",
          "winner": "BASE"
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate B introduces a more structured and readable control flow by replacing the goto statement with an if-else condition, which aligns better with idiomatic design principles. The nested while loop is also clearly defined, making the code easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = (((*(id)))) - str;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 12)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  12;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 2.0,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.546875,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces type mismatches and incorrect pointer arithmetic, which deviates from the Source Code structure. Candidate A maintains the correct use of types and pointer arithmetic, thus aligning better with the Source Code.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate B introduces an artificial wrapper block and uses pointer arithmetic which makes the code less idiomatic and harder to understand for humans.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id, type *id){\n  type id = id;\n  type id[8192];\n  type *id = id;\n  type *id = id + id;\n  type *id = id;\n  type id;\n  type id = 0;\n  {\n    id = (type)id;\n  }\n  {\n    type id;\n    type id = 0;\n    type *id;\n    type *id;\n    type id;\n    lbl:\n    {\n    }\n    if(id == id && id != id)goto lbl;\n    if(id == id){\n      if(id[id] > 0){\n        id = (type)id[id] - 1;\n      }\n    }else{\n      id = (id + (id[id]));\n      id = (type)id[id];\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + id - 1;\n        type *id;\n        while(1){\n          if(id < id){\n            id = id;\n            id = (type)id;\n            break;\n          }\n          id = id + ((id - id) >> 1);\n          if(((*(id))) < (*(id)))id = id - 1;elseif(((*(id))) > (*(id)))id = id + 1;else{\n            id = (type)(id - id);\n            goto lbl;\n          }\n        }\n      }\n      id = (type)id[id];\n      if(id > 0){\n        type *id = id;\n        type *id = id + (id << 1) - 2;\n        type *id;\n        while(1){\n          if(id < id){\n            id = (type)id;\n            break;\n          }\n          id = id + (((id - id) >> 1) & ~1);\n          if(((*(id))) < (*(id)))id = id - 2;elseif(((*(id))) > (*(id + 1)))id = id + 2;else{\n            id = (type)((id - id) >> 1);\n            break;\n          }\n        }\n      }\n      lbl:\n      {\n      }\n    }\n    id = (type)id[id];\n    if(id[id] != 0){\n      id = (id + (id[id]));\n      id = (type)(*(id));\n      id = 1;\n      while(id > 0){\n        switch((*(id))){\n          case 0:\n            {\n              {\n                id = 10 * id + ((((*(id)))) - str);\n              }\n              break;\n            }\n          case 1:\n            {\n              {\n                id = 0;\n              }\n              break;\n            }\n          case 2:\n            {\n              {\n                id = (((*(id)))) - str;\n              }\n              break;\n            }\n          case 3:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 4:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n          case 5:\n            {\n              {\n                id->id = id;\n              }\n              break;\n            }\n        }\n        id = 1;\n        id = 1;\n      }\n    }\n    if(id == id){\n      if(id >= 12)goto lbl;\n    }else{\n      if(id != 0){\n        id = 1;\n        goto lbl;\n      }\n    }\n    lbl:\n    {\n    }\n  }\n  id\n  12;\n  id != id\n  {\n    if(id){\n      call(id, (id), str, (type)id, (type)id, id);\n      call(id, id);\n    }\n    id = id;\n  }\n  (type)id;\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)id[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id(type *id, type id, type *id, type *id, type id){\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id[8200];\n  id = id + id;\n  id = 0;\n  id = 1;\n  id = 0;\n  id = id;\n  do{\n    id = id;\n    if(id == id){\n      if(id != 0xd){\n        id = call((type)(type)id[id] - 1);\n      }\n    }else{\n      id = (type)id;\n      id = id + (type)id[id];\n      id = (type)(type)id[id];\n      if((0xdaUL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + ((type)id - 1);\n        if(id <= id){\n          id = id;\n          do{\n            while(bool){\n              id = (type)id - (type)id >> 1;\n              id = id + id;\n              if(*id < (type)id[id])break;\n              if(*id <= (type)id[id]){\n                id = call(((type)id - (type)id) + id);\n                goto lbl;\n              }\n              id = id + 1;\n              if(id < id)goto lbl;\n            }\n            id = id + -1;\n          }while(id <= id);\n        }\n        lbl:\n        id = id + id;\n        id = id + id;\n      }\n      id = (type)id;\n      if((0xfb6UL >> (id & 0x3f) & 1) != 0){\n        id = (type)(type)id[id];\n        id = id + (type)id * 2 + -2;\n        if(id <= id){\n          id = id;\n          do{\n            while(id = (type)id - (type)id >> 1 & 0xfffffffffffffffe*id < (type)id[id]){\n              id = id + (id - 2);\n              if(id < id)goto lbl;\n            }\n            if(*id <= (type)id[id + 1]){\n              id = call(call(id + (id - (type)id)) >> 1);\n              break;\n            }\n            id = id + id + 2;\n          }while(id <= id);\n        }\n        lbl:\n        id = call(id + id);\n      }\n    }\n    lbl:\n    id = (type)(type)(&id)[id];\n    if((0xbfff556ad5U >> (id & 0x3f) & 1) == 0){\n      id = id[id];\n      id = id[id];\n      if(id != str){\n        id = 0;\n        do{\n          switch(*(type)((type)id + 0x1020c9 + id)){\n            case 0:\n              id = (type)*id + id * 10 + -0x30;\n              break;\n            case 1:\n              id = 0;\n              break;\n            case 2:\n              id = *id + -0x30;\n              break;\n            case 3:\n              id[2] = id;\n              break;\n            case 4:\n              id[1] = id;\n              break;\n            case 5:\n              *id = id;\n          }\n          id = id + 1;\n        }while((type)id != (type)id);\n      }\n    }\n    if((id == id) || (id = id + 1(0x7ff8aad5abU >> (id & 0x3f) & 1) == 0)){\n      if(((id != id) || (id = 0(0xbffff5ffffU >> (id & 0x3f) & 1) != 0)) && (id = 0x1did != (type)0x0)){\n        call(id, 0x2000, str, id & 0xffffffff, id & 0xffffffff, id);\n        call(id, id);\n        id = 0x1d;\n      }\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 2.0,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.546875,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces type casting and pointer arithmetic that are not present in the Source Code, which may indicate a regression in structural fidelity.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Candidate B introduces an artificial wrapper block and uses pointer arithmetic which makes the code less intuitive and harder to understand compared to Candidate A, which maintains cleaner and more idiomatic control flow.",
          "winner": "BASE"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < 0){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(0 < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.203125,
          "base_ppl": 2.265625,
          "pr_ppl": 2.25,
          "source_ast_ppl": 3.890625,
          "base_ast_ppl": 2.9375,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type *id = null;\n  type id, id;\n  type *id;\n  type *id;\n  type id, id, id = 0;\n  type id = id->id & id;\n  type id = id->id;\n  type *id = call(id unsigned char id->id);\n  type id = id->id;\n  type id = 0;\n  type id;\n  if((id->id & id) == 0)return 0;\n  for(id = 0;  id < id; id++){\n    type id;\n    if(id < call(id, call(id[id].id)))continue;\n    if(id[id].id < 0){\n      id = call(id);\n    }else{\n      id = call(id, id[id].id.id, call(id, id[id].id)) == 0;\n    }\n    if(!id)continue;\n    if(!id){\n      type id;\n      call(&id, 0, (id));\n      id.id = id;\n      id = call(id, &id, &id) != -1;\n    }\n    id = id;\n    call(id);\n    id = call(id, id->id, id, (id->id & id), id, &id, &id);\n    call(str, id, (type)id, id);\n    switch(id){\n      case id:\n      case id:\n        id->id = ~id;\n        if(id == id)id = call(id, id, id);elseid = call(id, -1, null, id, id, id);\n        if(id == -1)goto lbl;\n        id = 1;\n        if((id->id & id) != 0)goto lbl;\n        if(id != id && id != 0)goto lbl;\n        if((call(id, (id ? str : str))) == -1)goto lbl;\n        if((id = call(id)) == null)goto lbl;\n        if(call(id, -1, null, null, id, id) == -1){\n          if(call(id, id) != null)call();\n          goto lbl;\n        }\n        if((id = call(id, id)) != null){\n          if(call(id, str, id) == -1){\n            call(id);\n            goto lbl;\n          }\n          call(id);\n        }\n        if(!id && call(id, str) == -1)goto lbl;\n      case id:\n        break;\n      case def:\n        call();\n        lbl:\n        id = -1;\n        break;\n    }\n  }\n  lbl:\n  call(str, id);\n  if(id && id.id != id)(type)call(id, &id, null);\n  call(id);\n  id->id = id;\n  call(str, id);\n  return id;\n}",
        "base_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if((type)-id < 0){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "pr_ast": "type id( id, type *id, type id){\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id[144];\n  type id[19];\n  id = (type)0x0;\n  id = 0;\n  if((*(type)(id + 0x44) & 4) != 0){\n    id = *(type)(id + 0x44) & 0x410;\n    id = *id;\n    id = *(type)(id + 0x26);\n    id = *(type)(id + 0x28);\n    id = str;\n    if(id == 0){\n      id = str;\n    }\n    id = (type)&id;\n    id = bool;\n    id = 0;\n    id = 0;\n    id = id;\n    do{\n      id = *id;\n      id = -id;\n      if(0 < (type)id){\n        id = id;\n      }\n      if(id <= id){\n        if(id - 0xdU < 2){\n          id = call(id);\n          if(id != 0){\n            lbl:\n            id = !id;\n            id = bool;\n            if(id){\n              call(id, 0, 0x90);\n              id = (type)0x1;\n              id = call(0xd, (type)&id, (type)id);\n              id = id != -1;\n            }\n            id = id;\n            call(id);\n            id = call(id, *(type)(id + 0x120), id, *(type)(id + 0x44) & 0x4000000, id, &id, &id);\n            if(id != 2){\n              if(id == 1)goto lbl;\n              if(id != 0)goto lbl;\n            }\n            *(type)(id + 0x44) = *(type)(id + 0x44) & 0xfb;\n            if(id == 2){\n              id = call(id, id, id);\n            }else{\n              id = call(id, 0xffffffff, 0, id, id, id);\n            }\n            if(id != -1){\n              id = 1;\n              if(((*(type)(id + 0x47) & 2) != 0) || ((id != 0x410 && (id != 0))))break;\n              id = call(id, id);\n              if((id != -1) && (id = call(id)id != 0)){\n                id = call(id, 0xffffffff, 0, 0, id, id);\n                id = (type)call(id.id, id);\n                id = (type)call(id, id);\n                if((type)id == -1){\n                  if(id != (type)0x0){\n                    lbl:\n                    call();\n                  }\n                }else{\n                  if(id != (type)0x0){\n                    id = id;\n                    id = call(id, str, id);\n                    call(id);\n                    if(id == -1)goto lbl;\n                  }\n                  id = 1;\n                  if((id != 0) || (id = call(id, &id)id != -1))goto lbl;\n                }\n              }\n            }\n            lbl:\n            id = 0xffffffff;\n          }\n        }else{\n          id = call(id, *(type)(id + -2), (type)id);\n          if(id == 0)goto lbl;\n        }\n      }\n      lbl:\n      id = id + 1;\n      id = id + 8;\n    }while(id != 0xf);\n    if((id) && (id[0].id != (type)0x1)){\n      call(0xd, (type)id, (type)0x0);\n    }\n    call(id);\n    *(type)(id + 0x44) = *(type)(id + 0x44) | 4;\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 3.203125,
          "base_ppl": 2.265625,
          "pr_ppl": 2.25,
          "source_ast_ppl": 3.890625,
          "base_ast_ppl": 2.9375,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave BASE in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "type id(type *id, type *id, type *id){\n  type id = 0;\n  type id = id;\n  type *id = id->id;\n  type *id = call(1, (id));\n  type *id = call(1, (id));\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id > 0)id->id = id->id;\n  if(call(id, id->id) == -1){\n    id = id;\n    goto lbl;\n  }\n  if((id->id = call(0, id, id->id)) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if(call(0, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id, id, id->id.id, id)) != id){\n    goto lbl;\n  }\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = call() ^ id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  id->id = (id->id ? 8 : 4);\n  id->id = id->id;\n  id->id = id->id;\n  id->id = id->id;\n  if(id->id == null){\n    id->id = id->id;\n  }\n  if((id->id = call(id->id)) == null){\n    id = id;\n    goto lbl;\n  }\n  if(id->id && id->id && call(id->id, id->id) != 0){\n    type id = call(id->id, id->id);\n    if(id == (id) - 1){\n      id = id;\n      goto lbl;\n    }\n    id->id = id;\n  }\n  if((id = call(id->id, (id->id), id->id, (id->id), id->id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, &id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, id)) != id){\n    goto lbl;\n  }\n  if(call(id->id, id, id->id) == -1){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  if((id = call(id, 0)) != id){\n    goto lbl;\n  }\n  if(id->id.id && id->id != id->id){\n    id = id;\n    if(id->id.id){\n      call(id->id, (id->id), str, id->id, id->id);\n      call(id->id, id->id);\n    }\n    goto lbl;\n  }\n  if((id = call(id)) != id){\n    goto lbl;\n  }\n  lbl:\n  call(id->id);\n  if(id == id || id == id || id == id){\n    if(id->id.id){\n      call(id->id, (id->id), str, call(id), id, call(id), id);\n      call(id->id, id);\n    }\n  }\n  if(id)call(id);\n  if(id)call(id);\n  return id;\n}",
        "base_ast": "type id(type *id, type id, type id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = *(type)((type)id + 0x40);\n  id = id;\n  id = id;\n  id = id;\n  id = call(1, 0xdd0);\n  id = call(1, 0x180);\n  call(id, id, 0x40);\n  *(type)((type)id + 0x120) = *(type)((type)id + 0x48);\n  *(type)((type)id + 0x128) = *(type)((type)id + 0x50);\n  *(type)((type)id + 0x58) = id;\n  *(type)((type)id + 0x60) = *(type)((type)id + 0x40);\n  *(type)((type)id + 0x80) = (type)*(type)((type)id + 0x58);\n  if(0 < *(type)((type)id + 0x60)){\n    *(type)((type)id + 0x84) = (type)*(type)((type)id + 0x60);\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n  }else{\n    id = call(0, 2, id[5]);\n    *(type)((type)id + 0x40) = id;\n    if(id == -1){\n      id = 0xf;\n      if(*(type)((type)id + 0x30) != 0){\n        call((type)((type)id + 0x5ce), 0x800, str);\n        call((type)id + 0x5ce, *(type)((type)id + 0x58));\n      }\n    }else{\n      id = call(0, 0, id[5]);\n      if(id == -1){\n        id = 0xf;\n        if(*(type)((type)id + 0x30) != 0){\n          call((type)((type)id + 0x5ce), 0x800, str);\n          call((type)id + 0x5ce, *(type)((type)id + 0x58));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id + 0x30), id);\n        if(id == 0){\n          *(type)((type)id + 0x4c) = id[1];\n          *(type)((type)id + 0x48) = *id;\n          *(type)((type)id + 0x50) = id[2];\n          id = call();\n          *(type)((type)id + 0x68) = id ^ *id;\n          *(type)((type)id + 0x88) = *(type)(id + 0x10);\n          *(type)((type)id + 0x90) = *(type)(id + 0xe);\n          *(type)((type)id + 0x98) = *(type)(id + 8);\n          *(type)((type)id + 0xb0) = *(type)(id + 10);\n          *(type)((type)id + 0xc0) = *(type)(id + 0xc);\n          id = 4;\n          if(*(type)((type)id + 0x4c) != 0){\n            id = 8;\n          }\n          *(type)((type)id + 0xb8) = (type)id;\n          *(type)((type)id + 0x138) = *(type)(id + 0x12);\n          *(type)((type)id + 0x140) = *(type)(id + 0x14);\n          *(type)((type)id + 0x148) = id[3];\n          if(*(type)((type)id + 0x120) == 0){\n            *(type)((type)id + 0x120) = *(type)(id + 0x5e);\n          }\n          id = call(*(type)((type)id + 0x98));\n          *(type)((type)id + 0xa0) = id;\n          if(id == 0){\n            id = 3;\n          }else{\n            if(((*(type)((type)id + 0x120) != 0) && (*(type)((type)id + 0x128) != 0)) && (id = call(*(type)((type)id + 0x120), *(type)((type)id + 0x128))id != 0)){\n              id = call(*(type)((type)id + 0x128), *(type)((type)id + 0x120));\n              if(id == (type)0xffffffffffffffff){\n                id = 7;\n                goto lbl;\n              }\n              *(type)((type)id + 0x130) = id;\n            }\n            id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, *(type)((type)id + 0x130));\n            if(((id == 0) && (id = call(id, &id)id == 0)) && (id = call(id, id)id == 0)){\n              id = call(*(type)((type)id + 0x88), 0, id[5]);\n              if(id == -1){\n                id = 0xf;\n                if(*(type)((type)id + 0x30) != 0){\n                  call((type)((type)id + 0x5ce), 0x800, str, *(type)((type)id + 0x88));\n                  call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                }\n              }else{\n                id = call(id);\n                if((id == 0) && (id = call(id, 0)id == 0)){\n                  if((*(type)((type)id + 0x20) == 0) || (*(type)((type)id + 0x78) == *(type)((type)id + 0x80))){\n                    id = call(id);\n                  }else{\n                    id = 9;\n                    if(*(type)((type)id + 0x30) != 0){\n                      call((type)((type)id + 0x5ce), 0x800, str, (id) * (type)((type)id + 0x80), (id) * (type)((type)id + 0x78));\n                      call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[5]);\n  if((((id == 1) || (id == 2)) || (id == 0xf)) && (*(type)((type)id + 0x30) != 0)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id + 0x5ce), 0x800, str, id, (type)id, id, *id);\n    call((type)id + 0x5ce, id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "pr_ast": "type id(type *id, type id, type id){\n  type *id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  id = 0;\n  id = *(type)((type)id + 0x40);\n  id = id;\n  id = id;\n  id = id;\n  id = call(1, 0xdd0);\n  id = (type)call(1, 0x180);\n  call(id, id, 0x40);\n  *(type)((type)id + 0x120) = *(type)((type)id + 0x48);\n  *(type)((type)id + 0x128) = *(type)((type)id + 0x50);\n  *(type)((type)id + 0x58) = id;\n  *(type)((type)id + 0x60) = *(type)((type)id + 0x40);\n  *(type)((type)id + 0x80) = (type)*(type)((type)id + 0x58);\n  if(0 < *(type)((type)id + 0x60)){\n    *(type)((type)id + 0x84) = (type)*(type)((type)id + 0x60);\n  }\n  id = call(id, id[5]);\n  if(id == -1){\n    id = 1;\n  }else{\n    id = call(0, 2, id[5]);\n    *(type)((type)id + 0x40) = id;\n    if(id == -1){\n      id = 0xf;\n      if(*(type)((type)id + 0x30) != 0){\n        call((type)((type)id + 0x5ce), 0x800, str);\n        call((type)id + 0x5ce, *(type)((type)id + 0x58));\n      }\n    }else{\n      id = call(0, 0, id[5]);\n      if(id == -1){\n        id = 0xf;\n        if(*(type)((type)id + 0x30) != 0){\n          call((type)((type)id + 0x5ce), 0x800, str);\n          call((type)id + 0x5ce, *(type)((type)id + 0x58));\n        }\n      }else{\n        id = call(id, id, *(type)((type)id + 0x30), id);\n        if(id == 0){\n          *(type)((type)id + 0x4c) = id[1];\n          *(type)((type)id + 0x48) = *id;\n          *(type)((type)id + 0x50) = id[2];\n          id = call();\n          *(type)((type)id + 0x68) = id ^ *id;\n          *(type)((type)id + 0x88) = *(type)(id + 0x10);\n          *(type)((type)id + 0x90) = *(type)(id + 0xe);\n          *(type)((type)id + 0x98) = *(type)(id + 8);\n          *(type)((type)id + 0xb0) = *(type)(id + 10);\n          *(type)((type)id + 0xc0) = *(type)(id + 0xc);\n          id = 4;\n          if(*(type)((type)id + 0x4c) != 0){\n            id = 8;\n          }\n          *(type)((type)id + 0xb8) = (type)id;\n          *(type)((type)id + 0x138) = *(type)(id + 0x12);\n          *(type)((type)id + 0x140) = *(type)(id + 0x14);\n          *(type)((type)id + 0x148) = id[3];\n          if(*(type)((type)id + 0x120) == 0){\n            *(type)((type)id + 0x120) = *(type)(id + 0x5e);\n          }\n          id = call(*(type)((type)id + 0x98));\n          *(type)((type)id + 0xa0) = id;\n          if(id == 0){\n            id = 3;\n          }else{\n            if(((*(type)((type)id + 0x120) != 0) && (*(type)((type)id + 0x128) != 0)) && (id = call(*(type)((type)id + 0x120), *(type)((type)id + 0x128))id != 0)){\n              id = call(*(type)((type)id + 0x128), *(type)((type)id + 0x120));\n              if(id == (type)0xffffffffffffffff){\n                id = 7;\n                goto lbl;\n              }\n              *(type)((type)id + 0x130) = id;\n            }\n            id = call((type)id + 0x14c, 0x81, id + 0x16, 0x20, *(type)((type)id + 0x130));\n            if(((id == 0) && (id = call(id, &id)id == 0)) && (id = call(id, id)id == 0)){\n              id = call(*(type)((type)id + 0x88), 0, id[5]);\n              if(id == -1){\n                id = 0xf;\n                if(*(type)((type)id + 0x30) != 0){\n                  call((type)((type)id + 0x5ce), 0x800, str, *(type)((type)id + 0x88));\n                  call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                }\n              }else{\n                id = call(id);\n                if((id == 0) && (id = call(id, 0)id == 0)){\n                  if((*(type)((type)id + 0x20) == 0) || (*(type)((type)id + 0x78) == *(type)((type)id + 0x80))){\n                    id = call(id);\n                  }else{\n                    id = 9;\n                    if(*(type)((type)id + 0x30) != 0){\n                      call((type)((type)id + 0x5ce), 0x800, str, (id) * (type)((type)id + 0x80), (id) * (type)((type)id + 0x78));\n                      call((type)id + 0x5ce, *(type)((type)id + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  lbl:\n  call(id[5]);\n  if((((id == 1) || (id == 2)) || (id == 0xf)) && (*(type)((type)id + 0x30) != 0)){\n    id = call(id);\n    id = call();\n    id = call(*id);\n    id = call();\n    call((type)((type)id + 0x5ce), 0x800, str, id, (type)id, id, *id);\n    call((type)id + 0x5ce, id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  if(id != (type)0x0){\n    call(id);\n  }\n  return id;\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.75,
          "pr_ppl": 1.7421875,
          "source_ast_ppl": 1.984375,
          "base_ast_ppl": 1.8828125,
          "pr_ast_ppl": 1.8828125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B introduces a type cast that is not present in the Source Code, which could be considered noise and does not align with the Source structure.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O2.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      param_3 = __src;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      param_3 = __src + sVar2;\n      if (pbVar3 < param_3) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    param_3 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    if (pbVar3 <= param_3) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  byte *__src;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    __src = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < __src + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    pbVar7 = __src;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      __src = param_3 + 2;\n      goto LAB_001012f3;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_001012f0;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      __src = param_3 + 3;\n      break;\n    case 5:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      __src = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_001012f0;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_001012f0;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_001012f0;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_001012f0:\n      sVar2 = (size_t)uVar1;\nLAB_001012f3:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = __src + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),__src,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      __src = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    pbVar7 = __src;\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id){\n  type *id = (type)id;\n  type *id = id;\n  type id = 0;\n  type *id = (type)id;\n  while(id < (type)id + id){\n    type id = *id++;\n    type id = (id & 0xF0) >> 4;\n    type id = (id & 0x0F);\n    type id = 0;\n    type id = 0;\n    type id = str;\n    if(id + id[id] > (type)id + id){\n      return -1;\n    }\n    switch(id){\n      case id:\n        id = (*id++) + 64 + id * 256;\n        break;\n      case id:\n        id = (*id++) + 64 + id * 256 + 4096;\n        break;\n      case id:\n        id = id + 96;\n        break;\n      case id:\n        id = (*id++) + 18 + id * 256;\n        id = *id++;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = id + 1;\n        break;\n      case id:\n        id = id + 17;\n        break;\n      case id:\n        id = id + 33;\n        break;\n      case id:\n        id = id + 49;\n        break;\n      case id:\n        id = *id++;\n        id = id + 3;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id + id > id){\n        return -1;\n      }\n      if(id + id > (type)id + id){\n        return -1;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id + id > id){\n        return -1;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id( id, type id, type *id,  id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  if(id < 1){\n    return 0;\n  }\n  id = id + id;\n  id = 0;\n  do{\n    id = id + 1;\n    id = *id >> 4;\n    if(id < id + *(type)(id + (type)(type)id * 8)){\n      return 0xffffffffffffffff;\n    }\n    if(0xf < id){\n      lbl:\n      id = id;\n      id = id;\n      goto lbl;\n    }\n    id = *id & 0xf;\n    switch((type)id){\n      case 0:\n        id = (type)id[1] + call(id << 8) + 0x40;\n        goto lbl;\n      case 1:\n        id = (type)id[1] + call(id << 8) + 0x1040;\n        lbl:\n        id = id + 2;\n        goto lbl;\n      case 2:\n        id = id + 0x60;\n        goto lbl;\n      case 3:\n        goto lbl;\n      case 4:\n        id = (type)id[1] + call(id << 8) + 0x12;\n        id = id[2];\n        id = id + 3;\n        break;\n      case 5:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x40;\n        break;\n      case 6:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x20;\n        break;\n      case 7:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0;\n        break;\n      case 8:\n        id = id + 1;\n        goto lbl;\n      case 9:\n        id = id + 0x11;\n        goto lbl;\n      case 10:\n        id = id + 0x21;\n        goto lbl;\n      case 0xb:\n        id = id + 0x31;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        if(id != 0){\n          call((type)(id + id), id, id);\n        }\n        goto lbl;\n      case 0xc:\n        id = id[1];\n        id = id + 2;\n        id = (type)(id + 3);\n        break;\n      case 0xd:\n        id = (type)(id + 2);\n        id = 0x40;\n        break;\n      case 0xe:\n        id = (type)(id + 2);\n        id = 0x20;\n        break;\n      case 0xf:\n        id = (type)(id + 2);\n        id = 0;\n    }\n    id = id + id;\n    if(id < id){\n      return 0xffffffffffffffff;\n    }\n    id = id;\n    if(id != 0){\n      call((type)(id + id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id( id, type id, type *id,  id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  type *id;\n  if(id < 1){\n    return 0;\n  }\n  id = id + id;\n  id = 0;\n  do{\n    id = id + 1;\n    id = *id >> 4;\n    if(id < id + *(type)(id + (type)(type)id * 8)){\n      return 0xffffffffffffffff;\n    }\n    id = id;\n    id = id;\n    if(0xf < id)goto lbl;\n    id = *id & 0xf;\n    switch((type)id){\n      case 0:\n        id = (type)id[1] + call(id << 8) + 0x40;\n        goto lbl;\n      case 1:\n        id = (type)id[1] + call(id << 8) + 0x1040;\n        lbl:\n        id = id + 2;\n        goto lbl;\n      case 2:\n        id = id + 0x60;\n        goto lbl;\n      case 3:\n        goto lbl;\n      case 4:\n        id = (type)id[1] + call(id << 8) + 0x12;\n        id = id[2];\n        id = id + 3;\n        break;\n      case 5:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x40;\n        break;\n      case 6:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x20;\n        break;\n      case 7:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0;\n        break;\n      case 8:\n        id = id + 1;\n        goto lbl;\n      case 9:\n        id = id + 0x11;\n        goto lbl;\n      case 10:\n        id = id + 0x21;\n        goto lbl;\n      case 0xb:\n        id = id + 0x31;\n        lbl:\n        id = (type)id;\n        lbl:\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        if(id != 0){\n          call((type)(id + id), id, id);\n        }\n        goto lbl;\n      case 0xc:\n        id = id[1];\n        id = id + 2;\n        id = (type)(id + 3);\n        break;\n      case 0xd:\n        id = (type)(id + 2);\n        id = 0x40;\n        break;\n      case 0xe:\n        id = (type)(id + 2);\n        id = 0x20;\n        break;\n      case 0xf:\n        id = (type)(id + 2);\n        id = 0;\n    }\n    id = id + id;\n    if(id < id){\n      return 0xffffffffffffffff;\n    }\n    id = id;\n    if(id != 0){\n      call((type)(id + id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.671875,
          "base_ppl": 1.578125,
          "pr_ppl": 1.5703125,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.140625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_ast": {
          "motivation": "Candidate B improves idiomatic design by replacing the goto loop with a more straightforward and clean structure. The removal of artificial nesting and the use of a simple if condition makes the code easier to understand and aligns better with high-level human thinking.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      },
      {
        "binary": "task-readstat_sas_rle_decompress-O3.so",
        "function": "sas_rle_decompress",
        "source_code": "ssize_t sas_rle_decompress(void *output_buf, size_t output_len, \n        const void *input_buf, size_t input_len) {\n    unsigned char *buffer = (unsigned char *)output_buf;\n    unsigned char *output = buffer;\n    size_t output_written = 0;\n\n    const unsigned char *input = (const unsigned char *)input_buf;\n\n    while (input < (const unsigned char *)input_buf + input_len) {\n        unsigned char control = *input++;\n        unsigned char command = (control & 0xF0) >> 4;\n        unsigned char length = (control & 0x0F);\n        int copy_len = 0;\n        int insert_len = 0;\n        unsigned char insert_byte = '\\0';\n        if (input + command_lengths[command] > (const unsigned char *)input_buf + input_len) {\n            return -1;\n        }\n        switch (command) {\n            case SAS_RLE_COMMAND_COPY64:\n                copy_len = (*input++) + 64 + length * 256;\n                break;\n            case SAS_RLE_COMMAND_COPY64_PLUS_4096:\n                copy_len = (*input++) + 64 + length * 256 + 4096;\n                break;\n            case SAS_RLE_COMMAND_COPY96: copy_len = length + 96; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE18:\n                insert_len = (*input++) + 18 + length * 256;\n                insert_byte = *input++;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '@';\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = ' ';\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO17:\n                insert_len = (*input++) + 17 + length * 256;\n                insert_byte = '\\0';\n                break;\n            case SAS_RLE_COMMAND_COPY1:  copy_len = length + 1; break;\n            case SAS_RLE_COMMAND_COPY17: copy_len = length + 17; break;\n            case SAS_RLE_COMMAND_COPY33: copy_len = length + 33; break;\n            case SAS_RLE_COMMAND_COPY49: copy_len = length + 49; break;\n            case SAS_RLE_COMMAND_INSERT_BYTE3:\n                insert_byte = *input++;\n                insert_len = length + 3;\n                break;\n            case SAS_RLE_COMMAND_INSERT_AT2:\n                insert_byte = '@';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_BLANK2:\n                insert_byte = ' ';\n                insert_len = length + 2;\n                break;\n            case SAS_RLE_COMMAND_INSERT_ZERO2:\n                insert_byte = '\\0';\n                insert_len = length + 2;\n                break;\n            default:\n                /* error out here? */\n                break;\n        }\n        if (copy_len) {\n            if (output_written + copy_len > output_len) {\n                return -1;\n            }\n            if (input + copy_len > (const unsigned char *)input_buf + input_len) {\n                return -1;\n            }\n            if (output) {\n                memcpy(&output[output_written], input, copy_len);\n            }\n            input += copy_len;\n            output_written += copy_len;\n        }\n        if (insert_len) {\n            if (output_written + insert_len > output_len) {\n                return -1;\n            }\n            if (output) {\n                memset(&output[output_written], insert_byte, insert_len);\n            }\n            output_written += insert_len;\n        }\n    }\n\n    return output_written;\n}\n",
        "function_base": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    if (0xf < bVar5) {\nswitchD_001011a4_caseD_3:\n      uVar4 = uVar6;\n      goto LAB_00101153;\n    }\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto switchD_001011a4_caseD_3;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nulong sas_rle_decompress(long param_1,ulong param_2,byte *param_3,long param_4)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  byte bVar5;\n  ulong uVar6;\n  byte *pbVar7;\n  \n  if (param_4 < 1) {\n    return 0;\n  }\n  pbVar3 = param_3 + param_4;\n  uVar6 = 0;\n  do {\n    pbVar7 = param_3 + 1;\n    bVar5 = *param_3 >> 4;\n    if (pbVar3 < pbVar7 + *(long *)(command_lengths + (ulong)(uint)bVar5 * 8)) {\n      return 0xffffffffffffffff;\n    }\n    uVar4 = uVar6;\n    if (0xf < bVar5) goto LAB_00101153;\n    uVar1 = *param_3 & 0xf;\n    switch((uint)bVar5) {\n    case 0:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x40;\n      goto LAB_00101240;\n    case 1:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x1040;\nLAB_00101240:\n      param_3 = param_3 + 2;\n      goto joined_r0x0010130a;\n    case 2:\n      uVar1 = uVar1 + 0x60;\n      goto LAB_00101300;\n    case 3:\n      goto LAB_00101153;\n    case 4:\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x12;\n      bVar5 = param_3[2];\n      pbVar7 = param_3 + 3;\n      break;\n    case 5:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x40;\n      break;\n    case 6:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0x20;\n      break;\n    case 7:\n      pbVar7 = param_3 + 2;\n      sVar2 = (ulong)param_3[1] + (ulong)(uVar1 << 8) + 0x11;\n      bVar5 = 0;\n      break;\n    case 8:\n      uVar1 = uVar1 + 1;\n      goto LAB_00101300;\n    case 9:\n      uVar1 = uVar1 + 0x11;\n      goto LAB_00101300;\n    case 10:\n      uVar1 = uVar1 + 0x21;\n      goto LAB_00101300;\n    case 0xb:\n      uVar1 = uVar1 + 0x31;\nLAB_00101300:\n      sVar2 = (size_t)uVar1;\n      param_3 = pbVar7;\njoined_r0x0010130a:\n      uVar4 = sVar2 + uVar6;\n      if (param_2 < uVar4) {\n        return 0xffffffffffffffff;\n      }\n      pbVar7 = param_3 + sVar2;\n      if (pbVar3 < pbVar7) {\n        return 0xffffffffffffffff;\n      }\n      if (param_1 != 0) {\n        memcpy((void *)(uVar6 + param_1),param_3,sVar2);\n      }\n      goto LAB_00101153;\n    case 0xc:\n      bVar5 = param_3[1];\n      pbVar7 = param_3 + 2;\n      sVar2 = (size_t)(uVar1 + 3);\n      break;\n    case 0xd:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x40;\n      break;\n    case 0xe:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0x20;\n      break;\n    case 0xf:\n      sVar2 = (size_t)(uVar1 + 2);\n      bVar5 = 0;\n    }\n    uVar4 = sVar2 + uVar6;\n    if (param_2 < uVar4) {\n      return 0xffffffffffffffff;\n    }\n    if (param_1 != 0) {\n      memset((void *)(uVar6 + param_1),(uint)bVar5,sVar2);\n    }\nLAB_00101153:\n    uVar6 = uVar4;\n    param_3 = pbVar7;\n    if (pbVar3 <= pbVar7) {\n      return uVar4;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "type id(type *id, type id, type *id, type id){\n  type *id = (type)id;\n  type *id = id;\n  type id = 0;\n  type *id = (type)id;\n  while(id < (type)id + id){\n    type id = *id++;\n    type id = (id & 0xF0) >> 4;\n    type id = (id & 0x0F);\n    type id = 0;\n    type id = 0;\n    type id = str;\n    if(id + id[id] > (type)id + id){\n      return -1;\n    }\n    switch(id){\n      case id:\n        id = (*id++) + 64 + id * 256;\n        break;\n      case id:\n        id = (*id++) + 64 + id * 256 + 4096;\n        break;\n      case id:\n        id = id + 96;\n        break;\n      case id:\n        id = (*id++) + 18 + id * 256;\n        id = *id++;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = (*id++) + 17 + id * 256;\n        id = str;\n        break;\n      case id:\n        id = id + 1;\n        break;\n      case id:\n        id = id + 17;\n        break;\n      case id:\n        id = id + 33;\n        break;\n      case id:\n        id = id + 49;\n        break;\n      case id:\n        id = *id++;\n        id = id + 3;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case id:\n        id = str;\n        id = id + 2;\n        break;\n      case def:\n        break;\n    }\n    if(id){\n      if(id + id > id){\n        return -1;\n      }\n      if(id + id > (type)id + id){\n        return -1;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n      id = id;\n    }\n    if(id){\n      if(id + id > id){\n        return -1;\n      }\n      if(id){\n        call(&id[id], id, id);\n      }\n      id = id;\n    }\n  }\n  return id;\n}",
        "base_ast": "type id( id, type id, type *id,  id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  if(id < 1){\n    return 0;\n  }\n  id = id + id;\n  id = 0;\n  do{\n    id = id + 1;\n    id = *id >> 4;\n    if(id < id + *(type)(id + (type)(type)id * 8)){\n      return 0xffffffffffffffff;\n    }\n    if(0xf < id){\n      lbl:\n      id = id;\n      goto lbl;\n    }\n    id = *id & 0xf;\n    switch((type)id){\n      case 0:\n        id = (type)id[1] + call(id << 8) + 0x40;\n        goto lbl;\n      case 1:\n        id = (type)id[1] + call(id << 8) + 0x1040;\n        lbl:\n        id = id + 2;\n        goto lbl;\n      case 2:\n        id = id + 0x60;\n        goto lbl;\n      case 3:\n        goto lbl;\n      case 4:\n        id = (type)id[1] + call(id << 8) + 0x12;\n        id = id[2];\n        id = id + 3;\n        break;\n      case 5:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x40;\n        break;\n      case 6:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x20;\n        break;\n      case 7:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0;\n        break;\n      case 8:\n        id = id + 1;\n        goto lbl;\n      case 9:\n        id = id + 0x11;\n        goto lbl;\n      case 10:\n        id = id + 0x21;\n        goto lbl;\n      case 0xb:\n        id = id + 0x31;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        if(id != 0){\n          call((type)(id + id), id, id);\n        }\n        goto lbl;\n      case 0xc:\n        id = id[1];\n        id = id + 2;\n        id = (type)(id + 3);\n        break;\n      case 0xd:\n        id = (type)(id + 2);\n        id = 0x40;\n        break;\n      case 0xe:\n        id = (type)(id + 2);\n        id = 0x20;\n        break;\n      case 0xf:\n        id = (type)(id + 2);\n        id = 0;\n    }\n    id = id + id;\n    if(id < id){\n      return 0xffffffffffffffff;\n    }\n    if(id != 0){\n      call((type)(id + id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "pr_ast": "type id( id, type id, type *id,  id){\n  type id;\n  type id;\n  type *id;\n  type id;\n  type id;\n  type id;\n  type *id;\n  if(id < 1){\n    return 0;\n  }\n  id = id + id;\n  id = 0;\n  do{\n    id = id + 1;\n    id = *id >> 4;\n    if(id < id + *(type)(id + (type)(type)id * 8)){\n      return 0xffffffffffffffff;\n    }\n    id = id;\n    if(0xf < id)goto lbl;\n    id = *id & 0xf;\n    switch((type)id){\n      case 0:\n        id = (type)id[1] + call(id << 8) + 0x40;\n        goto lbl;\n      case 1:\n        id = (type)id[1] + call(id << 8) + 0x1040;\n        lbl:\n        id = id + 2;\n        goto lbl;\n      case 2:\n        id = id + 0x60;\n        goto lbl;\n      case 3:\n        goto lbl;\n      case 4:\n        id = (type)id[1] + call(id << 8) + 0x12;\n        id = id[2];\n        id = id + 3;\n        break;\n      case 5:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x40;\n        break;\n      case 6:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0x20;\n        break;\n      case 7:\n        id = id + 2;\n        id = (type)id[1] + call(id << 8) + 0x11;\n        id = 0;\n        break;\n      case 8:\n        id = id + 1;\n        goto lbl;\n      case 9:\n        id = id + 0x11;\n        goto lbl;\n      case 10:\n        id = id + 0x21;\n        goto lbl;\n      case 0xb:\n        id = id + 0x31;\n        lbl:\n        id = (type)id;\n        id = id;\n        lbl:\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        id = id + id;\n        if(id < id){\n          return 0xffffffffffffffff;\n        }\n        if(id != 0){\n          call((type)(id + id), id, id);\n        }\n        goto lbl;\n      case 0xc:\n        id = id[1];\n        id = id + 2;\n        id = (type)(id + 3);\n        break;\n      case 0xd:\n        id = (type)(id + 2);\n        id = 0x40;\n        break;\n      case 0xe:\n        id = (type)(id + 2);\n        id = 0x20;\n        break;\n      case 0xf:\n        id = (type)(id + 2);\n        id = 0;\n    }\n    id = id + id;\n    if(id < id){\n      return 0xffffffffffffffff;\n    }\n    if(id != 0){\n      call((type)(id + id), (type)id, id);\n    }\n    lbl:\n    id = id;\n    id = id;\n    if(id <= id){\n      return id;\n    }\n  }while(bool);\n}",
        "metrics": {
          "source_ppl": 1.671875,
          "base_ppl": 1.5625,
          "pr_ppl": 1.546875,
          "source_ast_ppl": 2.03125,
          "base_ast_ppl": 2.15625,
          "pr_ast_ppl": 2.171875,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        },
        "llm_qualitative_source": {
          "motivation": "Candidate B aligns more closely with the Source Code structure by preserving the original switch-case control flow and removing unnecessary goto statements.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B improves idiomatic design by replacing the goto cycle with a simple assignment and conditional statement, making the control flow cleaner and more reflective of high-level human thinking.",
          "winner": "PR"
        },
        "llm_ast_source": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response (Position Bias); declaring TIE. the LLM gave PR in both original and swapped prompts.",
          "raw_response1": "",
          "raw_response2": ""
        }
      }
    ]
  }
}